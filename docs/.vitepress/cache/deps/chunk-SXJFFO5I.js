import {
  Delaunay,
  Symbol as Symbol2,
  albersUsa_default,
  albers_default,
  arc_default,
  area_default,
  area_default2,
  ascending,
  azimuthalEqualArea_default,
  azimuthalEquidistant_default,
  basisClosed_default,
  basisOpen_default,
  basis_default,
  binary_default,
  bisectLeft,
  bisectRight,
  bisect_default,
  bisector,
  bounds_default,
  bundle_default,
  cardinalClosed_default,
  cardinalOpen_default,
  cardinal_default,
  catmullRomClosed_default,
  catmullRomOpen_default,
  catmullRom_default,
  center_default,
  centroid_default,
  cluster_default,
  collide_default,
  conicConformal_default,
  conicEqualArea_default,
  conicEquidistant_default,
  deviation,
  dice_default,
  diverging,
  divergingLog,
  divergingPow,
  divergingSqrt,
  divergingSymlog,
  dsv_default,
  equalEarth_default,
  equirectangular_default,
  format,
  formatLocale,
  formatPrefix,
  formatSpecifier,
  gnomonic_default,
  graticule,
  hcl,
  hierarchy,
  hsl,
  identity,
  identity_default,
  implicit,
  intersection,
  interval_default,
  lab,
  line_default,
  linear,
  linearClosed_default,
  linear_default,
  link_default,
  locale_default,
  log,
  manyBody_default,
  max,
  mean,
  median,
  mercator_default,
  millisecond,
  min,
  monotoneX,
  monotoneY,
  naturalEarth1_default,
  natural_default,
  ordinal,
  orthographic_default,
  pack_default,
  partition_default,
  path,
  path_default,
  permute,
  piecewise,
  pow,
  precisionFixed_default,
  precisionPrefix_default,
  precisionRound_default,
  projection,
  quantile,
  quantile2,
  quantileSorted,
  quantize,
  range,
  resquarify_default,
  rgb,
  round_default,
  second,
  sequential,
  sequentialLog,
  sequentialPow,
  sequentialSqrt,
  sequentialSymlog,
  simulation_default,
  sliceDice_default,
  slice_default,
  sqrt,
  squarify_default,
  src_exports,
  stepAfter,
  stepBefore,
  step_default,
  stereographic_default,
  stratify_default,
  sum,
  symlog,
  threshold,
  tickFormat,
  tickStep,
  time,
  timeDay,
  timeFormat,
  timeHour,
  timeMinute,
  timeMonth,
  timeParse,
  timeSunday,
  timeYear,
  transverseMercator_default,
  tree_default,
  treemap_default,
  union,
  utcDay,
  utcFormat,
  utcHour,
  utcMinute,
  utcMonth,
  utcParse,
  utcSunday,
  utcTime,
  utcYear,
  value_default,
  x_default,
  y_default
} from "./chunk-P5KQ2UN2.js";
import {
  __export
} from "./chunk-UV5CTPV7.js";

// node_modules/vega/build/vega.module.js
var vega_module_exports = {};
__export(vega_module_exports, {
  Bounds: () => Bounds,
  CanvasHandler: () => CanvasHandler,
  CanvasRenderer: () => CanvasRenderer,
  DATE: () => DATE,
  DAY: () => DAY,
  DAYOFYEAR: () => DAYOFYEAR,
  Dataflow: () => Dataflow,
  Debug: () => Debug,
  Error: () => Error$1,
  EventStream: () => EventStream,
  Gradient: () => Gradient,
  GroupItem: () => GroupItem,
  HOURS: () => HOURS,
  Handler: () => Handler,
  HybridHandler: () => HybridHandler,
  HybridRenderer: () => HybridRenderer,
  Info: () => Info,
  Item: () => Item,
  MILLISECONDS: () => MILLISECONDS,
  MINUTES: () => MINUTES,
  MONTH: () => MONTH,
  Marks: () => Marks,
  MultiPulse: () => MultiPulse,
  None: () => None,
  Operator: () => Operator,
  Parameters: () => Parameters,
  Pulse: () => Pulse,
  QUARTER: () => QUARTER,
  RenderType: () => RenderType,
  Renderer: () => Renderer,
  ResourceLoader: () => ResourceLoader,
  SECONDS: () => SECONDS,
  SVGHandler: () => SVGHandler,
  SVGRenderer: () => SVGRenderer,
  SVGStringRenderer: () => SVGStringRenderer,
  Scenegraph: () => Scenegraph,
  TIME_UNITS: () => TIME_UNITS,
  Transform: () => Transform,
  View: () => View,
  WEEK: () => WEEK,
  Warn: () => Warn,
  YEAR: () => YEAR,
  accessor: () => accessor,
  accessorFields: () => accessorFields,
  accessorName: () => accessorName,
  array: () => array,
  ascending: () => ascending2,
  bandwidthNRD: () => estimateBandwidth,
  bin: () => bin2,
  bootstrapCI: () => bootstrapCI,
  boundClip: () => boundClip,
  boundContext: () => boundContext,
  boundItem: () => boundItem,
  boundMark: () => boundMark,
  boundStroke: () => boundStroke,
  changeset: () => changeset,
  clampRange: () => clampRange,
  codegenExpression: () => codegen,
  compare: () => compare,
  constant: () => constant,
  cumulativeLogNormal: () => cumulativeLogNormal,
  cumulativeNormal: () => cumulativeNormal,
  cumulativeUniform: () => cumulativeUniform,
  dayofyear: () => dayofyear,
  debounce: () => debounce,
  defaultLocale: () => defaultLocale,
  definition: () => definition,
  densityLogNormal: () => densityLogNormal,
  densityNormal: () => densityNormal,
  densityUniform: () => densityUniform,
  domChild: () => domChild,
  domClear: () => domClear,
  domCreate: () => domCreate,
  domFind: () => domFind,
  dotbin: () => dotbin,
  error: () => error,
  expressionFunction: () => expressionFunction,
  extend: () => extend,
  extent: () => extent,
  extentIndex: () => extentIndex,
  falsy: () => falsy,
  fastmap: () => fastmap,
  field: () => field,
  flush: () => flush,
  font: () => font,
  fontFamily: () => fontFamily,
  fontSize: () => fontSize,
  format: () => format2,
  formatLocale: () => numberFormatDefaultLocale,
  formats: () => formats,
  hasOwnProperty: () => has,
  id: () => id,
  identity: () => identity2,
  inferType: () => inferType,
  inferTypes: () => inferTypes,
  ingest: () => ingest$1,
  inherits: () => inherits,
  inrange: () => inrange,
  interpolate: () => interpolate,
  interpolateColors: () => interpolateColors,
  interpolateRange: () => interpolateRange,
  intersect: () => intersect,
  intersectBoxLine: () => intersectBoxLine,
  intersectPath: () => intersectPath,
  intersectPoint: () => intersectPoint,
  intersectRule: () => intersectRule,
  isArray: () => isArray,
  isBoolean: () => isBoolean,
  isDate: () => isDate,
  isFunction: () => isFunction,
  isIterable: () => isIterable,
  isNumber: () => isNumber,
  isObject: () => isObject,
  isRegExp: () => isRegExp,
  isString: () => isString,
  isTuple: () => isTuple,
  key: () => key,
  lerp: () => lerp,
  lineHeight: () => lineHeight,
  loader: () => loader,
  locale: () => locale,
  logger: () => logger,
  lruCache: () => lruCache,
  markup: () => markup,
  merge: () => merge,
  mergeConfig: () => mergeConfig,
  multiLineOffset: () => multiLineOffset,
  one: () => one,
  pad: () => pad,
  panLinear: () => panLinear,
  panLog: () => panLog,
  panPow: () => panPow,
  panSymlog: () => panSymlog,
  parse: () => parse6,
  parseExpression: () => parser,
  parseSelector: () => eventSelector,
  path: () => path,
  pathCurves: () => curves,
  pathEqual: () => pathEqual,
  pathParse: () => parse4,
  pathRectangle: () => vg_rect,
  pathRender: () => pathRender,
  pathSymbols: () => symbols2,
  pathTrail: () => vg_trail,
  peek: () => peek,
  point: () => point2,
  projection: () => projection2,
  quantileLogNormal: () => quantileLogNormal,
  quantileNormal: () => quantileNormal,
  quantileUniform: () => quantileUniform,
  quantiles: () => quantiles,
  quantizeInterpolator: () => quantizeInterpolator,
  quarter: () => quarter,
  quartiles: () => quartiles,
  random: () => random,
  randomInteger: () => integer,
  randomKDE: () => kde,
  randomLCG: () => lcg,
  randomLogNormal: () => lognormal,
  randomMixture: () => mixture,
  randomNormal: () => gaussian,
  randomUniform: () => uniform,
  read: () => read,
  regressionConstant: () => constant2,
  regressionExp: () => exp2,
  regressionLinear: () => linear2,
  regressionLoess: () => loess,
  regressionLog: () => log3,
  regressionPoly: () => poly,
  regressionPow: () => pow3,
  regressionQuad: () => quad,
  renderModule: () => renderModule,
  repeat: () => repeat,
  resetDefaultLocale: () => resetDefaultLocale,
  resetSVGClipId: () => resetSVGClipId,
  resetSVGDefIds: () => resetSVGDefIds,
  responseType: () => responseType,
  runtimeContext: () => context2,
  sampleCurve: () => sampleCurve,
  sampleLogNormal: () => sampleLogNormal,
  sampleNormal: () => sampleNormal,
  sampleUniform: () => sampleUniform,
  scale: () => scale,
  sceneEqual: () => sceneEqual,
  sceneFromJSON: () => sceneFromJSON,
  scenePickVisit: () => pickVisit,
  sceneToJSON: () => sceneToJSON,
  sceneVisit: () => visit,
  sceneZOrder: () => zorder,
  scheme: () => scheme,
  serializeXML: () => serializeXML,
  setHybridRendererOptions: () => setHybridRendererOptions,
  setRandom: () => setRandom,
  span: () => span,
  splitAccessPath: () => splitAccessPath,
  stringValue: () => $,
  textMetrics: () => textMetrics,
  timeBin: () => bin,
  timeFloor: () => timeFloor,
  timeFormatLocale: () => timeFormatDefaultLocale,
  timeInterval: () => timeInterval,
  timeOffset: () => timeOffset,
  timeSequence: () => timeSequence,
  timeUnitSpecifier: () => timeUnitSpecifier,
  timeUnits: () => timeUnits,
  toBoolean: () => toBoolean,
  toDate: () => toDate,
  toNumber: () => toNumber,
  toSet: () => toSet,
  toString: () => toString,
  transform: () => transform,
  transforms: () => transforms,
  truncate: () => truncate,
  truthy: () => truthy,
  tupleid: () => tupleid,
  typeParsers: () => typeParsers,
  utcFloor: () => utcFloor,
  utcInterval: () => utcInterval,
  utcOffset: () => utcOffset,
  utcSequence: () => utcSequence,
  utcdayofyear: () => utcdayofyear,
  utcquarter: () => utcquarter,
  utcweek: () => utcweek,
  version: () => version,
  visitArray: () => visitArray,
  week: () => week,
  writeConfig: () => writeConfig,
  zero: () => zero,
  zoomLinear: () => zoomLinear,
  zoomLog: () => zoomLog,
  zoomPow: () => zoomPow,
  zoomSymlog: () => zoomSymlog
});

// node_modules/vega-util/build/vega-util.module.js
function accessor(fn, fields, name) {
  fn.fields = fields || [];
  fn.fname = name;
  return fn;
}
function accessorName(fn) {
  return fn == null ? null : fn.fname;
}
function accessorFields(fn) {
  return fn == null ? null : fn.fields;
}
function getter(path3) {
  return path3.length === 1 ? get1(path3[0]) : getN(path3);
}
var get1 = (field3) => function(obj) {
  return obj[field3];
};
var getN = (path3) => {
  const len = path3.length;
  return function(obj) {
    for (let i = 0; i < len; ++i) {
      obj = obj[path3[i]];
    }
    return obj;
  };
};
function error(message) {
  throw Error(message);
}
function splitAccessPath(p) {
  const path3 = [], n = p.length;
  let q = null, b2 = 0, s = "", i, j, c;
  p = p + "";
  function push() {
    path3.push(s + p.substring(i, j));
    s = "";
    i = j + 1;
  }
  for (i = j = 0; j < n; ++j) {
    c = p[j];
    if (c === "\\") {
      s += p.substring(i, j++);
      i = j;
    } else if (c === q) {
      push();
      q = null;
      b2 = -1;
    } else if (q) {
      continue;
    } else if (i === b2 && c === '"') {
      i = j + 1;
      q = c;
    } else if (i === b2 && c === "'") {
      i = j + 1;
      q = c;
    } else if (c === "." && !b2) {
      if (j > i) {
        push();
      } else {
        i = j + 1;
      }
    } else if (c === "[") {
      if (j > i)
        push();
      b2 = i = j + 1;
    } else if (c === "]") {
      if (!b2)
        error("Access path missing open bracket: " + p);
      if (b2 > 0)
        push();
      b2 = 0;
      i = j + 1;
    }
  }
  if (b2)
    error("Access path missing closing bracket: " + p);
  if (q)
    error("Access path missing closing quote: " + p);
  if (j > i) {
    j++;
    push();
  }
  return path3;
}
function field(field3, name, opt) {
  const path3 = splitAccessPath(field3);
  field3 = path3.length === 1 ? path3[0] : field3;
  return accessor((opt && opt.get || getter)(path3), [field3], name || field3);
}
var id = field("id");
var identity2 = accessor((_) => _, [], "identity");
var zero = accessor(() => 0, [], "zero");
var one = accessor(() => 1, [], "one");
var truthy = accessor(() => true, [], "true");
var falsy = accessor(() => false, [], "false");
function log$1(method2, level, input) {
  const args = [level].concat([].slice.call(input));
  console[method2].apply(console, args);
}
var None = 0;
var Error$1 = 1;
var Warn = 2;
var Info = 3;
var Debug = 4;
function logger(_, method2) {
  let handler = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : log$1;
  let level = _ || None;
  return {
    level(_2) {
      if (arguments.length) {
        level = +_2;
        return this;
      } else {
        return level;
      }
    },
    error() {
      if (level >= Error$1)
        handler(method2 || "error", "ERROR", arguments);
      return this;
    },
    warn() {
      if (level >= Warn)
        handler(method2 || "warn", "WARN", arguments);
      return this;
    },
    info() {
      if (level >= Info)
        handler(method2 || "log", "INFO", arguments);
      return this;
    },
    debug() {
      if (level >= Debug)
        handler(method2 || "log", "DEBUG", arguments);
      return this;
    }
  };
}
var isArray = Array.isArray;
function isObject(_) {
  return _ === Object(_);
}
var isLegalKey = (key2) => key2 !== "__proto__";
function mergeConfig() {
  for (var _len = arguments.length, configs = new Array(_len), _key = 0; _key < _len; _key++) {
    configs[_key] = arguments[_key];
  }
  return configs.reduce((out, source3) => {
    for (const key2 in source3) {
      if (key2 === "signals") {
        out.signals = mergeNamed(out.signals, source3.signals);
      } else {
        const r = key2 === "legend" ? {
          layout: 1
        } : key2 === "style" ? true : null;
        writeConfig(out, key2, source3[key2], r);
      }
    }
    return out;
  }, {});
}
function writeConfig(output3, key2, value3, recurse2) {
  if (!isLegalKey(key2))
    return;
  let k2, o;
  if (isObject(value3) && !isArray(value3)) {
    o = isObject(output3[key2]) ? output3[key2] : output3[key2] = {};
    for (k2 in value3) {
      if (recurse2 && (recurse2 === true || recurse2[k2])) {
        writeConfig(o, k2, value3[k2]);
      } else if (isLegalKey(k2)) {
        o[k2] = value3[k2];
      }
    }
  } else {
    output3[key2] = value3;
  }
}
function mergeNamed(a, b2) {
  if (a == null)
    return b2;
  const map2 = {}, out = [];
  function add4(_) {
    if (!map2[_.name]) {
      map2[_.name] = 1;
      out.push(_);
    }
  }
  b2.forEach(add4);
  a.forEach(add4);
  return out;
}
function peek(array4) {
  return array4[array4.length - 1];
}
function toNumber(_) {
  return _ == null || _ === "" ? null : +_;
}
var exp = (sign2) => (x2) => sign2 * Math.exp(x2);
var log2 = (sign2) => (x2) => Math.log(sign2 * x2);
var symlog2 = (c) => (x2) => Math.sign(x2) * Math.log1p(Math.abs(x2 / c));
var symexp = (c) => (x2) => Math.sign(x2) * Math.expm1(Math.abs(x2)) * c;
var pow2 = (exponent) => (x2) => x2 < 0 ? -Math.pow(-x2, exponent) : Math.pow(x2, exponent);
function pan(domain2, delta, lift, ground) {
  const d0 = lift(domain2[0]), d1 = lift(peek(domain2)), dd = (d1 - d0) * delta;
  return [ground(d0 - dd), ground(d1 - dd)];
}
function panLinear(domain2, delta) {
  return pan(domain2, delta, toNumber, identity2);
}
function panLog(domain2, delta) {
  var sign2 = Math.sign(domain2[0]);
  return pan(domain2, delta, log2(sign2), exp(sign2));
}
function panPow(domain2, delta, exponent) {
  return pan(domain2, delta, pow2(exponent), pow2(1 / exponent));
}
function panSymlog(domain2, delta, constant3) {
  return pan(domain2, delta, symlog2(constant3), symexp(constant3));
}
function zoom(domain2, anchor, scale6, lift, ground) {
  const d0 = lift(domain2[0]), d1 = lift(peek(domain2)), da = anchor != null ? lift(anchor) : (d0 + d1) / 2;
  return [ground(da + (d0 - da) * scale6), ground(da + (d1 - da) * scale6)];
}
function zoomLinear(domain2, anchor, scale6) {
  return zoom(domain2, anchor, scale6, toNumber, identity2);
}
function zoomLog(domain2, anchor, scale6) {
  const sign2 = Math.sign(domain2[0]);
  return zoom(domain2, anchor, scale6, log2(sign2), exp(sign2));
}
function zoomPow(domain2, anchor, scale6, exponent) {
  return zoom(domain2, anchor, scale6, pow2(exponent), pow2(1 / exponent));
}
function zoomSymlog(domain2, anchor, scale6, constant3) {
  return zoom(domain2, anchor, scale6, symlog2(constant3), symexp(constant3));
}
function quarter(date) {
  return 1 + ~~(new Date(date).getMonth() / 3);
}
function utcquarter(date) {
  return 1 + ~~(new Date(date).getUTCMonth() / 3);
}
function array(_) {
  return _ != null ? isArray(_) ? _ : [_] : [];
}
function clampRange(range4, min4, max4) {
  let lo = range4[0], hi = range4[1], span2;
  if (hi < lo) {
    span2 = hi;
    hi = lo;
    lo = span2;
  }
  span2 = hi - lo;
  return span2 >= max4 - min4 ? [min4, max4] : [lo = Math.min(Math.max(lo, min4), max4 - span2), lo + span2];
}
function isFunction(_) {
  return typeof _ === "function";
}
var DESCENDING = "descending";
function compare(fields, orders, opt) {
  opt = opt || {};
  orders = array(orders) || [];
  const ord = [], get5 = [], fmap = {}, gen = opt.comparator || comparator;
  array(fields).forEach((f, i) => {
    if (f == null)
      return;
    ord.push(orders[i] === DESCENDING ? -1 : 1);
    get5.push(f = isFunction(f) ? f : field(f, null, opt));
    (accessorFields(f) || []).forEach((_) => fmap[_] = 1);
  });
  return get5.length === 0 ? null : accessor(gen(get5, ord), Object.keys(fmap));
}
var ascending2 = (u, v) => (u < v || u == null) && v != null ? -1 : (u > v || v == null) && u != null ? 1 : (v = v instanceof Date ? +v : v, u = u instanceof Date ? +u : u) !== u && v === v ? -1 : v !== v && u === u ? 1 : 0;
var comparator = (fields, orders) => fields.length === 1 ? compare1(fields[0], orders[0]) : compareN(fields, orders, fields.length);
var compare1 = (field3, order) => function(a, b2) {
  return ascending2(field3(a), field3(b2)) * order;
};
var compareN = (fields, orders, n) => {
  orders.push(0);
  return function(a, b2) {
    let f, c = 0, i = -1;
    while (c === 0 && ++i < n) {
      f = fields[i];
      c = ascending2(f(a), f(b2));
    }
    return c * orders[i];
  };
};
function constant(_) {
  return isFunction(_) ? _ : () => _;
}
function debounce(delay, handler) {
  let tid;
  return (e) => {
    if (tid)
      clearTimeout(tid);
    tid = setTimeout(() => (handler(e), tid = null), delay);
  };
}
function extend(_) {
  for (let x2, k2, i = 1, len = arguments.length; i < len; ++i) {
    x2 = arguments[i];
    for (k2 in x2) {
      _[k2] = x2[k2];
    }
  }
  return _;
}
function extent(array4, f) {
  let i = 0, n, v, min4, max4;
  if (array4 && (n = array4.length)) {
    if (f == null) {
      for (v = array4[i]; i < n && (v == null || v !== v); v = array4[++i])
        ;
      min4 = max4 = v;
      for (; i < n; ++i) {
        v = array4[i];
        if (v != null) {
          if (v < min4)
            min4 = v;
          if (v > max4)
            max4 = v;
        }
      }
    } else {
      for (v = f(array4[i]); i < n && (v == null || v !== v); v = f(array4[++i]))
        ;
      min4 = max4 = v;
      for (; i < n; ++i) {
        v = f(array4[i]);
        if (v != null) {
          if (v < min4)
            min4 = v;
          if (v > max4)
            max4 = v;
        }
      }
    }
  }
  return [min4, max4];
}
function extentIndex(array4, f) {
  const n = array4.length;
  let i = -1, a, b2, c, u, v;
  if (f == null) {
    while (++i < n) {
      b2 = array4[i];
      if (b2 != null && b2 >= b2) {
        a = c = b2;
        break;
      }
    }
    if (i === n)
      return [-1, -1];
    u = v = i;
    while (++i < n) {
      b2 = array4[i];
      if (b2 != null) {
        if (a > b2) {
          a = b2;
          u = i;
        }
        if (c < b2) {
          c = b2;
          v = i;
        }
      }
    }
  } else {
    while (++i < n) {
      b2 = f(array4[i], i, array4);
      if (b2 != null && b2 >= b2) {
        a = c = b2;
        break;
      }
    }
    if (i === n)
      return [-1, -1];
    u = v = i;
    while (++i < n) {
      b2 = f(array4[i], i, array4);
      if (b2 != null) {
        if (a > b2) {
          a = b2;
          u = i;
        }
        if (c < b2) {
          c = b2;
          v = i;
        }
      }
    }
  }
  return [u, v];
}
var hop = Object.prototype.hasOwnProperty;
function has(object2, property2) {
  return hop.call(object2, property2);
}
var NULL = {};
function fastmap(input) {
  let obj = {}, test2;
  function has$1(key2) {
    return has(obj, key2) && obj[key2] !== NULL;
  }
  const map2 = {
    size: 0,
    empty: 0,
    object: obj,
    has: has$1,
    get(key2) {
      return has$1(key2) ? obj[key2] : void 0;
    },
    set(key2, value3) {
      if (!has$1(key2)) {
        ++map2.size;
        if (obj[key2] === NULL)
          --map2.empty;
      }
      obj[key2] = value3;
      return this;
    },
    delete(key2) {
      if (has$1(key2)) {
        --map2.size;
        ++map2.empty;
        obj[key2] = NULL;
      }
      return this;
    },
    clear() {
      map2.size = map2.empty = 0;
      map2.object = obj = {};
    },
    test(_) {
      if (arguments.length) {
        test2 = _;
        return map2;
      } else {
        return test2;
      }
    },
    clean() {
      const next = {};
      let size = 0;
      for (const key2 in obj) {
        const value3 = obj[key2];
        if (value3 !== NULL && (!test2 || !test2(value3))) {
          next[key2] = value3;
          ++size;
        }
      }
      map2.size = size;
      map2.empty = 0;
      map2.object = obj = next;
    }
  };
  if (input)
    Object.keys(input).forEach((key2) => {
      map2.set(key2, input[key2]);
    });
  return map2;
}
function flush(range4, value3, threshold2, left, right, center) {
  if (!threshold2 && threshold2 !== 0)
    return center;
  const t = +threshold2;
  let a = range4[0], b2 = peek(range4), l;
  if (b2 < a) {
    l = a;
    a = b2;
    b2 = l;
  }
  l = Math.abs(value3 - a);
  const r = Math.abs(b2 - value3);
  return l < r && l <= t ? left : r <= t ? right : center;
}
function inherits(child, parent, members) {
  const proto = child.prototype = Object.create(parent.prototype);
  Object.defineProperty(proto, "constructor", {
    value: child,
    writable: true,
    enumerable: true,
    configurable: true
  });
  return extend(proto, members);
}
function inrange(value3, range4, left, right) {
  let r0 = range4[0], r1 = range4[range4.length - 1], t;
  if (r0 > r1) {
    t = r0;
    r0 = r1;
    r1 = t;
  }
  left = left === void 0 || left;
  right = right === void 0 || right;
  return (left ? r0 <= value3 : r0 < value3) && (right ? value3 <= r1 : value3 < r1);
}
function isBoolean(_) {
  return typeof _ === "boolean";
}
function isDate(_) {
  return Object.prototype.toString.call(_) === "[object Date]";
}
function isIterable(_) {
  return _ && isFunction(_[Symbol.iterator]);
}
function isNumber(_) {
  return typeof _ === "number";
}
function isRegExp(_) {
  return Object.prototype.toString.call(_) === "[object RegExp]";
}
function isString(_) {
  return typeof _ === "string";
}
function key(fields, flat, opt) {
  if (fields) {
    fields = flat ? array(fields).map((f) => f.replace(/\\(.)/g, "$1")) : array(fields);
  }
  const len = fields && fields.length, gen = opt && opt.get || getter, map2 = (f) => gen(flat ? [f] : splitAccessPath(f));
  let fn;
  if (!len) {
    fn = function() {
      return "";
    };
  } else if (len === 1) {
    const get5 = map2(fields[0]);
    fn = function(_) {
      return "" + get5(_);
    };
  } else {
    const get5 = fields.map(map2);
    fn = function(_) {
      let s = "" + get5[0](_), i = 0;
      while (++i < len)
        s += "|" + get5[i](_);
      return s;
    };
  }
  return accessor(fn, fields, "key");
}
function lerp(array4, frac) {
  const lo = array4[0], hi = peek(array4), f = +frac;
  return !f ? lo : f === 1 ? hi : lo + f * (hi - lo);
}
var DEFAULT_MAX_SIZE = 1e4;
function lruCache(maxsize) {
  maxsize = +maxsize || DEFAULT_MAX_SIZE;
  let curr, prev, size;
  const clear = () => {
    curr = {};
    prev = {};
    size = 0;
  };
  const update3 = (key2, value3) => {
    if (++size > maxsize) {
      prev = curr;
      curr = {};
      size = 1;
    }
    return curr[key2] = value3;
  };
  clear();
  return {
    clear,
    has: (key2) => has(curr, key2) || has(prev, key2),
    get: (key2) => has(curr, key2) ? curr[key2] : has(prev, key2) ? update3(key2, prev[key2]) : void 0,
    set: (key2, value3) => has(curr, key2) ? curr[key2] = value3 : update3(key2, value3)
  };
}
function merge(compare3, array0, array1, output3) {
  const n0 = array0.length, n1 = array1.length;
  if (!n1)
    return array0;
  if (!n0)
    return array1;
  const merged = output3 || new array0.constructor(n0 + n1);
  let i0 = 0, i1 = 0, i = 0;
  for (; i0 < n0 && i1 < n1; ++i) {
    merged[i] = compare3(array0[i0], array1[i1]) > 0 ? array1[i1++] : array0[i0++];
  }
  for (; i0 < n0; ++i0, ++i) {
    merged[i] = array0[i0];
  }
  for (; i1 < n1; ++i1, ++i) {
    merged[i] = array1[i1];
  }
  return merged;
}
function repeat(str, reps) {
  let s = "";
  while (--reps >= 0)
    s += str;
  return s;
}
function pad(str, length2, padchar, align) {
  const c = padchar || " ", s = str + "", n = length2 - s.length;
  return n <= 0 ? s : align === "left" ? repeat(c, n) + s : align === "center" ? repeat(c, ~~(n / 2)) + s + repeat(c, Math.ceil(n / 2)) : s + repeat(c, n);
}
function span(array4) {
  return array4 && peek(array4) - array4[0] || 0;
}
function $(x2) {
  return isArray(x2) ? "[" + x2.map($) + "]" : isObject(x2) || isString(x2) ? (
    // Output valid JSON and JS source strings.
    // See http://timelessrepo.com/json-isnt-a-javascript-subset
    JSON.stringify(x2).replace("\u2028", "\\u2028").replace("\u2029", "\\u2029")
  ) : x2;
}
function toBoolean(_) {
  return _ == null || _ === "" ? null : !_ || _ === "false" || _ === "0" ? false : !!_;
}
var defaultParser = (_) => isNumber(_) ? _ : isDate(_) ? _ : Date.parse(_);
function toDate(_, parser3) {
  parser3 = parser3 || defaultParser;
  return _ == null || _ === "" ? null : parser3(_);
}
function toString(_) {
  return _ == null || _ === "" ? null : _ + "";
}
function toSet(_) {
  const s = {}, n = _.length;
  for (let i = 0; i < n; ++i)
    s[_[i]] = true;
  return s;
}
function truncate(str, length2, align, ellipsis) {
  const e = ellipsis != null ? ellipsis : "…", s = str + "", n = s.length, l = Math.max(0, length2 - e.length);
  return n <= length2 ? s : align === "left" ? e + s.slice(n - l) : align === "center" ? s.slice(0, Math.ceil(l / 2)) + e + s.slice(n - ~~(l / 2)) : s.slice(0, l) + e;
}
function visitArray(array4, filter3, visitor) {
  if (array4) {
    if (filter3) {
      const n = array4.length;
      for (let i = 0; i < n; ++i) {
        const t = filter3(array4[i]);
        if (t)
          visitor(t, i, array4);
      }
    } else {
      array4.forEach(visitor);
    }
  }
}

// node_modules/topojson-client/src/identity.js
function identity_default2(x2) {
  return x2;
}

// node_modules/topojson-client/src/transform.js
function transform_default(transform4) {
  if (transform4 == null)
    return identity_default2;
  var x02, y02, kx2 = transform4.scale[0], ky = transform4.scale[1], dx = transform4.translate[0], dy = transform4.translate[1];
  return function(input, i) {
    if (!i)
      x02 = y02 = 0;
    var j = 2, n = input.length, output3 = new Array(n);
    output3[0] = (x02 += input[0]) * kx2 + dx;
    output3[1] = (y02 += input[1]) * ky + dy;
    while (j < n)
      output3[j] = input[j], ++j;
    return output3;
  };
}

// node_modules/topojson-client/src/reverse.js
function reverse_default(array4, n) {
  var t, j = array4.length, i = j - n;
  while (i < --j)
    t = array4[i], array4[i++] = array4[j], array4[j] = t;
}

// node_modules/topojson-client/src/feature.js
function feature_default(topology, o) {
  if (typeof o === "string")
    o = topology.objects[o];
  return o.type === "GeometryCollection" ? { type: "FeatureCollection", features: o.geometries.map(function(o2) {
    return feature(topology, o2);
  }) } : feature(topology, o);
}
function feature(topology, o) {
  var id2 = o.id, bbox = o.bbox, properties = o.properties == null ? {} : o.properties, geometry = object(topology, o);
  return id2 == null && bbox == null ? { type: "Feature", properties, geometry } : bbox == null ? { type: "Feature", id: id2, properties, geometry } : { type: "Feature", id: id2, bbox, properties, geometry };
}
function object(topology, o) {
  var transformPoint = transform_default(topology.transform), arcs = topology.arcs;
  function arc3(i, points2) {
    if (points2.length)
      points2.pop();
    for (var a = arcs[i < 0 ? ~i : i], k2 = 0, n = a.length; k2 < n; ++k2) {
      points2.push(transformPoint(a[k2], k2));
    }
    if (i < 0)
      reverse_default(points2, n);
  }
  function point3(p) {
    return transformPoint(p);
  }
  function line3(arcs2) {
    var points2 = [];
    for (var i = 0, n = arcs2.length; i < n; ++i)
      arc3(arcs2[i], points2);
    if (points2.length < 2)
      points2.push(points2[0]);
    return points2;
  }
  function ring(arcs2) {
    var points2 = line3(arcs2);
    while (points2.length < 4)
      points2.push(points2[0]);
    return points2;
  }
  function polygon(arcs2) {
    return arcs2.map(ring);
  }
  function geometry(o2) {
    var type2 = o2.type, coordinates;
    switch (type2) {
      case "GeometryCollection":
        return { type: type2, geometries: o2.geometries.map(geometry) };
      case "Point":
        coordinates = point3(o2.coordinates);
        break;
      case "MultiPoint":
        coordinates = o2.coordinates.map(point3);
        break;
      case "LineString":
        coordinates = line3(o2.arcs);
        break;
      case "MultiLineString":
        coordinates = o2.arcs.map(line3);
        break;
      case "Polygon":
        coordinates = polygon(o2.arcs);
        break;
      case "MultiPolygon":
        coordinates = o2.arcs.map(polygon);
        break;
      default:
        return null;
    }
    return { type: type2, coordinates };
  }
  return geometry(o);
}

// node_modules/topojson-client/src/stitch.js
function stitch_default(topology, arcs) {
  var stitchedArcs = {}, fragmentByStart = {}, fragmentByEnd = {}, fragments = [], emptyIndex = -1;
  arcs.forEach(function(i, j) {
    var arc3 = topology.arcs[i < 0 ? ~i : i], t;
    if (arc3.length < 3 && !arc3[1][0] && !arc3[1][1]) {
      t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;
    }
  });
  arcs.forEach(function(i) {
    var e = ends(i), start = e[0], end = e[1], f, g;
    if (f = fragmentByEnd[start]) {
      delete fragmentByEnd[f.end];
      f.push(i);
      f.end = end;
      if (g = fragmentByStart[end]) {
        delete fragmentByStart[g.start];
        var fg = g === f ? f : f.concat(g);
        fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;
      } else {
        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
      }
    } else if (f = fragmentByStart[end]) {
      delete fragmentByStart[f.start];
      f.unshift(i);
      f.start = start;
      if (g = fragmentByEnd[start]) {
        delete fragmentByEnd[g.end];
        var gf = g === f ? f : g.concat(f);
        fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;
      } else {
        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
      }
    } else {
      f = [i];
      fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;
    }
  });
  function ends(i) {
    var arc3 = topology.arcs[i < 0 ? ~i : i], p0 = arc3[0], p1;
    if (topology.transform)
      p1 = [0, 0], arc3.forEach(function(dp) {
        p1[0] += dp[0], p1[1] += dp[1];
      });
    else
      p1 = arc3[arc3.length - 1];
    return i < 0 ? [p1, p0] : [p0, p1];
  }
  function flush2(fragmentByEnd2, fragmentByStart2) {
    for (var k2 in fragmentByEnd2) {
      var f = fragmentByEnd2[k2];
      delete fragmentByStart2[f.start];
      delete f.start;
      delete f.end;
      f.forEach(function(i) {
        stitchedArcs[i < 0 ? ~i : i] = 1;
      });
      fragments.push(f);
    }
  }
  flush2(fragmentByEnd, fragmentByStart);
  flush2(fragmentByStart, fragmentByEnd);
  arcs.forEach(function(i) {
    if (!stitchedArcs[i < 0 ? ~i : i])
      fragments.push([i]);
  });
  return fragments;
}

// node_modules/topojson-client/src/mesh.js
function mesh_default(topology) {
  return object(topology, meshArcs.apply(this, arguments));
}
function meshArcs(topology, object2, filter3) {
  var arcs, i, n;
  if (arguments.length > 1)
    arcs = extractArcs(topology, object2, filter3);
  else
    for (i = 0, arcs = new Array(n = topology.arcs.length); i < n; ++i)
      arcs[i] = i;
  return { type: "MultiLineString", arcs: stitch_default(topology, arcs) };
}
function extractArcs(topology, object2, filter3) {
  var arcs = [], geomsByArc = [], geom;
  function extract0(i) {
    var j = i < 0 ? ~i : i;
    (geomsByArc[j] || (geomsByArc[j] = [])).push({ i, g: geom });
  }
  function extract1(arcs2) {
    arcs2.forEach(extract0);
  }
  function extract2(arcs2) {
    arcs2.forEach(extract1);
  }
  function extract3(arcs2) {
    arcs2.forEach(extract2);
  }
  function geometry(o) {
    switch (geom = o, o.type) {
      case "GeometryCollection":
        o.geometries.forEach(geometry);
        break;
      case "LineString":
        extract1(o.arcs);
        break;
      case "MultiLineString":
      case "Polygon":
        extract2(o.arcs);
        break;
      case "MultiPolygon":
        extract3(o.arcs);
        break;
    }
  }
  geometry(object2);
  geomsByArc.forEach(filter3 == null ? function(geoms) {
    arcs.push(geoms[0].i);
  } : function(geoms) {
    if (filter3(geoms[0].g, geoms[geoms.length - 1].g))
      arcs.push(geoms[0].i);
  });
  return arcs;
}

// node_modules/vega-time/build/vega-time.module.js
var YEAR = "year";
var QUARTER = "quarter";
var MONTH = "month";
var WEEK = "week";
var DATE = "date";
var DAY = "day";
var DAYOFYEAR = "dayofyear";
var HOURS = "hours";
var MINUTES = "minutes";
var SECONDS = "seconds";
var MILLISECONDS = "milliseconds";
var TIME_UNITS = [YEAR, QUARTER, MONTH, WEEK, DATE, DAY, DAYOFYEAR, HOURS, MINUTES, SECONDS, MILLISECONDS];
var UNITS = TIME_UNITS.reduce((o, u, i) => (o[u] = 1 + i, o), {});
function timeUnits(units) {
  const u = array(units).slice(), m = {};
  if (!u.length)
    error("Missing time unit.");
  u.forEach((unit) => {
    if (has(UNITS, unit)) {
      m[unit] = 1;
    } else {
      error(`Invalid time unit: ${unit}.`);
    }
  });
  const numTypes = (m[WEEK] || m[DAY] ? 1 : 0) + (m[QUARTER] || m[MONTH] || m[DATE] ? 1 : 0) + (m[DAYOFYEAR] ? 1 : 0);
  if (numTypes > 1) {
    error(`Incompatible time units: ${units}`);
  }
  u.sort((a, b2) => UNITS[a] - UNITS[b2]);
  return u;
}
var defaultSpecifiers = {
  [YEAR]: "%Y ",
  [QUARTER]: "Q%q ",
  [MONTH]: "%b ",
  [DATE]: "%d ",
  [WEEK]: "W%U ",
  [DAY]: "%a ",
  [DAYOFYEAR]: "%j ",
  [HOURS]: "%H:00",
  [MINUTES]: "00:%M",
  [SECONDS]: ":%S",
  [MILLISECONDS]: ".%L",
  [`${YEAR}-${MONTH}`]: "%Y-%m ",
  [`${YEAR}-${MONTH}-${DATE}`]: "%Y-%m-%d ",
  [`${HOURS}-${MINUTES}`]: "%H:%M"
};
function timeUnitSpecifier(units, specifiers) {
  const s = extend({}, defaultSpecifiers, specifiers), u = timeUnits(units), n = u.length;
  let fmt = "", start = 0, end, key2;
  for (start = 0; start < n; ) {
    for (end = u.length; end > start; --end) {
      key2 = u.slice(start, end).join("-");
      if (s[key2] != null) {
        fmt += s[key2];
        start = end;
        break;
      }
    }
  }
  return fmt.trim();
}
var t0 = /* @__PURE__ */ new Date();
function localYear(y2) {
  t0.setFullYear(y2);
  t0.setMonth(0);
  t0.setDate(1);
  t0.setHours(0, 0, 0, 0);
  return t0;
}
function dayofyear(d) {
  return localDayOfYear(new Date(d));
}
function week(d) {
  return localWeekNum(new Date(d));
}
function localDayOfYear(d) {
  return timeDay.count(localYear(d.getFullYear()) - 1, d);
}
function localWeekNum(d) {
  return timeSunday.count(localYear(d.getFullYear()) - 1, d);
}
function localFirst(y2) {
  return localYear(y2).getDay();
}
function localDate(y2, m, d, H, M, S, L) {
  if (0 <= y2 && y2 < 100) {
    const date = new Date(-1, m, d, H, M, S, L);
    date.setFullYear(y2);
    return date;
  }
  return new Date(y2, m, d, H, M, S, L);
}
function utcdayofyear(d) {
  return utcDayOfYear(new Date(d));
}
function utcweek(d) {
  return utcWeekNum(new Date(d));
}
function utcDayOfYear(d) {
  const y2 = Date.UTC(d.getUTCFullYear(), 0, 1);
  return utcDay.count(y2 - 1, d);
}
function utcWeekNum(d) {
  const y2 = Date.UTC(d.getUTCFullYear(), 0, 1);
  return utcSunday.count(y2 - 1, d);
}
function utcFirst(y2) {
  t0.setTime(Date.UTC(y2, 0, 1));
  return t0.getUTCDay();
}
function utcDate(y2, m, d, H, M, S, L) {
  if (0 <= y2 && y2 < 100) {
    const date = new Date(Date.UTC(-1, m, d, H, M, S, L));
    date.setUTCFullYear(d.y);
    return date;
  }
  return new Date(Date.UTC(y2, m, d, H, M, S, L));
}
function floor(units, step, get5, inv, newDate) {
  const s = step || 1, b2 = peek(units), _ = (unit, p, key2) => {
    key2 = key2 || unit;
    return getUnit(get5[key2], inv[key2], unit === b2 && s, p);
  };
  const t = /* @__PURE__ */ new Date(), u = toSet(units), y2 = u[YEAR] ? _(YEAR) : constant(2012), m = u[MONTH] ? _(MONTH) : u[QUARTER] ? _(QUARTER) : zero, d = u[WEEK] && u[DAY] ? _(DAY, 1, WEEK + DAY) : u[WEEK] ? _(WEEK, 1) : u[DAY] ? _(DAY, 1) : u[DATE] ? _(DATE, 1) : u[DAYOFYEAR] ? _(DAYOFYEAR, 1) : one, H = u[HOURS] ? _(HOURS) : zero, M = u[MINUTES] ? _(MINUTES) : zero, S = u[SECONDS] ? _(SECONDS) : zero, L = u[MILLISECONDS] ? _(MILLISECONDS) : zero;
  return function(v) {
    t.setTime(+v);
    const year = y2(t);
    return newDate(year, m(t), d(t, year), H(t), M(t), S(t), L(t));
  };
}
function getUnit(f, inv, step, phase) {
  const u = step <= 1 ? f : phase ? (d, y2) => phase + step * Math.floor((f(d, y2) - phase) / step) : (d, y2) => step * Math.floor(f(d, y2) / step);
  return inv ? (d, y2) => inv(u(d, y2), y2) : u;
}
function weekday(week2, day, firstDay) {
  return day + week2 * 7 - (firstDay + 6) % 7;
}
var localGet = {
  [YEAR]: (d) => d.getFullYear(),
  [QUARTER]: (d) => Math.floor(d.getMonth() / 3),
  [MONTH]: (d) => d.getMonth(),
  [DATE]: (d) => d.getDate(),
  [HOURS]: (d) => d.getHours(),
  [MINUTES]: (d) => d.getMinutes(),
  [SECONDS]: (d) => d.getSeconds(),
  [MILLISECONDS]: (d) => d.getMilliseconds(),
  [DAYOFYEAR]: (d) => localDayOfYear(d),
  [WEEK]: (d) => localWeekNum(d),
  [WEEK + DAY]: (d, y2) => weekday(localWeekNum(d), d.getDay(), localFirst(y2)),
  [DAY]: (d, y2) => weekday(1, d.getDay(), localFirst(y2))
};
var localInv = {
  [QUARTER]: (q) => 3 * q,
  [WEEK]: (w3, y2) => weekday(w3, 0, localFirst(y2))
};
function timeFloor(units, step) {
  return floor(units, step || 1, localGet, localInv, localDate);
}
var utcGet = {
  [YEAR]: (d) => d.getUTCFullYear(),
  [QUARTER]: (d) => Math.floor(d.getUTCMonth() / 3),
  [MONTH]: (d) => d.getUTCMonth(),
  [DATE]: (d) => d.getUTCDate(),
  [HOURS]: (d) => d.getUTCHours(),
  [MINUTES]: (d) => d.getUTCMinutes(),
  [SECONDS]: (d) => d.getUTCSeconds(),
  [MILLISECONDS]: (d) => d.getUTCMilliseconds(),
  [DAYOFYEAR]: (d) => utcDayOfYear(d),
  [WEEK]: (d) => utcWeekNum(d),
  [DAY]: (d, y2) => weekday(1, d.getUTCDay(), utcFirst(y2)),
  [WEEK + DAY]: (d, y2) => weekday(utcWeekNum(d), d.getUTCDay(), utcFirst(y2))
};
var utcInv = {
  [QUARTER]: (q) => 3 * q,
  [WEEK]: (w3, y2) => weekday(w3, 0, utcFirst(y2))
};
function utcFloor(units, step) {
  return floor(units, step || 1, utcGet, utcInv, utcDate);
}
var timeIntervals = {
  [YEAR]: timeYear,
  [QUARTER]: timeMonth.every(3),
  [MONTH]: timeMonth,
  [WEEK]: timeSunday,
  [DATE]: timeDay,
  [DAY]: timeDay,
  [DAYOFYEAR]: timeDay,
  [HOURS]: timeHour,
  [MINUTES]: timeMinute,
  [SECONDS]: second,
  [MILLISECONDS]: millisecond
};
var utcIntervals = {
  [YEAR]: utcYear,
  [QUARTER]: utcMonth.every(3),
  [MONTH]: utcMonth,
  [WEEK]: utcSunday,
  [DATE]: utcDay,
  [DAY]: utcDay,
  [DAYOFYEAR]: utcDay,
  [HOURS]: utcHour,
  [MINUTES]: utcMinute,
  [SECONDS]: second,
  [MILLISECONDS]: millisecond
};
function timeInterval(unit) {
  return timeIntervals[unit];
}
function utcInterval(unit) {
  return utcIntervals[unit];
}
function offset(ival, date, step) {
  return ival ? ival.offset(date, step) : void 0;
}
function timeOffset(unit, date, step) {
  return offset(timeInterval(unit), date, step);
}
function utcOffset(unit, date, step) {
  return offset(utcInterval(unit), date, step);
}
function sequence(ival, start, stop2, step) {
  return ival ? ival.range(start, stop2, step) : void 0;
}
function timeSequence(unit, start, stop2, step) {
  return sequence(timeInterval(unit), start, stop2, step);
}
function utcSequence(unit, start, stop2, step) {
  return sequence(utcInterval(unit), start, stop2, step);
}
var durationSecond = 1e3;
var durationMinute = durationSecond * 60;
var durationHour = durationMinute * 60;
var durationDay = durationHour * 24;
var durationWeek = durationDay * 7;
var durationMonth = durationDay * 30;
var durationYear = durationDay * 365;
var Milli = [YEAR, MONTH, DATE, HOURS, MINUTES, SECONDS, MILLISECONDS];
var Seconds = Milli.slice(0, -1);
var Minutes = Seconds.slice(0, -1);
var Hours = Minutes.slice(0, -1);
var Day = Hours.slice(0, -1);
var Week = [YEAR, WEEK];
var Month = [YEAR, MONTH];
var Year = [YEAR];
var intervals = [[Seconds, 1, durationSecond], [Seconds, 5, 5 * durationSecond], [Seconds, 15, 15 * durationSecond], [Seconds, 30, 30 * durationSecond], [Minutes, 1, durationMinute], [Minutes, 5, 5 * durationMinute], [Minutes, 15, 15 * durationMinute], [Minutes, 30, 30 * durationMinute], [Hours, 1, durationHour], [Hours, 3, 3 * durationHour], [Hours, 6, 6 * durationHour], [Hours, 12, 12 * durationHour], [Day, 1, durationDay], [Week, 1, durationWeek], [Month, 1, durationMonth], [Month, 3, 3 * durationMonth], [Year, 1, durationYear]];
function bin(opt) {
  const ext = opt.extent, max4 = opt.maxbins || 40, target2 = Math.abs(span(ext)) / max4;
  let i = bisector((i2) => i2[2]).right(intervals, target2), units, step;
  if (i === intervals.length) {
    units = Year, step = tickStep(ext[0] / durationYear, ext[1] / durationYear, max4);
  } else if (i) {
    i = intervals[target2 / intervals[i - 1][2] < intervals[i][2] / target2 ? i - 1 : i];
    units = i[0];
    step = i[1];
  } else {
    units = Milli;
    step = Math.max(tickStep(ext[0], ext[1], max4), 1);
  }
  return {
    units,
    step
  };
}

// node_modules/vega-format/build/vega-format.module.js
function memoize(method2) {
  const cache2 = {};
  return (spec) => cache2[spec] || (cache2[spec] = method2(spec));
}
function trimZeroes(numberFormat, decimalChar) {
  return (x2) => {
    const str = numberFormat(x2), dec = str.indexOf(decimalChar);
    if (dec < 0)
      return str;
    let idx = rightmostDigit(str, dec);
    const end = idx < str.length ? str.slice(idx) : "";
    while (--idx > dec)
      if (str[idx] !== "0") {
        ++idx;
        break;
      }
    return str.slice(0, idx) + end;
  };
}
function rightmostDigit(str, dec) {
  let i = str.lastIndexOf("e"), c;
  if (i > 0)
    return i;
  for (i = str.length; --i > dec; ) {
    c = str.charCodeAt(i);
    if (c >= 48 && c <= 57)
      return i + 1;
  }
}
function numberLocale(locale2) {
  const format5 = memoize(locale2.format), formatPrefix2 = locale2.formatPrefix;
  return {
    format: format5,
    formatPrefix: formatPrefix2,
    formatFloat(spec) {
      const s = formatSpecifier(spec || ",");
      if (s.precision == null) {
        s.precision = 12;
        switch (s.type) {
          case "%":
            s.precision -= 2;
            break;
          case "e":
            s.precision -= 1;
            break;
        }
        return trimZeroes(
          format5(s),
          // number format
          format5(".1f")(1)[1]
          // decimal point character
        );
      } else {
        return format5(s);
      }
    },
    formatSpan(start, stop2, count, specifier) {
      specifier = formatSpecifier(specifier == null ? ",f" : specifier);
      const step = tickStep(start, stop2, count), value3 = Math.max(Math.abs(start), Math.abs(stop2));
      let precision;
      if (specifier.precision == null) {
        switch (specifier.type) {
          case "s": {
            if (!isNaN(precision = precisionPrefix_default(step, value3))) {
              specifier.precision = precision;
            }
            return formatPrefix2(specifier, value3);
          }
          case "":
          case "e":
          case "g":
          case "p":
          case "r": {
            if (!isNaN(precision = precisionRound_default(step, value3))) {
              specifier.precision = precision - (specifier.type === "e");
            }
            break;
          }
          case "f":
          case "%": {
            if (!isNaN(precision = precisionFixed_default(step))) {
              specifier.precision = precision - (specifier.type === "%") * 2;
            }
            break;
          }
        }
      }
      return format5(specifier);
    }
  };
}
var defaultNumberLocale;
resetNumberFormatDefaultLocale();
function resetNumberFormatDefaultLocale() {
  return defaultNumberLocale = numberLocale({
    format,
    formatPrefix
  });
}
function numberFormatLocale(definition3) {
  return numberLocale(locale_default(definition3));
}
function numberFormatDefaultLocale(definition3) {
  return arguments.length ? defaultNumberLocale = numberFormatLocale(definition3) : defaultNumberLocale;
}
function timeMultiFormat(format5, interval, spec) {
  spec = spec || {};
  if (!isObject(spec)) {
    error(`Invalid time multi-format specifier: ${spec}`);
  }
  const second2 = interval(SECONDS), minute = interval(MINUTES), hour = interval(HOURS), day = interval(DATE), week2 = interval(WEEK), month = interval(MONTH), quarter2 = interval(QUARTER), year = interval(YEAR), L = format5(spec[MILLISECONDS] || ".%L"), S = format5(spec[SECONDS] || ":%S"), M = format5(spec[MINUTES] || "%I:%M"), H = format5(spec[HOURS] || "%I %p"), d = format5(spec[DATE] || spec[DAY] || "%a %d"), w3 = format5(spec[WEEK] || "%b %d"), m = format5(spec[MONTH] || "%B"), q = format5(spec[QUARTER] || "%B"), y2 = format5(spec[YEAR] || "%Y");
  return (date) => (second2(date) < date ? L : minute(date) < date ? S : hour(date) < date ? M : day(date) < date ? H : month(date) < date ? week2(date) < date ? d : w3 : year(date) < date ? quarter2(date) < date ? m : q : y2)(date);
}
function timeLocale(locale2) {
  const timeFormat3 = memoize(locale2.format), utcFormat3 = memoize(locale2.utcFormat);
  return {
    timeFormat: (spec) => isString(spec) ? timeFormat3(spec) : timeMultiFormat(timeFormat3, timeInterval, spec),
    utcFormat: (spec) => isString(spec) ? utcFormat3(spec) : timeMultiFormat(utcFormat3, utcInterval, spec),
    timeParse: memoize(locale2.parse),
    utcParse: memoize(locale2.utcParse)
  };
}
var defaultTimeLocale;
resetTimeFormatDefaultLocale();
function resetTimeFormatDefaultLocale() {
  return defaultTimeLocale = timeLocale({
    format: timeFormat,
    parse: timeParse,
    utcFormat,
    utcParse
  });
}
function timeFormatLocale(definition3) {
  return timeLocale(formatLocale(definition3));
}
function timeFormatDefaultLocale(definition3) {
  return arguments.length ? defaultTimeLocale = timeFormatLocale(definition3) : defaultTimeLocale;
}
var createLocale = (number5, time3) => extend({}, number5, time3);
function locale(numberSpec, timeSpec) {
  const number5 = numberSpec ? numberFormatLocale(numberSpec) : numberFormatDefaultLocale();
  const time3 = timeSpec ? timeFormatLocale(timeSpec) : timeFormatDefaultLocale();
  return createLocale(number5, time3);
}
function defaultLocale(numberSpec, timeSpec) {
  const args = arguments.length;
  if (args && args !== 2) {
    error("defaultLocale expects either zero or two arguments.");
  }
  return args ? createLocale(numberFormatDefaultLocale(numberSpec), timeFormatDefaultLocale(timeSpec)) : createLocale(numberFormatDefaultLocale(), timeFormatDefaultLocale());
}
function resetDefaultLocale() {
  resetNumberFormatDefaultLocale();
  resetTimeFormatDefaultLocale();
  return defaultLocale();
}

// node_modules/vega-loader/build/vega-loader.browser.module.js
var protocol_re = /^(data:|([A-Za-z]+:)?\/\/)/;
var allowed_re = /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp|file|data):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i;
var whitespace_re = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g;
var fileProtocol = "file://";
function loaderFactory(fetch2, fs) {
  return (options) => ({
    options: options || {},
    sanitize,
    load,
    fileAccess: !!fs,
    file: fileLoader(fs),
    http: httpLoader(fetch2)
  });
}
async function load(uri, options) {
  const opt = await this.sanitize(uri, options), url = opt.href;
  return opt.localFile ? this.file(url) : this.http(url, options);
}
async function sanitize(uri, options) {
  options = extend({}, this.options, options);
  const fileAccess = this.fileAccess, result = {
    href: null
  };
  let isFile, loadFile, base2;
  const isAllowed = allowed_re.test(uri.replace(whitespace_re, ""));
  if (uri == null || typeof uri !== "string" || !isAllowed) {
    error("Sanitize failure, invalid URI: " + $(uri));
  }
  const hasProtocol = protocol_re.test(uri);
  if ((base2 = options.baseURL) && !hasProtocol) {
    if (!uri.startsWith("/") && !base2.endsWith("/")) {
      uri = "/" + uri;
    }
    uri = base2 + uri;
  }
  loadFile = (isFile = uri.startsWith(fileProtocol)) || options.mode === "file" || options.mode !== "http" && !hasProtocol && fileAccess;
  if (isFile) {
    uri = uri.slice(fileProtocol.length);
  } else if (uri.startsWith("//")) {
    if (options.defaultProtocol === "file") {
      uri = uri.slice(2);
      loadFile = true;
    } else {
      uri = (options.defaultProtocol || "http") + ":" + uri;
    }
  }
  Object.defineProperty(result, "localFile", {
    value: !!loadFile
  });
  result.href = uri;
  if (options.target) {
    result.target = options.target + "";
  }
  if (options.rel) {
    result.rel = options.rel + "";
  }
  if (options.context === "image" && options.crossOrigin) {
    result.crossOrigin = options.crossOrigin + "";
  }
  return result;
}
function fileLoader(fs) {
  return fs ? (filename) => new Promise((accept, reject) => {
    fs.readFile(filename, (error2, data3) => {
      if (error2)
        reject(error2);
      else
        accept(data3);
    });
  }) : fileReject;
}
async function fileReject() {
  error("No file system access.");
}
function httpLoader(fetch2) {
  return fetch2 ? async function(url, options) {
    const opt = extend({}, this.options.http, options), type2 = options && options.response, response = await fetch2(url, opt);
    return !response.ok ? error(response.status + "" + response.statusText) : isFunction(response[type2]) ? response[type2]() : response.text();
  } : httpReject;
}
async function httpReject() {
  error("No HTTP fetch method available.");
}
var isValid = (_) => _ != null && _ === _;
var isBoolean2 = (_) => _ === "true" || _ === "false" || _ === true || _ === false;
var isDate2 = (_) => !Number.isNaN(Date.parse(_));
var isNumber2 = (_) => !Number.isNaN(+_) && !(_ instanceof Date);
var isInteger = (_) => isNumber2(_) && Number.isInteger(+_);
var typeParsers = {
  boolean: toBoolean,
  integer: toNumber,
  number: toNumber,
  date: toDate,
  string: toString,
  unknown: identity2
};
var typeTests = [isBoolean2, isInteger, isNumber2, isDate2];
var typeList = ["boolean", "integer", "number", "date"];
function inferType(values2, field3) {
  if (!values2 || !values2.length)
    return "unknown";
  const n = values2.length, m = typeTests.length, a = typeTests.map((_, i) => i + 1);
  for (let i = 0, t = 0, j, value3; i < n; ++i) {
    value3 = field3 ? values2[i][field3] : values2[i];
    for (j = 0; j < m; ++j) {
      if (a[j] && isValid(value3) && !typeTests[j](value3)) {
        a[j] = 0;
        ++t;
        if (t === typeTests.length)
          return "string";
      }
    }
  }
  return typeList[a.reduce((u, v) => u === 0 ? v : u, 0) - 1];
}
function inferTypes(data3, fields) {
  return fields.reduce((types, field3) => {
    types[field3] = inferType(data3, field3);
    return types;
  }, {});
}
function delimitedFormat(delimiter) {
  const parse7 = function(data3, format5) {
    const delim = {
      delimiter
    };
    return dsv(data3, format5 ? extend(format5, delim) : delim);
  };
  parse7.responseType = "text";
  return parse7;
}
function dsv(data3, format5) {
  if (format5.header) {
    data3 = format5.header.map($).join(format5.delimiter) + "\n" + data3;
  }
  return dsv_default(format5.delimiter).parse(data3 + "");
}
dsv.responseType = "text";
function isBuffer(_) {
  return typeof Buffer === "function" && isFunction(Buffer.isBuffer) ? Buffer.isBuffer(_) : false;
}
function json(data3, format5) {
  const prop = format5 && format5.property ? field(format5.property) : identity2;
  return isObject(data3) && !isBuffer(data3) ? parseJSON(prop(data3), format5) : prop(JSON.parse(data3));
}
json.responseType = "json";
function parseJSON(data3, format5) {
  if (!isArray(data3) && isIterable(data3)) {
    data3 = [...data3];
  }
  return format5 && format5.copy ? JSON.parse(JSON.stringify(data3)) : data3;
}
var filters = {
  interior: (a, b2) => a !== b2,
  exterior: (a, b2) => a === b2
};
function topojson(data3, format5) {
  let method2, object2, property2, filter3;
  data3 = json(data3, format5);
  if (format5 && format5.feature) {
    method2 = feature_default;
    property2 = format5.feature;
  } else if (format5 && format5.mesh) {
    method2 = mesh_default;
    property2 = format5.mesh;
    filter3 = filters[format5.filter];
  } else {
    error("Missing TopoJSON feature or mesh parameter.");
  }
  object2 = (object2 = data3.objects[property2]) ? method2(data3, object2, filter3) : error("Invalid TopoJSON object: " + property2);
  return object2 && object2.features || [object2];
}
topojson.responseType = "json";
var format2 = {
  dsv,
  csv: delimitedFormat(","),
  tsv: delimitedFormat("	"),
  json,
  topojson
};
function formats(name, reader) {
  if (arguments.length > 1) {
    format2[name] = reader;
    return this;
  } else {
    return has(format2, name) ? format2[name] : null;
  }
}
function responseType(type2) {
  const f = formats(type2);
  return f && f.responseType || "text";
}
function read(data3, schema, timeParser, utcParser) {
  schema = schema || {};
  const reader = formats(schema.type || "json");
  if (!reader)
    error("Unknown data format type: " + schema.type);
  data3 = reader(data3, schema);
  if (schema.parse)
    parse(data3, schema.parse, timeParser, utcParser);
  if (has(data3, "columns"))
    delete data3.columns;
  return data3;
}
function parse(data3, types, timeParser, utcParser) {
  if (!data3.length)
    return;
  const locale2 = timeFormatDefaultLocale();
  timeParser = timeParser || locale2.timeParse;
  utcParser = utcParser || locale2.utcParse;
  let fields = data3.columns || Object.keys(data3[0]), datum2, field3, i, j, n, m;
  if (types === "auto")
    types = inferTypes(data3, fields);
  fields = Object.keys(types);
  const parsers = fields.map((field4) => {
    const type2 = types[field4];
    let parts, pattern;
    if (type2 && (type2.startsWith("date:") || type2.startsWith("utc:"))) {
      parts = type2.split(/:(.+)?/, 2);
      pattern = parts[1];
      if (pattern[0] === "'" && pattern[pattern.length - 1] === "'" || pattern[0] === '"' && pattern[pattern.length - 1] === '"') {
        pattern = pattern.slice(1, -1);
      }
      const parse7 = parts[0] === "utc" ? utcParser : timeParser;
      return parse7(pattern);
    }
    if (!typeParsers[type2]) {
      throw Error("Illegal format pattern: " + field4 + ":" + type2);
    }
    return typeParsers[type2];
  });
  for (i = 0, n = data3.length, m = fields.length; i < n; ++i) {
    datum2 = data3[i];
    for (j = 0; j < m; ++j) {
      field3 = fields[j];
      datum2[field3] = parsers[j](datum2[field3]);
    }
  }
}
var loader = loaderFactory(
  typeof fetch !== "undefined" && fetch,
  // use built-in fetch API
  null
  // no file system access
);

// node_modules/vega-dataflow/build/vega-dataflow.module.js
function UniqueList(idFunc) {
  const $2 = idFunc || identity2, list = [], ids = {};
  list.add = (_) => {
    const id2 = $2(_);
    if (!ids[id2]) {
      ids[id2] = 1;
      list.push(_);
    }
    return list;
  };
  list.remove = (_) => {
    const id2 = $2(_);
    if (ids[id2]) {
      ids[id2] = 0;
      const idx = list.indexOf(_);
      if (idx >= 0)
        list.splice(idx, 1);
    }
    return list;
  };
  return list;
}
async function asyncCallback(df, callback) {
  try {
    await callback(df);
  } catch (err) {
    df.error(err);
  }
}
var TUPLE_ID_KEY = Symbol("vega_id");
var TUPLE_ID = 1;
function isTuple(t) {
  return !!(t && tupleid(t));
}
function tupleid(t) {
  return t[TUPLE_ID_KEY];
}
function setid(t, id2) {
  t[TUPLE_ID_KEY] = id2;
  return t;
}
function ingest$1(datum2) {
  const t = datum2 === Object(datum2) ? datum2 : {
    data: datum2
  };
  return tupleid(t) ? t : setid(t, TUPLE_ID++);
}
function derive(t) {
  return rederive(t, ingest$1({}));
}
function rederive(t, d) {
  for (const k2 in t)
    d[k2] = t[k2];
  return d;
}
function replace(t, d) {
  return setid(d, tupleid(t));
}
function stableCompare(cmp, f) {
  return !cmp ? null : f ? (a, b2) => cmp(a, b2) || tupleid(f(a)) - tupleid(f(b2)) : (a, b2) => cmp(a, b2) || tupleid(a) - tupleid(b2);
}
function isChangeSet(v) {
  return v && v.constructor === changeset;
}
function changeset() {
  const add4 = [], rem2 = [], mod = [], remp = [], modp = [];
  let clean = null, reflow2 = false;
  return {
    constructor: changeset,
    insert(t) {
      const d = array(t), n = d.length;
      for (let i = 0; i < n; ++i)
        add4.push(d[i]);
      return this;
    },
    remove(t) {
      const a = isFunction(t) ? remp : rem2, d = array(t), n = d.length;
      for (let i = 0; i < n; ++i)
        a.push(d[i]);
      return this;
    },
    modify(t, field3, value3) {
      const m = {
        field: field3,
        value: constant(value3)
      };
      if (isFunction(t)) {
        m.filter = t;
        modp.push(m);
      } else {
        m.tuple = t;
        mod.push(m);
      }
      return this;
    },
    encode(t, set4) {
      if (isFunction(t))
        modp.push({
          filter: t,
          field: set4
        });
      else
        mod.push({
          tuple: t,
          field: set4
        });
      return this;
    },
    clean(value3) {
      clean = value3;
      return this;
    },
    reflow() {
      reflow2 = true;
      return this;
    },
    pulse(pulse2, tuples) {
      const cur = {}, out = {};
      let i, n, m, f, t, id2;
      for (i = 0, n = tuples.length; i < n; ++i) {
        cur[tupleid(tuples[i])] = 1;
      }
      for (i = 0, n = rem2.length; i < n; ++i) {
        t = rem2[i];
        cur[tupleid(t)] = -1;
      }
      for (i = 0, n = remp.length; i < n; ++i) {
        f = remp[i];
        tuples.forEach((t2) => {
          if (f(t2))
            cur[tupleid(t2)] = -1;
        });
      }
      for (i = 0, n = add4.length; i < n; ++i) {
        t = add4[i];
        id2 = tupleid(t);
        if (cur[id2]) {
          cur[id2] = 1;
        } else {
          pulse2.add.push(ingest$1(add4[i]));
        }
      }
      for (i = 0, n = tuples.length; i < n; ++i) {
        t = tuples[i];
        if (cur[tupleid(t)] < 0)
          pulse2.rem.push(t);
      }
      function modify2(t2, f2, v) {
        if (v) {
          t2[f2] = v(t2);
        } else {
          pulse2.encode = f2;
        }
        if (!reflow2)
          out[tupleid(t2)] = t2;
      }
      for (i = 0, n = mod.length; i < n; ++i) {
        m = mod[i];
        t = m.tuple;
        f = m.field;
        id2 = cur[tupleid(t)];
        if (id2 > 0) {
          modify2(t, f, m.value);
          pulse2.modifies(f);
        }
      }
      for (i = 0, n = modp.length; i < n; ++i) {
        m = modp[i];
        f = m.filter;
        tuples.forEach((t2) => {
          if (f(t2) && cur[tupleid(t2)] > 0) {
            modify2(t2, m.field, m.value);
          }
        });
        pulse2.modifies(m.field);
      }
      if (reflow2) {
        pulse2.mod = rem2.length || remp.length ? tuples.filter((t2) => cur[tupleid(t2)] > 0) : tuples.slice();
      } else {
        for (id2 in out)
          pulse2.mod.push(out[id2]);
      }
      if (clean || clean == null && (rem2.length || remp.length)) {
        pulse2.clean(true);
      }
      return pulse2;
    }
  };
}
var CACHE = "_:mod:_";
function Parameters() {
  Object.defineProperty(this, CACHE, {
    writable: true,
    value: {}
  });
}
Parameters.prototype = {
  /**
   * Set a parameter value. If the parameter value changes, the parameter
   * will be recorded as modified.
   * @param {string} name - The parameter name.
   * @param {number} index - The index into an array-value parameter. Ignored if
   *   the argument is undefined, null or less than zero.
   * @param {*} value - The parameter value to set.
   * @param {boolean} [force=false] - If true, records the parameter as modified
   *   even if the value is unchanged.
   * @return {Parameters} - This parameter object.
   */
  set(name, index2, value3, force) {
    const o = this, v = o[name], mod = o[CACHE];
    if (index2 != null && index2 >= 0) {
      if (v[index2] !== value3 || force) {
        v[index2] = value3;
        mod[index2 + ":" + name] = -1;
        mod[name] = -1;
      }
    } else if (v !== value3 || force) {
      o[name] = value3;
      mod[name] = isArray(value3) ? 1 + value3.length : -1;
    }
    return o;
  },
  /**
   * Tests if one or more parameters has been modified. If invoked with no
   * arguments, returns true if any parameter value has changed. If the first
   * argument is array, returns trues if any parameter name in the array has
   * changed. Otherwise, tests if the given name and optional array index has
   * changed.
   * @param {string} name - The parameter name to test.
   * @param {number} [index=undefined] - The parameter array index to test.
   * @return {boolean} - Returns true if a queried parameter was modified.
   */
  modified(name, index2) {
    const mod = this[CACHE];
    if (!arguments.length) {
      for (const k2 in mod) {
        if (mod[k2])
          return true;
      }
      return false;
    } else if (isArray(name)) {
      for (let k2 = 0; k2 < name.length; ++k2) {
        if (mod[name[k2]])
          return true;
      }
      return false;
    }
    return index2 != null && index2 >= 0 ? index2 + 1 < mod[name] || !!mod[index2 + ":" + name] : !!mod[name];
  },
  /**
   * Clears the modification records. After calling this method,
   * all parameters are considered unmodified.
   */
  clear() {
    this[CACHE] = {};
    return this;
  }
};
var OP_ID = 0;
var PULSE = "pulse";
var NO_PARAMS = new Parameters();
var SKIP$1 = 1;
var MODIFIED = 2;
function Operator(init2, update3, params2, react) {
  this.id = ++OP_ID;
  this.value = init2;
  this.stamp = -1;
  this.rank = -1;
  this.qrank = -1;
  this.flags = 0;
  if (update3) {
    this._update = update3;
  }
  if (params2)
    this.parameters(params2, react);
}
function flag(bit) {
  return function(state) {
    const f = this.flags;
    if (arguments.length === 0)
      return !!(f & bit);
    this.flags = state ? f | bit : f & ~bit;
    return this;
  };
}
Operator.prototype = {
  /**
   * Returns a list of target operators dependent on this operator.
   * If this list does not exist, it is created and then returned.
   * @return {UniqueList}
   */
  targets() {
    return this._targets || (this._targets = UniqueList(id));
  },
  /**
   * Sets the value of this operator.
   * @param {*} value - the value to set.
   * @return {Number} Returns 1 if the operator value has changed
   *   according to strict equality, returns 0 otherwise.
   */
  set(value3) {
    if (this.value !== value3) {
      this.value = value3;
      return 1;
    } else {
      return 0;
    }
  },
  /**
   * Indicates that operator evaluation should be skipped on the next pulse.
   * This operator will still propagate incoming pulses, but its update function
   * will not be invoked. The skip flag is reset after every pulse, so calling
   * this method will affect processing of the next pulse only.
   */
  skip: flag(SKIP$1),
  /**
   * Indicates that this operator's value has been modified on its most recent
   * pulse. Normally modification is checked via strict equality; however, in
   * some cases it is more efficient to update the internal state of an object.
   * In those cases, the modified flag can be used to trigger propagation. Once
   * set, the modification flag persists across pulses until unset. The flag can
   * be used with the last timestamp to test if a modification is recent.
   */
  modified: flag(MODIFIED),
  /**
   * Sets the parameters for this operator. The parameter values are analyzed for
   * operator instances. If found, this operator will be added as a dependency
   * of the parameterizing operator. Operator values are dynamically marshalled
   * from each operator parameter prior to evaluation. If a parameter value is
   * an array, the array will also be searched for Operator instances. However,
   * the search does not recurse into sub-arrays or object properties.
   * @param {object} params - A hash of operator parameters.
   * @param {boolean} [react=true] - A flag indicating if this operator should
   *   automatically update (react) when parameter values change. In other words,
   *   this flag determines if the operator registers itself as a listener on
   *   any upstream operators included in the parameters.
   * @param {boolean} [initonly=false] - A flag indicating if this operator
   *   should calculate an update only upon its initial evaluation, then
   *   deregister dependencies and suppress all future update invocations.
   * @return {Operator[]} - An array of upstream dependencies.
   */
  parameters(params2, react, initonly) {
    react = react !== false;
    const argval = this._argval = this._argval || new Parameters(), argops = this._argops = this._argops || [], deps = [];
    let name, value3, n, i;
    const add4 = (name2, index2, value4) => {
      if (value4 instanceof Operator) {
        if (value4 !== this) {
          if (react)
            value4.targets().add(this);
          deps.push(value4);
        }
        argops.push({
          op: value4,
          name: name2,
          index: index2
        });
      } else {
        argval.set(name2, index2, value4);
      }
    };
    for (name in params2) {
      value3 = params2[name];
      if (name === PULSE) {
        array(value3).forEach((op) => {
          if (!(op instanceof Operator)) {
            error("Pulse parameters must be operator instances.");
          } else if (op !== this) {
            op.targets().add(this);
            deps.push(op);
          }
        });
        this.source = value3;
      } else if (isArray(value3)) {
        argval.set(name, -1, Array(n = value3.length));
        for (i = 0; i < n; ++i)
          add4(name, i, value3[i]);
      } else {
        add4(name, -1, value3);
      }
    }
    this.marshall().clear();
    if (initonly)
      argops.initonly = true;
    return deps;
  },
  /**
   * Internal method for marshalling parameter values.
   * Visits each operator dependency to pull the latest value.
   * @return {Parameters} A Parameters object to pass to the update function.
   */
  marshall(stamp) {
    const argval = this._argval || NO_PARAMS, argops = this._argops;
    let item, i, op, mod;
    if (argops) {
      const n = argops.length;
      for (i = 0; i < n; ++i) {
        item = argops[i];
        op = item.op;
        mod = op.modified() && op.stamp === stamp;
        argval.set(item.name, item.index, op.value, mod);
      }
      if (argops.initonly) {
        for (i = 0; i < n; ++i) {
          item = argops[i];
          item.op.targets().remove(this);
        }
        this._argops = null;
        this._update = null;
      }
    }
    return argval;
  },
  /**
   * Detach this operator from the dataflow.
   * Unregisters listeners on upstream dependencies.
   */
  detach() {
    const argops = this._argops;
    let i, n, item, op;
    if (argops) {
      for (i = 0, n = argops.length; i < n; ++i) {
        item = argops[i];
        op = item.op;
        if (op._targets) {
          op._targets.remove(this);
        }
      }
    }
    this.pulse = null;
    this.source = null;
  },
  /**
   * Delegate method to perform operator processing.
   * Subclasses can override this method to perform custom processing.
   * By default, it marshalls parameters and calls the update function
   * if that function is defined. If the update function does not
   * change the operator value then StopPropagation is returned.
   * If no update function is defined, this method does nothing.
   * @param {Pulse} pulse - the current dataflow pulse.
   * @return The output pulse or StopPropagation. A falsy return value
   *   (including undefined) will let the input pulse pass through.
   */
  evaluate(pulse2) {
    const update3 = this._update;
    if (update3) {
      const params2 = this.marshall(pulse2.stamp), v = update3.call(this, params2, pulse2);
      params2.clear();
      if (v !== this.value) {
        this.value = v;
      } else if (!this.modified()) {
        return pulse2.StopPropagation;
      }
    }
  },
  /**
   * Run this operator for the current pulse. If this operator has already
   * been run at (or after) the pulse timestamp, returns StopPropagation.
   * Internally, this method calls {@link evaluate} to perform processing.
   * If {@link evaluate} returns a falsy value, the input pulse is returned.
   * This method should NOT be overridden, instead overrride {@link evaluate}.
   * @param {Pulse} pulse - the current dataflow pulse.
   * @return the output pulse for this operator (or StopPropagation)
   */
  run(pulse2) {
    if (pulse2.stamp < this.stamp)
      return pulse2.StopPropagation;
    let rv;
    if (this.skip()) {
      this.skip(false);
      rv = 0;
    } else {
      rv = this.evaluate(pulse2);
    }
    return this.pulse = rv || pulse2;
  }
};
function add(init2, update3, params2, react) {
  let shift = 1, op;
  if (init2 instanceof Operator) {
    op = init2;
  } else if (init2 && init2.prototype instanceof Operator) {
    op = new init2();
  } else if (isFunction(init2)) {
    op = new Operator(null, init2);
  } else {
    shift = 0;
    op = new Operator(init2, update3);
  }
  this.rank(op);
  if (shift) {
    react = params2;
    params2 = update3;
  }
  if (params2)
    this.connect(op, op.parameters(params2, react));
  this.touch(op);
  return op;
}
function connect(target2, sources) {
  const targetRank = target2.rank, n = sources.length;
  for (let i = 0; i < n; ++i) {
    if (targetRank < sources[i].rank) {
      this.rerank(target2);
      return;
    }
  }
}
var STREAM_ID = 0;
function EventStream(filter3, apply2, receive) {
  this.id = ++STREAM_ID;
  this.value = null;
  if (receive)
    this.receive = receive;
  if (filter3)
    this._filter = filter3;
  if (apply2)
    this._apply = apply2;
}
function stream(filter3, apply2, receive) {
  return new EventStream(filter3, apply2, receive);
}
EventStream.prototype = {
  _filter: truthy,
  _apply: identity2,
  targets() {
    return this._targets || (this._targets = UniqueList(id));
  },
  consume(_) {
    if (!arguments.length)
      return !!this._consume;
    this._consume = !!_;
    return this;
  },
  receive(evt) {
    if (this._filter(evt)) {
      const val = this.value = this._apply(evt), trg = this._targets, n = trg ? trg.length : 0;
      for (let i = 0; i < n; ++i)
        trg[i].receive(val);
      if (this._consume) {
        evt.preventDefault();
        evt.stopPropagation();
      }
    }
  },
  filter(filter3) {
    const s = stream(filter3);
    this.targets().add(s);
    return s;
  },
  apply(apply2) {
    const s = stream(null, apply2);
    this.targets().add(s);
    return s;
  },
  merge() {
    const s = stream();
    this.targets().add(s);
    for (let i = 0, n = arguments.length; i < n; ++i) {
      arguments[i].targets().add(s);
    }
    return s;
  },
  throttle(pause) {
    let t = -1;
    return this.filter(() => {
      const now = Date.now();
      if (now - t > pause) {
        t = now;
        return 1;
      } else {
        return 0;
      }
    });
  },
  debounce(delay) {
    const s = stream();
    this.targets().add(stream(null, null, debounce(delay, (e) => {
      const df = e.dataflow;
      s.receive(e);
      if (df && df.run)
        df.run();
    })));
    return s;
  },
  between(a, b2) {
    let active = false;
    a.targets().add(stream(null, null, () => active = true));
    b2.targets().add(stream(null, null, () => active = false));
    return this.filter(() => active);
  },
  detach() {
    this._filter = truthy;
    this._targets = null;
  }
};
function events(source3, type2, filter3, apply2) {
  const df = this, s = stream(filter3, apply2), send = function(e) {
    e.dataflow = df;
    try {
      s.receive(e);
    } catch (error2) {
      df.error(error2);
    } finally {
      df.run();
    }
  };
  let sources;
  if (typeof source3 === "string" && typeof document !== "undefined") {
    sources = document.querySelectorAll(source3);
  } else {
    sources = array(source3);
  }
  const n = sources.length;
  for (let i = 0; i < n; ++i) {
    sources[i].addEventListener(type2, send);
  }
  return s;
}
function parse2(data3, format5) {
  const locale2 = this.locale();
  return read(data3, format5, locale2.timeParse, locale2.utcParse);
}
function ingest(target2, data3, format5) {
  data3 = this.parse(data3, format5);
  return this.pulse(target2, this.changeset().insert(data3));
}
async function request(url, format5) {
  const df = this;
  let status = 0, data3;
  try {
    data3 = await df.loader().load(url, {
      context: "dataflow",
      response: responseType(format5 && format5.type)
    });
    try {
      data3 = df.parse(data3, format5);
    } catch (err) {
      status = -2;
      df.warn("Data ingestion failed", url, err);
    }
  } catch (err) {
    status = -1;
    df.warn("Loading failed", url, err);
  }
  return {
    data: data3,
    status
  };
}
async function preload(target2, url, format5) {
  const df = this, pending = df._pending || loadPending(df);
  pending.requests += 1;
  const res = await df.request(url, format5);
  df.pulse(target2, df.changeset().remove(truthy).insert(res.data || []));
  pending.done();
  return res;
}
function loadPending(df) {
  let accept;
  const pending = new Promise((a) => accept = a);
  pending.requests = 0;
  pending.done = () => {
    if (--pending.requests === 0) {
      df._pending = null;
      accept(df);
    }
  };
  return df._pending = pending;
}
var SKIP = {
  skip: true
};
function on(source3, target2, update3, params2, options) {
  const fn = source3 instanceof Operator ? onOperator : onStream;
  fn(this, source3, target2, update3, params2, options);
  return this;
}
function onStream(df, stream2, target2, update3, params2, options) {
  const opt = extend({}, options, SKIP);
  let func, op;
  if (!isFunction(target2))
    target2 = constant(target2);
  if (update3 === void 0) {
    func = (e) => df.touch(target2(e));
  } else if (isFunction(update3)) {
    op = new Operator(null, update3, params2, false);
    func = (e) => {
      op.evaluate(e);
      const t = target2(e), v = op.value;
      isChangeSet(v) ? df.pulse(t, v, options) : df.update(t, v, opt);
    };
  } else {
    func = (e) => df.update(target2(e), update3, opt);
  }
  stream2.apply(func);
}
function onOperator(df, source3, target2, update3, params2, options) {
  if (update3 === void 0) {
    source3.targets().add(target2);
  } else {
    const opt = options || {}, op = new Operator(null, updater(target2, update3), params2, false);
    op.modified(opt.force);
    op.rank = source3.rank;
    source3.targets().add(op);
    if (target2) {
      op.skip(true);
      op.value = target2.value;
      op.targets().add(target2);
      df.connect(target2, [op]);
    }
  }
}
function updater(target2, update3) {
  update3 = isFunction(update3) ? update3 : constant(update3);
  return target2 ? function(_, pulse2) {
    const value3 = update3(_, pulse2);
    if (!target2.skip()) {
      target2.skip(value3 !== this.value).value = value3;
    }
    return value3;
  } : update3;
}
function rank(op) {
  op.rank = ++this._rank;
}
function rerank(op) {
  const queue = [op];
  let cur, list, i;
  while (queue.length) {
    this.rank(cur = queue.pop());
    if (list = cur._targets) {
      for (i = list.length; --i >= 0; ) {
        queue.push(cur = list[i]);
        if (cur === op)
          error("Cycle detected in dataflow graph.");
      }
    }
  }
}
var StopPropagation = {};
var ADD = 1 << 0;
var REM = 1 << 1;
var MOD = 1 << 2;
var ADD_REM = ADD | REM;
var ADD_MOD = ADD | MOD;
var ALL = ADD | REM | MOD;
var REFLOW = 1 << 3;
var SOURCE = 1 << 4;
var NO_SOURCE = 1 << 5;
var NO_FIELDS = 1 << 6;
function Pulse(dataflow, stamp, encode2) {
  this.dataflow = dataflow;
  this.stamp = stamp == null ? -1 : stamp;
  this.add = [];
  this.rem = [];
  this.mod = [];
  this.fields = null;
  this.encode = encode2 || null;
}
function materialize(data3, filter3) {
  const out = [];
  visitArray(data3, filter3, (_) => out.push(_));
  return out;
}
function filter(pulse2, flags) {
  const map2 = {};
  pulse2.visit(flags, (t) => {
    map2[tupleid(t)] = 1;
  });
  return (t) => map2[tupleid(t)] ? null : t;
}
function addFilter(a, b2) {
  return a ? (t, i) => a(t, i) && b2(t, i) : b2;
}
Pulse.prototype = {
  /**
   * Sentinel value indicating pulse propagation should stop.
   */
  StopPropagation,
  /**
   * Boolean flag indicating ADD (added) tuples.
   */
  ADD,
  /**
   * Boolean flag indicating REM (removed) tuples.
   */
  REM,
  /**
   * Boolean flag indicating MOD (modified) tuples.
   */
  MOD,
  /**
   * Boolean flag indicating ADD (added) and REM (removed) tuples.
   */
  ADD_REM,
  /**
   * Boolean flag indicating ADD (added) and MOD (modified) tuples.
   */
  ADD_MOD,
  /**
   * Boolean flag indicating ADD, REM and MOD tuples.
   */
  ALL,
  /**
   * Boolean flag indicating all tuples in a data source
   * except for the ADD, REM and MOD tuples.
   */
  REFLOW,
  /**
   * Boolean flag indicating a 'pass-through' to a
   * backing data source, ignoring ADD, REM and MOD tuples.
   */
  SOURCE,
  /**
   * Boolean flag indicating that source data should be
   * suppressed when creating a forked pulse.
   */
  NO_SOURCE,
  /**
   * Boolean flag indicating that field modifications should be
   * suppressed when creating a forked pulse.
   */
  NO_FIELDS,
  /**
   * Creates a new pulse based on the values of this pulse.
   * The dataflow, time stamp and field modification values are copied over.
   * By default, new empty ADD, REM and MOD arrays are created.
   * @param {number} flags - Integer of boolean flags indicating which (if any)
   *   tuple arrays should be copied to the new pulse. The supported flag values
   *   are ADD, REM and MOD. Array references are copied directly: new array
   *   instances are not created.
   * @return {Pulse} - The forked pulse instance.
   * @see init
   */
  fork(flags) {
    return new Pulse(this.dataflow).init(this, flags);
  },
  /**
   * Creates a copy of this pulse with new materialized array
   * instances for the ADD, REM, MOD, and SOURCE arrays.
   * The dataflow, time stamp and field modification values are copied over.
   * @return {Pulse} - The cloned pulse instance.
   * @see init
   */
  clone() {
    const p = this.fork(ALL);
    p.add = p.add.slice();
    p.rem = p.rem.slice();
    p.mod = p.mod.slice();
    if (p.source)
      p.source = p.source.slice();
    return p.materialize(ALL | SOURCE);
  },
  /**
   * Returns a pulse that adds all tuples from a backing source. This is
   * useful for cases where operators are added to a dataflow after an
   * upstream data pipeline has already been processed, ensuring that
   * new operators can observe all tuples within a stream.
   * @return {Pulse} - A pulse instance with all source tuples included
   *   in the add array. If the current pulse already has all source
   *   tuples in its add array, it is returned directly. If the current
   *   pulse does not have a backing source, it is returned directly.
   */
  addAll() {
    let p = this;
    const reuse = !p.source || p.add === p.rem || !p.rem.length && p.source.length === p.add.length;
    if (reuse) {
      return p;
    } else {
      p = new Pulse(this.dataflow).init(this);
      p.add = p.source;
      p.rem = [];
      return p;
    }
  },
  /**
   * Initialize this pulse based on the values of another pulse. This method
   * is used internally by {@link fork} to initialize a new forked tuple.
   * The dataflow, time stamp and field modification values are copied over.
   * By default, new empty ADD, REM and MOD arrays are created.
   * @param {Pulse} src - The source pulse to copy from.
   * @param {number} flags - Integer of boolean flags indicating which (if any)
   *   tuple arrays should be copied to the new pulse. The supported flag values
   *   are ADD, REM and MOD. Array references are copied directly: new array
   *   instances are not created. By default, source data arrays are copied
   *   to the new pulse. Use the NO_SOURCE flag to enforce a null source.
   * @return {Pulse} - Returns this Pulse instance.
   */
  init(src, flags) {
    const p = this;
    p.stamp = src.stamp;
    p.encode = src.encode;
    if (src.fields && !(flags & NO_FIELDS)) {
      p.fields = src.fields;
    }
    if (flags & ADD) {
      p.addF = src.addF;
      p.add = src.add;
    } else {
      p.addF = null;
      p.add = [];
    }
    if (flags & REM) {
      p.remF = src.remF;
      p.rem = src.rem;
    } else {
      p.remF = null;
      p.rem = [];
    }
    if (flags & MOD) {
      p.modF = src.modF;
      p.mod = src.mod;
    } else {
      p.modF = null;
      p.mod = [];
    }
    if (flags & NO_SOURCE) {
      p.srcF = null;
      p.source = null;
    } else {
      p.srcF = src.srcF;
      p.source = src.source;
      if (src.cleans)
        p.cleans = src.cleans;
    }
    return p;
  },
  /**
   * Schedules a function to run after pulse propagation completes.
   * @param {function} func - The function to run.
   */
  runAfter(func) {
    this.dataflow.runAfter(func);
  },
  /**
   * Indicates if tuples have been added, removed or modified.
   * @param {number} [flags] - The tuple types (ADD, REM or MOD) to query.
   *   Defaults to ALL, returning true if any tuple type has changed.
   * @return {boolean} - Returns true if one or more queried tuple types have
   *   changed, false otherwise.
   */
  changed(flags) {
    const f = flags || ALL;
    return f & ADD && this.add.length || f & REM && this.rem.length || f & MOD && this.mod.length;
  },
  /**
   * Forces a "reflow" of tuple values, such that all tuples in the backing
   * source are added to the MOD set, unless already present in the ADD set.
   * @param {boolean} [fork=false] - If true, returns a forked copy of this
   *   pulse, and invokes reflow on that derived pulse.
   * @return {Pulse} - The reflowed pulse instance.
   */
  reflow(fork) {
    if (fork)
      return this.fork(ALL).reflow();
    const len = this.add.length, src = this.source && this.source.length;
    if (src && src !== len) {
      this.mod = this.source;
      if (len)
        this.filter(MOD, filter(this, ADD));
    }
    return this;
  },
  /**
   * Get/set metadata to pulse requesting garbage collection
   * to reclaim currently unused resources.
   */
  clean(value3) {
    if (arguments.length) {
      this.cleans = !!value3;
      return this;
    } else {
      return this.cleans;
    }
  },
  /**
   * Marks one or more data field names as modified to assist dependency
   * tracking and incremental processing by transform operators.
   * @param {string|Array<string>} _ - The field(s) to mark as modified.
   * @return {Pulse} - This pulse instance.
   */
  modifies(_) {
    const hash = this.fields || (this.fields = {});
    if (isArray(_)) {
      _.forEach((f) => hash[f] = true);
    } else {
      hash[_] = true;
    }
    return this;
  },
  /**
   * Checks if one or more data fields have been modified during this pulse
   * propagation timestamp.
   * @param {string|Array<string>} _ - The field(s) to check for modified.
   * @param {boolean} nomod - If true, will check the modified flag even if
   *   no mod tuples exist. If false (default), mod tuples must be present.
   * @return {boolean} - Returns true if any of the provided fields has been
   *   marked as modified, false otherwise.
   */
  modified(_, nomod) {
    const fields = this.fields;
    return !((nomod || this.mod.length) && fields) ? false : !arguments.length ? !!fields : isArray(_) ? _.some((f) => fields[f]) : fields[_];
  },
  /**
   * Adds a filter function to one more tuple sets. Filters are applied to
   * backing tuple arrays, to determine the actual set of tuples considered
   * added, removed or modified. They can be used to delay materialization of
   * a tuple set in order to avoid expensive array copies. In addition, the
   * filter functions can serve as value transformers: unlike standard predicate
   * function (which return boolean values), Pulse filters should return the
   * actual tuple value to process. If a tuple set is already filtered, the
   * new filter function will be appended into a conjuntive ('and') query.
   * @param {number} flags - Flags indicating the tuple set(s) to filter.
   * @param {function(*):object} filter - Filter function that will be applied
   *   to the tuple set array, and should return a data tuple if the value
   *   should be included in the tuple set, and falsy (or null) otherwise.
   * @return {Pulse} - Returns this pulse instance.
   */
  filter(flags, filter3) {
    const p = this;
    if (flags & ADD)
      p.addF = addFilter(p.addF, filter3);
    if (flags & REM)
      p.remF = addFilter(p.remF, filter3);
    if (flags & MOD)
      p.modF = addFilter(p.modF, filter3);
    if (flags & SOURCE)
      p.srcF = addFilter(p.srcF, filter3);
    return p;
  },
  /**
   * Materialize one or more tuple sets in this pulse. If the tuple set(s) have
   * a registered filter function, it will be applied and the tuple set(s) will
   * be replaced with materialized tuple arrays.
   * @param {number} flags - Flags indicating the tuple set(s) to materialize.
   * @return {Pulse} - Returns this pulse instance.
   */
  materialize(flags) {
    flags = flags || ALL;
    const p = this;
    if (flags & ADD && p.addF) {
      p.add = materialize(p.add, p.addF);
      p.addF = null;
    }
    if (flags & REM && p.remF) {
      p.rem = materialize(p.rem, p.remF);
      p.remF = null;
    }
    if (flags & MOD && p.modF) {
      p.mod = materialize(p.mod, p.modF);
      p.modF = null;
    }
    if (flags & SOURCE && p.srcF) {
      p.source = p.source.filter(p.srcF);
      p.srcF = null;
    }
    return p;
  },
  /**
   * Visit one or more tuple sets in this pulse.
   * @param {number} flags - Flags indicating the tuple set(s) to visit.
   *   Legal values are ADD, REM, MOD and SOURCE (if a backing data source
   *   has been set).
   * @param {function(object):*} - Visitor function invoked per-tuple.
   * @return {Pulse} - Returns this pulse instance.
   */
  visit(flags, visitor) {
    const p = this, v = visitor;
    if (flags & SOURCE) {
      visitArray(p.source, p.srcF, v);
      return p;
    }
    if (flags & ADD)
      visitArray(p.add, p.addF, v);
    if (flags & REM)
      visitArray(p.rem, p.remF, v);
    if (flags & MOD)
      visitArray(p.mod, p.modF, v);
    const src = p.source;
    if (flags & REFLOW && src) {
      const sum2 = p.add.length + p.mod.length;
      if (sum2 === src.length)
        ;
      else if (sum2) {
        visitArray(src, filter(p, ADD_MOD), v);
      } else {
        visitArray(src, p.srcF, v);
      }
    }
    return p;
  }
};
function MultiPulse(dataflow, stamp, pulses, encode2) {
  const p = this;
  let c = 0;
  this.dataflow = dataflow;
  this.stamp = stamp;
  this.fields = null;
  this.encode = encode2 || null;
  this.pulses = pulses;
  for (const pulse2 of pulses) {
    if (pulse2.stamp !== stamp)
      continue;
    if (pulse2.fields) {
      const hash = p.fields || (p.fields = {});
      for (const f in pulse2.fields) {
        hash[f] = 1;
      }
    }
    if (pulse2.changed(p.ADD))
      c |= p.ADD;
    if (pulse2.changed(p.REM))
      c |= p.REM;
    if (pulse2.changed(p.MOD))
      c |= p.MOD;
  }
  this.changes = c;
}
inherits(MultiPulse, Pulse, {
  /**
   * Creates a new pulse based on the values of this pulse.
   * The dataflow, time stamp and field modification values are copied over.
   * @return {Pulse}
   */
  fork(flags) {
    const p = new Pulse(this.dataflow).init(this, flags & this.NO_FIELDS);
    if (flags !== void 0) {
      if (flags & p.ADD)
        this.visit(p.ADD, (t) => p.add.push(t));
      if (flags & p.REM)
        this.visit(p.REM, (t) => p.rem.push(t));
      if (flags & p.MOD)
        this.visit(p.MOD, (t) => p.mod.push(t));
    }
    return p;
  },
  changed(flags) {
    return this.changes & flags;
  },
  modified(_) {
    const p = this, fields = p.fields;
    return !(fields && p.changes & p.MOD) ? 0 : isArray(_) ? _.some((f) => fields[f]) : fields[_];
  },
  filter() {
    error("MultiPulse does not support filtering.");
  },
  materialize() {
    error("MultiPulse does not support materialization.");
  },
  visit(flags, visitor) {
    const p = this, pulses = p.pulses, n = pulses.length;
    let i = 0;
    if (flags & p.SOURCE) {
      for (; i < n; ++i) {
        pulses[i].visit(flags, visitor);
      }
    } else {
      for (; i < n; ++i) {
        if (pulses[i].stamp === p.stamp) {
          pulses[i].visit(flags, visitor);
        }
      }
    }
    return p;
  }
});
async function evaluate(encode2, prerun, postrun) {
  const df = this, async = [];
  if (df._pulse)
    return reentrant(df);
  if (df._pending)
    await df._pending;
  if (prerun)
    await asyncCallback(df, prerun);
  if (!df._touched.length) {
    df.debug("Dataflow invoked, but nothing to do.");
    return df;
  }
  const stamp = ++df._clock;
  df._pulse = new Pulse(df, stamp, encode2);
  df._touched.forEach((op2) => df._enqueue(op2, true));
  df._touched = UniqueList(id);
  let count = 0, op, next, error2;
  try {
    while (df._heap.size() > 0) {
      op = df._heap.pop();
      if (op.rank !== op.qrank) {
        df._enqueue(op, true);
        continue;
      }
      next = op.run(df._getPulse(op, encode2));
      if (next.then) {
        next = await next;
      } else if (next.async) {
        async.push(next.async);
        next = StopPropagation;
      }
      if (next !== StopPropagation) {
        if (op._targets)
          op._targets.forEach((op2) => df._enqueue(op2));
      }
      ++count;
    }
  } catch (err) {
    df._heap.clear();
    error2 = err;
  }
  df._input = {};
  df._pulse = null;
  df.debug(`Pulse ${stamp}: ${count} operators`);
  if (error2) {
    df._postrun = [];
    df.error(error2);
  }
  if (df._postrun.length) {
    const pr = df._postrun.sort((a, b2) => b2.priority - a.priority);
    df._postrun = [];
    for (let i = 0; i < pr.length; ++i) {
      await asyncCallback(df, pr[i].callback);
    }
  }
  if (postrun)
    await asyncCallback(df, postrun);
  if (async.length) {
    Promise.all(async).then((cb) => df.runAsync(null, () => {
      cb.forEach((f) => {
        try {
          f(df);
        } catch (err) {
          df.error(err);
        }
      });
    }));
  }
  return df;
}
async function runAsync(encode2, prerun, postrun) {
  while (this._running)
    await this._running;
  const clear = () => this._running = null;
  (this._running = this.evaluate(encode2, prerun, postrun)).then(clear, clear);
  return this._running;
}
function run(encode2, prerun, postrun) {
  return this._pulse ? reentrant(this) : (this.evaluate(encode2, prerun, postrun), this);
}
function runAfter(callback, enqueue2, priority) {
  if (this._pulse || enqueue2) {
    this._postrun.push({
      priority: priority || 0,
      callback
    });
  } else {
    try {
      callback(this);
    } catch (err) {
      this.error(err);
    }
  }
}
function reentrant(df) {
  df.error("Dataflow already running. Use runAsync() to chain invocations.");
  return df;
}
function enqueue(op, force) {
  const q = op.stamp < this._clock;
  if (q)
    op.stamp = this._clock;
  if (q || force) {
    op.qrank = op.rank;
    this._heap.push(op);
  }
}
function getPulse(op, encode2) {
  const s = op.source, stamp = this._clock;
  return s && isArray(s) ? new MultiPulse(this, stamp, s.map((_) => _.pulse), encode2) : this._input[op.id] || singlePulse(this._pulse, s && s.pulse);
}
function singlePulse(p, s) {
  if (s && s.stamp === p.stamp) {
    return s;
  }
  p = p.fork();
  if (s && s !== StopPropagation) {
    p.source = s.source;
  }
  return p;
}
var NO_OPT = {
  skip: false,
  force: false
};
function touch(op, options) {
  const opt = options || NO_OPT;
  if (this._pulse) {
    this._enqueue(op);
  } else {
    this._touched.add(op);
  }
  if (opt.skip)
    op.skip(true);
  return this;
}
function update(op, value3, options) {
  const opt = options || NO_OPT;
  if (op.set(value3) || opt.force) {
    this.touch(op, opt);
  }
  return this;
}
function pulse(op, changeset2, options) {
  this.touch(op, options || NO_OPT);
  const p = new Pulse(this, this._clock + (this._pulse ? 0 : 1)), t = op.pulse && op.pulse.source || [];
  p.target = op;
  this._input[op.id] = changeset2.pulse(p, t);
  return this;
}
function Heap(cmp) {
  let nodes = [];
  return {
    clear: () => nodes = [],
    size: () => nodes.length,
    peek: () => nodes[0],
    push: (x2) => {
      nodes.push(x2);
      return siftdown(nodes, 0, nodes.length - 1, cmp);
    },
    pop: () => {
      const last = nodes.pop();
      let item;
      if (nodes.length) {
        item = nodes[0];
        nodes[0] = last;
        siftup(nodes, 0, cmp);
      } else {
        item = last;
      }
      return item;
    }
  };
}
function siftdown(array4, start, idx, cmp) {
  let parent, pidx;
  const item = array4[idx];
  while (idx > start) {
    pidx = idx - 1 >> 1;
    parent = array4[pidx];
    if (cmp(item, parent) < 0) {
      array4[idx] = parent;
      idx = pidx;
      continue;
    }
    break;
  }
  return array4[idx] = item;
}
function siftup(array4, idx, cmp) {
  const start = idx, end = array4.length, item = array4[idx];
  let cidx = (idx << 1) + 1, ridx;
  while (cidx < end) {
    ridx = cidx + 1;
    if (ridx < end && cmp(array4[cidx], array4[ridx]) >= 0) {
      cidx = ridx;
    }
    array4[idx] = array4[cidx];
    idx = cidx;
    cidx = (idx << 1) + 1;
  }
  array4[idx] = item;
  return siftdown(array4, start, idx, cmp);
}
function Dataflow() {
  this.logger(logger());
  this.logLevel(Error$1);
  this._clock = 0;
  this._rank = 0;
  this._locale = defaultLocale();
  try {
    this._loader = loader();
  } catch (e) {
  }
  this._touched = UniqueList(id);
  this._input = {};
  this._pulse = null;
  this._heap = Heap((a, b2) => a.qrank - b2.qrank);
  this._postrun = [];
}
function logMethod(method2) {
  return function() {
    return this._log[method2].apply(this, arguments);
  };
}
Dataflow.prototype = {
  /**
   * The current timestamp of this dataflow. This value reflects the
   * timestamp of the previous dataflow run. The dataflow is initialized
   * with a stamp value of 0. The initial run of the dataflow will have
   * a timestap of 1, and so on. This value will match the
   * {@link Pulse.stamp} property.
   * @return {number} - The current timestamp value.
   */
  stamp() {
    return this._clock;
  },
  /**
   * Gets or sets the loader instance to use for data file loading. A
   * loader object must provide a "load" method for loading files and a
   * "sanitize" method for checking URL/filename validity. Both methods
   * should accept a URI and options hash as arguments, and return a Promise
   * that resolves to the loaded file contents (load) or a hash containing
   * sanitized URI data with the sanitized url assigned to the "href" property
   * (sanitize).
   * @param {object} _ - The loader instance to use.
   * @return {object|Dataflow} - If no arguments are provided, returns
   *   the current loader instance. Otherwise returns this Dataflow instance.
   */
  loader(_) {
    if (arguments.length) {
      this._loader = _;
      return this;
    } else {
      return this._loader;
    }
  },
  /**
   * Gets or sets the locale instance to use for formatting and parsing
   * string values. The locale object should be provided by the
   * vega-format library, and include methods such as format, timeFormat,
   * utcFormat, timeParse, and utcParse.
   * @param {object} _ - The locale instance to use.
   * @return {object|Dataflow} - If no arguments are provided, returns
   *   the current locale instance. Otherwise returns this Dataflow instance.
   */
  locale(_) {
    if (arguments.length) {
      this._locale = _;
      return this;
    } else {
      return this._locale;
    }
  },
  /**
   * Get or set the logger instance used to log messages. If no arguments are
   * provided, returns the current logger instance. Otherwise, sets the logger
   * and return this Dataflow instance. Provided loggers must support the full
   * API of logger objects generated by the vega-util logger method. Note that
   * by default the log level of the new logger will be used; use the logLevel
   * method to adjust the log level as needed.
   */
  logger(logger2) {
    if (arguments.length) {
      this._log = logger2;
      return this;
    } else {
      return this._log;
    }
  },
  /**
   * Logs an error message. By default, logged messages are written to console
   * output. The message will only be logged if the current log level is high
   * enough to permit error messages.
   */
  error: logMethod("error"),
  /**
   * Logs a warning message. By default, logged messages are written to console
   * output. The message will only be logged if the current log level is high
   * enough to permit warning messages.
   */
  warn: logMethod("warn"),
  /**
   * Logs a information message. By default, logged messages are written to
   * console output. The message will only be logged if the current log level is
   * high enough to permit information messages.
   */
  info: logMethod("info"),
  /**
   * Logs a debug message. By default, logged messages are written to console
   * output. The message will only be logged if the current log level is high
   * enough to permit debug messages.
   */
  debug: logMethod("debug"),
  /**
   * Get or set the current log level. If an argument is provided, it
   * will be used as the new log level.
   * @param {number} [level] - Should be one of None, Warn, Info
   * @return {number} - The current log level.
   */
  logLevel: logMethod("level"),
  /**
   * Empty entry threshold for garbage cleaning. Map data structures will
   * perform cleaning once the number of empty entries exceeds this value.
   */
  cleanThreshold: 1e4,
  // OPERATOR REGISTRATION
  add,
  connect,
  rank,
  rerank,
  // OPERATOR UPDATES
  pulse,
  touch,
  update,
  changeset,
  // DATA LOADING
  ingest,
  parse: parse2,
  preload,
  request,
  // EVENT HANDLING
  events,
  on,
  // PULSE PROPAGATION
  evaluate,
  run,
  runAsync,
  runAfter,
  _enqueue: enqueue,
  _getPulse: getPulse
};
function Transform(init2, params2) {
  Operator.call(this, init2, null, params2);
}
inherits(Transform, Operator, {
  /**
   * Overrides {@link Operator.evaluate} for transform operators.
   * Internally, this method calls {@link evaluate} to perform processing.
   * If {@link evaluate} returns a falsy value, the input pulse is returned.
   * This method should NOT be overridden, instead overrride {@link evaluate}.
   * @param {Pulse} pulse - the current dataflow pulse.
   * @return the output pulse for this operator (or StopPropagation)
   */
  run(pulse2) {
    if (pulse2.stamp < this.stamp)
      return pulse2.StopPropagation;
    let rv;
    if (this.skip()) {
      this.skip(false);
    } else {
      rv = this.evaluate(pulse2);
    }
    rv = rv || pulse2;
    if (rv.then) {
      rv = rv.then((_) => this.pulse = _);
    } else if (rv !== pulse2.StopPropagation) {
      this.pulse = rv;
    }
    return rv;
  },
  /**
   * Overrides {@link Operator.evaluate} for transform operators.
   * Marshalls parameter values and then invokes {@link transform}.
   * @param {Pulse} pulse - the current dataflow pulse.
   * @return {Pulse} The output pulse (or StopPropagation). A falsy return
       value (including undefined) will let the input pulse pass through.
  */
  evaluate(pulse2) {
    const params2 = this.marshall(pulse2.stamp), out = this.transform(params2, pulse2);
    params2.clear();
    return out;
  },
  /**
   * Process incoming pulses.
   * Subclasses should override this method to implement transforms.
   * @param {Parameters} _ - The operator parameter values.
   * @param {Pulse} pulse - The current dataflow pulse.
   * @return {Pulse} The output pulse (or StopPropagation). A falsy return
   *   value (including undefined) will let the input pulse pass through.
   */
  transform() {
  }
});
var transforms = {};
function definition(type2) {
  const t = transform(type2);
  return t && t.Definition || null;
}
function transform(type2) {
  type2 = type2 && type2.toLowerCase();
  return has(transforms, type2) ? transforms[type2] : null;
}

// node_modules/vega-transforms/build/vega-transforms.module.js
var vega_transforms_module_exports = {};
__export(vega_transforms_module_exports, {
  aggregate: () => Aggregate,
  bin: () => Bin,
  collect: () => Collect,
  compare: () => Compare,
  countpattern: () => CountPattern,
  cross: () => Cross,
  density: () => Density,
  dotbin: () => DotBin,
  expression: () => Expression,
  extent: () => Extent,
  facet: () => Facet,
  field: () => Field,
  filter: () => Filter,
  flatten: () => Flatten,
  fold: () => Fold,
  formula: () => Formula,
  generate: () => Generate,
  impute: () => Impute,
  joinaggregate: () => JoinAggregate,
  kde: () => KDE,
  key: () => Key,
  load: () => Load,
  lookup: () => Lookup,
  multiextent: () => MultiExtent,
  multivalues: () => MultiValues,
  params: () => Params,
  pivot: () => Pivot,
  prefacet: () => PreFacet,
  project: () => Project,
  proxy: () => Proxy,
  quantile: () => Quantile,
  relay: () => Relay,
  sample: () => Sample,
  sequence: () => Sequence,
  sieve: () => Sieve,
  subflow: () => Subflow,
  timeunit: () => TimeUnit,
  tupleindex: () => TupleIndex,
  values: () => Values,
  window: () => Window
});

// node_modules/vega-statistics/build/vega-statistics.module.js
function* numbers(values2, valueof) {
  if (valueof == null) {
    for (let value3 of values2) {
      if (value3 != null && value3 !== "" && (value3 = +value3) >= value3) {
        yield value3;
      }
    }
  } else {
    let index2 = -1;
    for (let value3 of values2) {
      value3 = valueof(value3, ++index2, values2);
      if (value3 != null && value3 !== "" && (value3 = +value3) >= value3) {
        yield value3;
      }
    }
  }
}
function quantiles(array4, p, f) {
  const values2 = Float64Array.from(numbers(array4, f));
  values2.sort(ascending);
  return p.map((_) => quantileSorted(values2, _));
}
function quartiles(array4, f) {
  return quantiles(array4, [0.25, 0.5, 0.75], f);
}
function estimateBandwidth(array4, f) {
  const n = array4.length, d = deviation(array4, f), q = quartiles(array4, f), h2 = (q[2] - q[0]) / 1.34, v = Math.min(d, h2) || d || Math.abs(q[0]) || 1;
  return 1.06 * v * Math.pow(n, -0.2);
}
function bin2(_) {
  const maxb = _.maxbins || 20, base2 = _.base || 10, logb = Math.log(base2), div = _.divide || [5, 2];
  let min4 = _.extent[0], max4 = _.extent[1], step, level, minstep, v, i, n;
  const span2 = _.span || max4 - min4 || Math.abs(min4) || 1;
  if (_.step) {
    step = _.step;
  } else if (_.steps) {
    v = span2 / maxb;
    for (i = 0, n = _.steps.length; i < n && _.steps[i] < v; ++i)
      ;
    step = _.steps[Math.max(0, i - 1)];
  } else {
    level = Math.ceil(Math.log(maxb) / logb);
    minstep = _.minstep || 0;
    step = Math.max(minstep, Math.pow(base2, Math.round(Math.log(span2) / logb) - level));
    while (Math.ceil(span2 / step) > maxb) {
      step *= base2;
    }
    for (i = 0, n = div.length; i < n; ++i) {
      v = step / div[i];
      if (v >= minstep && span2 / v <= maxb)
        step = v;
    }
  }
  v = Math.log(step);
  const precision = v >= 0 ? 0 : ~~(-v / logb) + 1, eps = Math.pow(base2, -precision - 1);
  if (_.nice || _.nice === void 0) {
    v = Math.floor(min4 / step + eps) * step;
    min4 = min4 < v ? v - step : v;
    max4 = Math.ceil(max4 / step) * step;
  }
  return {
    start: min4,
    stop: max4 === min4 ? min4 + step : max4,
    step
  };
}
var random = Math.random;
function setRandom(r) {
  random = r;
}
function bootstrapCI(array4, samples, alpha, f) {
  if (!array4.length)
    return [void 0, void 0];
  const values2 = Float64Array.from(numbers(array4, f)), n = values2.length, m = samples;
  let a, i, j, mu;
  for (j = 0, mu = Array(m); j < m; ++j) {
    for (a = 0, i = 0; i < n; ++i) {
      a += values2[~~(random() * n)];
    }
    mu[j] = a / n;
  }
  mu.sort(ascending);
  return [quantile(mu, alpha / 2), quantile(mu, 1 - alpha / 2)];
}
function dotbin(array4, step, smooth, f) {
  f = f || ((_) => _);
  const n = array4.length, v = new Float64Array(n);
  let i = 0, j = 1, a = f(array4[0]), b2 = a, w3 = a + step, x2;
  for (; j < n; ++j) {
    x2 = f(array4[j]);
    if (x2 >= w3) {
      b2 = (a + b2) / 2;
      for (; i < j; ++i)
        v[i] = b2;
      w3 = x2 + step;
      a = x2;
    }
    b2 = x2;
  }
  b2 = (a + b2) / 2;
  for (; i < j; ++i)
    v[i] = b2;
  return smooth ? smoothing(v, step + step / 4) : v;
}
function smoothing(v, thresh) {
  const n = v.length;
  let a = 0, b2 = 1, c, d;
  while (v[a] === v[b2])
    ++b2;
  while (b2 < n) {
    c = b2 + 1;
    while (v[b2] === v[c])
      ++c;
    if (v[b2] - v[b2 - 1] < thresh) {
      d = b2 + (a + c - b2 - b2 >> 1);
      while (d < b2)
        v[d++] = v[b2];
      while (d > b2)
        v[d--] = v[a];
    }
    a = b2;
    b2 = c;
  }
  return v;
}
function lcg(seed) {
  return function() {
    seed = (1103515245 * seed + 12345) % 2147483647;
    return seed / 2147483647;
  };
}
function integer(min4, max4) {
  if (max4 == null) {
    max4 = min4;
    min4 = 0;
  }
  let a, b2, d;
  const dist = {
    min(_) {
      if (arguments.length) {
        a = _ || 0;
        d = b2 - a;
        return dist;
      } else {
        return a;
      }
    },
    max(_) {
      if (arguments.length) {
        b2 = _ || 0;
        d = b2 - a;
        return dist;
      } else {
        return b2;
      }
    },
    sample() {
      return a + Math.floor(d * random());
    },
    pdf(x2) {
      return x2 === Math.floor(x2) && x2 >= a && x2 < b2 ? 1 / d : 0;
    },
    cdf(x2) {
      const v = Math.floor(x2);
      return v < a ? 0 : v >= b2 ? 1 : (v - a + 1) / d;
    },
    icdf(p) {
      return p >= 0 && p <= 1 ? a - 1 + Math.floor(p * d) : NaN;
    }
  };
  return dist.min(min4).max(max4);
}
var SQRT2PI = Math.sqrt(2 * Math.PI);
var SQRT2 = Math.SQRT2;
var nextSample = NaN;
function sampleNormal(mean2, stdev) {
  mean2 = mean2 || 0;
  stdev = stdev == null ? 1 : stdev;
  let x2 = 0, y2 = 0, rds, c;
  if (nextSample === nextSample) {
    x2 = nextSample;
    nextSample = NaN;
  } else {
    do {
      x2 = random() * 2 - 1;
      y2 = random() * 2 - 1;
      rds = x2 * x2 + y2 * y2;
    } while (rds === 0 || rds > 1);
    c = Math.sqrt(-2 * Math.log(rds) / rds);
    x2 *= c;
    nextSample = y2 * c;
  }
  return mean2 + x2 * stdev;
}
function densityNormal(value3, mean2, stdev) {
  stdev = stdev == null ? 1 : stdev;
  const z = (value3 - (mean2 || 0)) / stdev;
  return Math.exp(-0.5 * z * z) / (stdev * SQRT2PI);
}
function cumulativeNormal(value3, mean2, stdev) {
  mean2 = mean2 || 0;
  stdev = stdev == null ? 1 : stdev;
  const z = (value3 - mean2) / stdev, Z = Math.abs(z);
  let cd;
  if (Z > 37) {
    cd = 0;
  } else {
    const exp4 = Math.exp(-Z * Z / 2);
    let sum2;
    if (Z < 7.07106781186547) {
      sum2 = 0.0352624965998911 * Z + 0.700383064443688;
      sum2 = sum2 * Z + 6.37396220353165;
      sum2 = sum2 * Z + 33.912866078383;
      sum2 = sum2 * Z + 112.079291497871;
      sum2 = sum2 * Z + 221.213596169931;
      sum2 = sum2 * Z + 220.206867912376;
      cd = exp4 * sum2;
      sum2 = 0.0883883476483184 * Z + 1.75566716318264;
      sum2 = sum2 * Z + 16.064177579207;
      sum2 = sum2 * Z + 86.7807322029461;
      sum2 = sum2 * Z + 296.564248779674;
      sum2 = sum2 * Z + 637.333633378831;
      sum2 = sum2 * Z + 793.826512519948;
      sum2 = sum2 * Z + 440.413735824752;
      cd = cd / sum2;
    } else {
      sum2 = Z + 0.65;
      sum2 = Z + 4 / sum2;
      sum2 = Z + 3 / sum2;
      sum2 = Z + 2 / sum2;
      sum2 = Z + 1 / sum2;
      cd = exp4 / sum2 / 2.506628274631;
    }
  }
  return z > 0 ? 1 - cd : cd;
}
function quantileNormal(p, mean2, stdev) {
  if (p < 0 || p > 1)
    return NaN;
  return (mean2 || 0) + (stdev == null ? 1 : stdev) * SQRT2 * erfinv(2 * p - 1);
}
function erfinv(x2) {
  let w3 = -Math.log((1 - x2) * (1 + x2)), p;
  if (w3 < 6.25) {
    w3 -= 3.125;
    p = -364441206401782e-35;
    p = -16850591381820166e-35 + p * w3;
    p = 128584807152564e-32 + p * w3;
    p = 11157877678025181e-33 + p * w3;
    p = -1333171662854621e-31 + p * w3;
    p = 20972767875968562e-33 + p * w3;
    p = 6637638134358324e-30 + p * w3;
    p = -4054566272975207e-29 + p * w3;
    p = -8151934197605472e-29 + p * w3;
    p = 26335093153082323e-28 + p * w3;
    p = -12975133253453532e-27 + p * w3;
    p = -5415412054294628e-26 + p * w3;
    p = 10512122733215323e-25 + p * w3;
    p = -4112633980346984e-24 + p * w3;
    p = -29070369957882005e-24 + p * w3;
    p = 42347877827932404e-23 + p * w3;
    p = -13654692000834679e-22 + p * w3;
    p = -13882523362786469e-21 + p * w3;
    p = 18673420803405714e-20 + p * w3;
    p = -740702534166267e-18 + p * w3;
    p = -0.006033670871430149 + p * w3;
    p = 0.24015818242558962 + p * w3;
    p = 1.6536545626831027 + p * w3;
  } else if (w3 < 16) {
    w3 = Math.sqrt(w3) - 3.25;
    p = 22137376921775787e-25;
    p = 9075656193888539e-23 + p * w3;
    p = -27517406297064545e-23 + p * w3;
    p = 18239629214389228e-24 + p * w3;
    p = 15027403968909828e-22 + p * w3;
    p = -4013867526981546e-21 + p * w3;
    p = 29234449089955446e-22 + p * w3;
    p = 12475304481671779e-21 + p * w3;
    p = -47318229009055734e-21 + p * w3;
    p = 6828485145957318e-20 + p * w3;
    p = 24031110387097894e-21 + p * w3;
    p = -3550375203628475e-19 + p * w3;
    p = 9532893797373805e-19 + p * w3;
    p = -0.0016882755560235047 + p * w3;
    p = 0.002491442096107851 + p * w3;
    p = -0.003751208507569241 + p * w3;
    p = 0.005370914553590064 + p * w3;
    p = 1.0052589676941592 + p * w3;
    p = 3.0838856104922208 + p * w3;
  } else if (Number.isFinite(w3)) {
    w3 = Math.sqrt(w3) - 5;
    p = -27109920616438573e-27;
    p = -2555641816996525e-25 + p * w3;
    p = 15076572693500548e-25 + p * w3;
    p = -3789465440126737e-24 + p * w3;
    p = 761570120807834e-23 + p * w3;
    p = -1496002662714924e-23 + p * w3;
    p = 2914795345090108e-23 + p * w3;
    p = -6771199775845234e-23 + p * w3;
    p = 22900482228026655e-23 + p * w3;
    p = -99298272942317e-20 + p * w3;
    p = 4526062597223154e-21 + p * w3;
    p = -1968177810553167e-20 + p * w3;
    p = 7599527703001776e-20 + p * w3;
    p = -21503011930044477e-20 + p * w3;
    p = -13871931833623122e-20 + p * w3;
    p = 1.0103004648645344 + p * w3;
    p = 4.849906401408584 + p * w3;
  } else {
    p = Infinity;
  }
  return p * x2;
}
function gaussian(mean2, stdev) {
  let mu, sigma;
  const dist = {
    mean(_) {
      if (arguments.length) {
        mu = _ || 0;
        return dist;
      } else {
        return mu;
      }
    },
    stdev(_) {
      if (arguments.length) {
        sigma = _ == null ? 1 : _;
        return dist;
      } else {
        return sigma;
      }
    },
    sample: () => sampleNormal(mu, sigma),
    pdf: (value3) => densityNormal(value3, mu, sigma),
    cdf: (value3) => cumulativeNormal(value3, mu, sigma),
    icdf: (p) => quantileNormal(p, mu, sigma)
  };
  return dist.mean(mean2).stdev(stdev);
}
function kde(support, bandwidth2) {
  const kernel = gaussian();
  let n = 0;
  const dist = {
    data(_) {
      if (arguments.length) {
        support = _;
        n = _ ? _.length : 0;
        return dist.bandwidth(bandwidth2);
      } else {
        return support;
      }
    },
    bandwidth(_) {
      if (!arguments.length)
        return bandwidth2;
      bandwidth2 = _;
      if (!bandwidth2 && support)
        bandwidth2 = estimateBandwidth(support);
      return dist;
    },
    sample() {
      return support[~~(random() * n)] + bandwidth2 * kernel.sample();
    },
    pdf(x2) {
      let y2 = 0, i = 0;
      for (; i < n; ++i) {
        y2 += kernel.pdf((x2 - support[i]) / bandwidth2);
      }
      return y2 / bandwidth2 / n;
    },
    cdf(x2) {
      let y2 = 0, i = 0;
      for (; i < n; ++i) {
        y2 += kernel.cdf((x2 - support[i]) / bandwidth2);
      }
      return y2 / n;
    },
    icdf() {
      throw Error("KDE icdf not supported.");
    }
  };
  return dist.data(support);
}
function sampleLogNormal(mean2, stdev) {
  mean2 = mean2 || 0;
  stdev = stdev == null ? 1 : stdev;
  return Math.exp(mean2 + sampleNormal() * stdev);
}
function densityLogNormal(value3, mean2, stdev) {
  if (value3 <= 0)
    return 0;
  mean2 = mean2 || 0;
  stdev = stdev == null ? 1 : stdev;
  const z = (Math.log(value3) - mean2) / stdev;
  return Math.exp(-0.5 * z * z) / (stdev * SQRT2PI * value3);
}
function cumulativeLogNormal(value3, mean2, stdev) {
  return cumulativeNormal(Math.log(value3), mean2, stdev);
}
function quantileLogNormal(p, mean2, stdev) {
  return Math.exp(quantileNormal(p, mean2, stdev));
}
function lognormal(mean2, stdev) {
  let mu, sigma;
  const dist = {
    mean(_) {
      if (arguments.length) {
        mu = _ || 0;
        return dist;
      } else {
        return mu;
      }
    },
    stdev(_) {
      if (arguments.length) {
        sigma = _ == null ? 1 : _;
        return dist;
      } else {
        return sigma;
      }
    },
    sample: () => sampleLogNormal(mu, sigma),
    pdf: (value3) => densityLogNormal(value3, mu, sigma),
    cdf: (value3) => cumulativeLogNormal(value3, mu, sigma),
    icdf: (p) => quantileLogNormal(p, mu, sigma)
  };
  return dist.mean(mean2).stdev(stdev);
}
function mixture(dists, weights) {
  let m = 0, w3;
  function normalize(x2) {
    const w4 = [];
    let sum2 = 0, i;
    for (i = 0; i < m; ++i) {
      sum2 += w4[i] = x2[i] == null ? 1 : +x2[i];
    }
    for (i = 0; i < m; ++i) {
      w4[i] /= sum2;
    }
    return w4;
  }
  const dist = {
    weights(_) {
      if (arguments.length) {
        w3 = normalize(weights = _ || []);
        return dist;
      }
      return weights;
    },
    distributions(_) {
      if (arguments.length) {
        if (_) {
          m = _.length;
          dists = _;
        } else {
          m = 0;
          dists = [];
        }
        return dist.weights(weights);
      }
      return dists;
    },
    sample() {
      const r = random();
      let d = dists[m - 1], v = w3[0], i = 0;
      for (; i < m - 1; v += w3[++i]) {
        if (r < v) {
          d = dists[i];
          break;
        }
      }
      return d.sample();
    },
    pdf(x2) {
      let p = 0, i = 0;
      for (; i < m; ++i) {
        p += w3[i] * dists[i].pdf(x2);
      }
      return p;
    },
    cdf(x2) {
      let p = 0, i = 0;
      for (; i < m; ++i) {
        p += w3[i] * dists[i].cdf(x2);
      }
      return p;
    },
    icdf() {
      throw Error("Mixture icdf not supported.");
    }
  };
  return dist.distributions(dists).weights(weights);
}
function sampleUniform(min4, max4) {
  if (max4 == null) {
    max4 = min4 == null ? 1 : min4;
    min4 = 0;
  }
  return min4 + (max4 - min4) * random();
}
function densityUniform(value3, min4, max4) {
  if (max4 == null) {
    max4 = min4 == null ? 1 : min4;
    min4 = 0;
  }
  return value3 >= min4 && value3 <= max4 ? 1 / (max4 - min4) : 0;
}
function cumulativeUniform(value3, min4, max4) {
  if (max4 == null) {
    max4 = min4 == null ? 1 : min4;
    min4 = 0;
  }
  return value3 < min4 ? 0 : value3 > max4 ? 1 : (value3 - min4) / (max4 - min4);
}
function quantileUniform(p, min4, max4) {
  if (max4 == null) {
    max4 = min4 == null ? 1 : min4;
    min4 = 0;
  }
  return p >= 0 && p <= 1 ? min4 + p * (max4 - min4) : NaN;
}
function uniform(min4, max4) {
  let a, b2;
  const dist = {
    min(_) {
      if (arguments.length) {
        a = _ || 0;
        return dist;
      } else {
        return a;
      }
    },
    max(_) {
      if (arguments.length) {
        b2 = _ == null ? 1 : _;
        return dist;
      } else {
        return b2;
      }
    },
    sample: () => sampleUniform(a, b2),
    pdf: (value3) => densityUniform(value3, a, b2),
    cdf: (value3) => cumulativeUniform(value3, a, b2),
    icdf: (p) => quantileUniform(p, a, b2)
  };
  if (max4 == null) {
    max4 = min4 == null ? 1 : min4;
    min4 = 0;
  }
  return dist.min(min4).max(max4);
}
function constant2(data3, x2, y2) {
  let mean2 = 0, n = 0;
  for (const d of data3) {
    const val = y2(d);
    if (x2(d) == null || val == null || isNaN(val))
      continue;
    mean2 += (val - mean2) / ++n;
  }
  return {
    coef: [mean2],
    predict: () => mean2,
    rSquared: 0
  };
}
function ols(uX, uY, uXY, uX2) {
  const delta = uX2 - uX * uX, slope = Math.abs(delta) < 1e-24 ? 0 : (uXY - uX * uY) / delta, intercept = uY - slope * uX;
  return [intercept, slope];
}
function points(data3, x2, y2, sort2) {
  data3 = data3.filter((d2) => {
    let u = x2(d2), v = y2(d2);
    return u != null && (u = +u) >= u && v != null && (v = +v) >= v;
  });
  if (sort2) {
    data3.sort((a, b2) => x2(a) - x2(b2));
  }
  const n = data3.length, X2 = new Float64Array(n), Y2 = new Float64Array(n);
  let i = 0, ux = 0, uy = 0, xv, yv, d;
  for (d of data3) {
    X2[i] = xv = +x2(d);
    Y2[i] = yv = +y2(d);
    ++i;
    ux += (xv - ux) / i;
    uy += (yv - uy) / i;
  }
  for (i = 0; i < n; ++i) {
    X2[i] -= ux;
    Y2[i] -= uy;
  }
  return [X2, Y2, ux, uy];
}
function visitPoints(data3, x2, y2, callback) {
  let i = -1, u, v;
  for (const d of data3) {
    u = x2(d);
    v = y2(d);
    if (u != null && (u = +u) >= u && v != null && (v = +v) >= v) {
      callback(u, v, ++i);
    }
  }
}
function rSquared(data3, x2, y2, uY, predict) {
  let SSE = 0, SST = 0;
  visitPoints(data3, x2, y2, (dx, dy) => {
    const sse = dy - predict(dx), sst = dy - uY;
    SSE += sse * sse;
    SST += sst * sst;
  });
  return 1 - SSE / SST;
}
function linear2(data3, x2, y2) {
  let X2 = 0, Y2 = 0, XY = 0, X22 = 0, n = 0;
  visitPoints(data3, x2, y2, (dx, dy) => {
    ++n;
    X2 += (dx - X2) / n;
    Y2 += (dy - Y2) / n;
    XY += (dx * dy - XY) / n;
    X22 += (dx * dx - X22) / n;
  });
  const coef = ols(X2, Y2, XY, X22), predict = (x3) => coef[0] + coef[1] * x3;
  return {
    coef,
    predict,
    rSquared: rSquared(data3, x2, y2, Y2, predict)
  };
}
function log3(data3, x2, y2) {
  let X2 = 0, Y2 = 0, XY = 0, X22 = 0, n = 0;
  visitPoints(data3, x2, y2, (dx, dy) => {
    ++n;
    dx = Math.log(dx);
    X2 += (dx - X2) / n;
    Y2 += (dy - Y2) / n;
    XY += (dx * dy - XY) / n;
    X22 += (dx * dx - X22) / n;
  });
  const coef = ols(X2, Y2, XY, X22), predict = (x3) => coef[0] + coef[1] * Math.log(x3);
  return {
    coef,
    predict,
    rSquared: rSquared(data3, x2, y2, Y2, predict)
  };
}
function exp2(data3, x2, y2) {
  const [xv, yv, ux, uy] = points(data3, x2, y2);
  let YL = 0, XY = 0, XYL = 0, X2Y = 0, n = 0, dx, ly2, xy;
  visitPoints(data3, x2, y2, (_, dy) => {
    dx = xv[n++];
    ly2 = Math.log(dy);
    xy = dx * dy;
    YL += (dy * ly2 - YL) / n;
    XY += (xy - XY) / n;
    XYL += (xy * ly2 - XYL) / n;
    X2Y += (dx * xy - X2Y) / n;
  });
  const [c0, c1] = ols(XY / uy, YL / uy, XYL / uy, X2Y / uy), predict = (x3) => Math.exp(c0 + c1 * (x3 - ux));
  return {
    coef: [Math.exp(c0 - c1 * ux), c1],
    predict,
    rSquared: rSquared(data3, x2, y2, uy, predict)
  };
}
function pow3(data3, x2, y2) {
  let X2 = 0, Y2 = 0, XY = 0, X22 = 0, YS = 0, n = 0;
  visitPoints(data3, x2, y2, (dx, dy) => {
    const lx2 = Math.log(dx), ly2 = Math.log(dy);
    ++n;
    X2 += (lx2 - X2) / n;
    Y2 += (ly2 - Y2) / n;
    XY += (lx2 * ly2 - XY) / n;
    X22 += (lx2 * lx2 - X22) / n;
    YS += (dy - YS) / n;
  });
  const coef = ols(X2, Y2, XY, X22), predict = (x3) => coef[0] * Math.pow(x3, coef[1]);
  coef[0] = Math.exp(coef[0]);
  return {
    coef,
    predict,
    rSquared: rSquared(data3, x2, y2, YS, predict)
  };
}
function quad(data3, x2, y2) {
  const [xv, yv, ux, uy] = points(data3, x2, y2), n = xv.length;
  let X2 = 0, X3 = 0, X4 = 0, XY = 0, X2Y = 0, i, dx, dy, x22;
  for (i = 0; i < n; ) {
    dx = xv[i];
    dy = yv[i++];
    x22 = dx * dx;
    X2 += (x22 - X2) / i;
    X3 += (x22 * dx - X3) / i;
    X4 += (x22 * x22 - X4) / i;
    XY += (dx * dy - XY) / i;
    X2Y += (x22 * dy - X2Y) / i;
  }
  const X2X2 = X4 - X2 * X2, d = X2 * X2X2 - X3 * X3, a = (X2Y * X2 - XY * X3) / d, b2 = (XY * X2X2 - X2Y * X3) / d, c = -a * X2, predict = (x3) => {
    x3 = x3 - ux;
    return a * x3 * x3 + b2 * x3 + c + uy;
  };
  return {
    coef: [c - b2 * ux + a * ux * ux + uy, b2 - 2 * a * ux, a],
    predict,
    rSquared: rSquared(data3, x2, y2, uy, predict)
  };
}
function poly(data3, x2, y2, order) {
  if (order === 0)
    return constant2(data3, x2, y2);
  if (order === 1)
    return linear2(data3, x2, y2);
  if (order === 2)
    return quad(data3, x2, y2);
  const [xv, yv, ux, uy] = points(data3, x2, y2), n = xv.length, lhs = [], rhs = [], k2 = order + 1;
  let i, j, l, v, c;
  for (i = 0; i < k2; ++i) {
    for (l = 0, v = 0; l < n; ++l) {
      v += Math.pow(xv[l], i) * yv[l];
    }
    lhs.push(v);
    c = new Float64Array(k2);
    for (j = 0; j < k2; ++j) {
      for (l = 0, v = 0; l < n; ++l) {
        v += Math.pow(xv[l], i + j);
      }
      c[j] = v;
    }
    rhs.push(c);
  }
  rhs.push(lhs);
  const coef = gaussianElimination(rhs), predict = (x3) => {
    x3 -= ux;
    let y3 = uy + coef[0] + coef[1] * x3 + coef[2] * x3 * x3;
    for (i = 3; i < k2; ++i)
      y3 += coef[i] * Math.pow(x3, i);
    return y3;
  };
  return {
    coef: uncenter(k2, coef, -ux, uy),
    predict,
    rSquared: rSquared(data3, x2, y2, uy, predict)
  };
}
function uncenter(k2, a, x2, y2) {
  const z = Array(k2);
  let i, j, v, c;
  for (i = 0; i < k2; ++i)
    z[i] = 0;
  for (i = k2 - 1; i >= 0; --i) {
    v = a[i];
    c = 1;
    z[i] += v;
    for (j = 1; j <= i; ++j) {
      c *= (i + 1 - j) / j;
      z[i - j] += v * Math.pow(x2, j) * c;
    }
  }
  z[0] += y2;
  return z;
}
function gaussianElimination(matrix) {
  const n = matrix.length - 1, coef = [];
  let i, j, k2, r, t;
  for (i = 0; i < n; ++i) {
    r = i;
    for (j = i + 1; j < n; ++j) {
      if (Math.abs(matrix[i][j]) > Math.abs(matrix[i][r])) {
        r = j;
      }
    }
    for (k2 = i; k2 < n + 1; ++k2) {
      t = matrix[k2][i];
      matrix[k2][i] = matrix[k2][r];
      matrix[k2][r] = t;
    }
    for (j = i + 1; j < n; ++j) {
      for (k2 = n; k2 >= i; k2--) {
        matrix[k2][j] -= matrix[k2][i] * matrix[i][j] / matrix[i][i];
      }
    }
  }
  for (j = n - 1; j >= 0; --j) {
    t = 0;
    for (k2 = j + 1; k2 < n; ++k2) {
      t += matrix[k2][j] * coef[k2];
    }
    coef[j] = (matrix[n][j] - t) / matrix[j][j];
  }
  return coef;
}
var maxiters = 2;
var epsilon = 1e-12;
function loess(data3, x2, y2, bandwidth2) {
  const [xv, yv, ux, uy] = points(data3, x2, y2, true), n = xv.length, bw = Math.max(2, ~~(bandwidth2 * n)), yhat = new Float64Array(n), residuals = new Float64Array(n), robustWeights = new Float64Array(n).fill(1);
  for (let iter = -1; ++iter <= maxiters; ) {
    const interval = [0, bw - 1];
    for (let i = 0; i < n; ++i) {
      const dx = xv[i], i0 = interval[0], i1 = interval[1], edge = dx - xv[i0] > xv[i1] - dx ? i0 : i1;
      let W = 0, X2 = 0, Y2 = 0, XY = 0, X22 = 0;
      const denom = 1 / Math.abs(xv[edge] - dx || 1);
      for (let k2 = i0; k2 <= i1; ++k2) {
        const xk = xv[k2], yk = yv[k2], w3 = tricube(Math.abs(dx - xk) * denom) * robustWeights[k2], xkw = xk * w3;
        W += w3;
        X2 += xkw;
        Y2 += yk * w3;
        XY += yk * xkw;
        X22 += xk * xkw;
      }
      const [a, b2] = ols(X2 / W, Y2 / W, XY / W, X22 / W);
      yhat[i] = a + b2 * dx;
      residuals[i] = Math.abs(yv[i] - yhat[i]);
      updateInterval(xv, i + 1, interval);
    }
    if (iter === maxiters) {
      break;
    }
    const medianResidual = median(residuals);
    if (Math.abs(medianResidual) < epsilon)
      break;
    for (let i = 0, arg, w3; i < n; ++i) {
      arg = residuals[i] / (6 * medianResidual);
      robustWeights[i] = arg >= 1 ? epsilon : (w3 = 1 - arg * arg) * w3;
    }
  }
  return output(xv, yhat, ux, uy);
}
function tricube(x2) {
  return (x2 = 1 - x2 * x2 * x2) * x2 * x2;
}
function updateInterval(xv, i, interval) {
  const val = xv[i];
  let left = interval[0], right = interval[1] + 1;
  if (right >= xv.length)
    return;
  while (i > left && xv[right] - val <= val - xv[left]) {
    interval[0] = ++left;
    interval[1] = right;
    ++right;
  }
}
function output(xv, yhat, ux, uy) {
  const n = xv.length, out = [];
  let i = 0, cnt = 0, prev = [], v;
  for (; i < n; ++i) {
    v = xv[i] + ux;
    if (prev[0] === v) {
      prev[1] += (yhat[i] - prev[1]) / ++cnt;
    } else {
      cnt = 0;
      prev[1] += uy;
      prev = [v, yhat[i]];
      out.push(prev);
    }
  }
  prev[1] += uy;
  return out;
}
var MIN_RADIANS = 0.5 * Math.PI / 180;
function sampleCurve(f, extent2, minSteps, maxSteps) {
  minSteps = minSteps || 25;
  maxSteps = Math.max(minSteps, maxSteps || 200);
  const point3 = (x2) => [x2, f(x2)], minX = extent2[0], maxX = extent2[1], span2 = maxX - minX, stop2 = span2 / maxSteps, prev = [point3(minX)], next = [];
  if (minSteps === maxSteps) {
    for (let i = 1; i < maxSteps; ++i) {
      prev.push(point3(minX + i / minSteps * span2));
    }
    prev.push(point3(maxX));
    return prev;
  } else {
    next.push(point3(maxX));
    for (let i = minSteps; --i > 0; ) {
      next.push(point3(minX + i / minSteps * span2));
    }
  }
  let p0 = prev[0];
  let p1 = next[next.length - 1];
  const sx = 1 / span2;
  const sy = scaleY(p0[1], next);
  while (p1) {
    const pm = point3((p0[0] + p1[0]) / 2);
    const dx = pm[0] - p0[0] >= stop2;
    if (dx && angleDelta(p0, pm, p1, sx, sy) > MIN_RADIANS) {
      next.push(pm);
    } else {
      p0 = p1;
      prev.push(p1);
      next.pop();
    }
    p1 = next[next.length - 1];
  }
  return prev;
}
function scaleY(init2, points2) {
  let ymin = init2;
  let ymax = init2;
  const n = points2.length;
  for (let i = 0; i < n; ++i) {
    const y2 = points2[i][1];
    if (y2 < ymin)
      ymin = y2;
    if (y2 > ymax)
      ymax = y2;
  }
  return 1 / (ymax - ymin);
}
function angleDelta(p, q, r, sx, sy) {
  const a0 = Math.atan2(sy * (r[1] - p[1]), sx * (r[0] - p[0])), a1 = Math.atan2(sy * (q[1] - p[1]), sx * (q[0] - p[0]));
  return Math.abs(a0 - a1);
}

// node_modules/vega-transforms/build/vega-transforms.module.js
function multikey(f) {
  return (x2) => {
    const n = f.length;
    let i = 1, k2 = String(f[0](x2));
    for (; i < n; ++i) {
      k2 += "|" + f[i](x2);
    }
    return k2;
  };
}
function groupkey(fields) {
  return !fields || !fields.length ? function() {
    return "";
  } : fields.length === 1 ? fields[0] : multikey(fields);
}
function measureName(op, field3, as) {
  return as || op + (!field3 ? "" : "_" + field3);
}
var noop = () => {
};
var base_op = {
  init: noop,
  add: noop,
  rem: noop,
  idx: 0
};
var AggregateOps = {
  values: {
    init: (m) => m.cell.store = true,
    value: (m) => m.cell.data.values(),
    idx: -1
  },
  count: {
    value: (m) => m.cell.num
  },
  __count__: {
    value: (m) => m.missing + m.valid
  },
  missing: {
    value: (m) => m.missing
  },
  valid: {
    value: (m) => m.valid
  },
  sum: {
    init: (m) => m.sum = 0,
    value: (m) => m.valid ? m.sum : void 0,
    add: (m, v) => m.sum += +v,
    rem: (m, v) => m.sum -= v
  },
  product: {
    init: (m) => m.product = 1,
    value: (m) => m.valid ? m.product : void 0,
    add: (m, v) => m.product *= v,
    rem: (m, v) => m.product /= v
  },
  mean: {
    init: (m) => m.mean = 0,
    value: (m) => m.valid ? m.mean : void 0,
    add: (m, v) => (m.mean_d = v - m.mean, m.mean += m.mean_d / m.valid),
    rem: (m, v) => (m.mean_d = v - m.mean, m.mean -= m.valid ? m.mean_d / m.valid : m.mean)
  },
  average: {
    value: (m) => m.valid ? m.mean : void 0,
    req: ["mean"],
    idx: 1
  },
  variance: {
    init: (m) => m.dev = 0,
    value: (m) => m.valid > 1 ? m.dev / (m.valid - 1) : void 0,
    add: (m, v) => m.dev += m.mean_d * (v - m.mean),
    rem: (m, v) => m.dev -= m.mean_d * (v - m.mean),
    req: ["mean"],
    idx: 1
  },
  variancep: {
    value: (m) => m.valid > 1 ? m.dev / m.valid : void 0,
    req: ["variance"],
    idx: 2
  },
  stdev: {
    value: (m) => m.valid > 1 ? Math.sqrt(m.dev / (m.valid - 1)) : void 0,
    req: ["variance"],
    idx: 2
  },
  stdevp: {
    value: (m) => m.valid > 1 ? Math.sqrt(m.dev / m.valid) : void 0,
    req: ["variance"],
    idx: 2
  },
  stderr: {
    value: (m) => m.valid > 1 ? Math.sqrt(m.dev / (m.valid * (m.valid - 1))) : void 0,
    req: ["variance"],
    idx: 2
  },
  distinct: {
    value: (m) => m.cell.data.distinct(m.get),
    req: ["values"],
    idx: 3
  },
  ci0: {
    value: (m) => m.cell.data.ci0(m.get),
    req: ["values"],
    idx: 3
  },
  ci1: {
    value: (m) => m.cell.data.ci1(m.get),
    req: ["values"],
    idx: 3
  },
  median: {
    value: (m) => m.cell.data.q2(m.get),
    req: ["values"],
    idx: 3
  },
  q1: {
    value: (m) => m.cell.data.q1(m.get),
    req: ["values"],
    idx: 3
  },
  q3: {
    value: (m) => m.cell.data.q3(m.get),
    req: ["values"],
    idx: 3
  },
  min: {
    init: (m) => m.min = void 0,
    value: (m) => m.min = Number.isNaN(m.min) ? m.cell.data.min(m.get) : m.min,
    add: (m, v) => {
      if (v < m.min || m.min === void 0)
        m.min = v;
    },
    rem: (m, v) => {
      if (v <= m.min)
        m.min = NaN;
    },
    req: ["values"],
    idx: 4
  },
  max: {
    init: (m) => m.max = void 0,
    value: (m) => m.max = Number.isNaN(m.max) ? m.cell.data.max(m.get) : m.max,
    add: (m, v) => {
      if (v > m.max || m.max === void 0)
        m.max = v;
    },
    rem: (m, v) => {
      if (v >= m.max)
        m.max = NaN;
    },
    req: ["values"],
    idx: 4
  },
  argmin: {
    init: (m) => m.argmin = void 0,
    value: (m) => m.argmin || m.cell.data.argmin(m.get),
    add: (m, v, t) => {
      if (v < m.min)
        m.argmin = t;
    },
    rem: (m, v) => {
      if (v <= m.min)
        m.argmin = void 0;
    },
    req: ["min", "values"],
    idx: 3
  },
  argmax: {
    init: (m) => m.argmax = void 0,
    value: (m) => m.argmax || m.cell.data.argmax(m.get),
    add: (m, v, t) => {
      if (v > m.max)
        m.argmax = t;
    },
    rem: (m, v) => {
      if (v >= m.max)
        m.argmax = void 0;
    },
    req: ["max", "values"],
    idx: 3
  },
  exponential: {
    init: (m, r) => {
      m.exp = 0;
      m.exp_r = r;
    },
    value: (m) => m.valid ? m.exp * (1 - m.exp_r) / (1 - m.exp_r ** m.valid) : void 0,
    add: (m, v) => m.exp = m.exp_r * m.exp + v,
    rem: (m, v) => m.exp = (m.exp - v / m.exp_r ** (m.valid - 1)) / m.exp_r
  },
  exponentialb: {
    value: (m) => m.valid ? m.exp * (1 - m.exp_r) : void 0,
    req: ["exponential"],
    idx: 1
  }
};
var ValidAggregateOps = Object.keys(AggregateOps).filter((d) => d !== "__count__");
function measure(key2, value3) {
  return (out, aggregate_param) => extend({
    name: key2,
    aggregate_param,
    out: out || key2
  }, base_op, value3);
}
[...ValidAggregateOps, "__count__"].forEach((key2) => {
  AggregateOps[key2] = measure(key2, AggregateOps[key2]);
});
function createMeasure(op, param2, name) {
  return AggregateOps[op](name, param2);
}
function compareIndex(a, b2) {
  return a.idx - b2.idx;
}
function resolve(agg) {
  const map2 = {};
  agg.forEach((a) => map2[a.name] = a);
  const getreqs = (a) => {
    if (!a.req)
      return;
    a.req.forEach((key2) => {
      if (!map2[key2])
        getreqs(map2[key2] = AggregateOps[key2]());
    });
  };
  agg.forEach(getreqs);
  return Object.values(map2).sort(compareIndex);
}
function init() {
  this.valid = 0;
  this.missing = 0;
  this._ops.forEach((op) => op.aggregate_param == null ? op.init(this) : op.init(this, op.aggregate_param));
}
function add2(v, t) {
  if (v == null || v === "") {
    ++this.missing;
    return;
  }
  if (v !== v)
    return;
  ++this.valid;
  this._ops.forEach((op) => op.add(this, v, t));
}
function rem(v, t) {
  if (v == null || v === "") {
    --this.missing;
    return;
  }
  if (v !== v)
    return;
  --this.valid;
  this._ops.forEach((op) => op.rem(this, v, t));
}
function set(t) {
  this._out.forEach((op) => t[op.out] = op.value(this));
  return t;
}
function compileMeasures(agg, field3) {
  const get5 = field3 || identity2, ops2 = resolve(agg), out = agg.slice().sort(compareIndex);
  function ctr(cell2) {
    this._ops = ops2;
    this._out = out;
    this.cell = cell2;
    this.init();
  }
  ctr.prototype.init = init;
  ctr.prototype.add = add2;
  ctr.prototype.rem = rem;
  ctr.prototype.set = set;
  ctr.prototype.get = get5;
  ctr.fields = agg.map((op) => op.out);
  return ctr;
}
function TupleStore(key2) {
  this._key = key2 ? field(key2) : tupleid;
  this.reset();
}
var prototype$1 = TupleStore.prototype;
prototype$1.reset = function() {
  this._add = [];
  this._rem = [];
  this._ext = null;
  this._get = null;
  this._q = null;
};
prototype$1.add = function(v) {
  this._add.push(v);
};
prototype$1.rem = function(v) {
  this._rem.push(v);
};
prototype$1.values = function() {
  this._get = null;
  if (this._rem.length === 0)
    return this._add;
  const a = this._add, r = this._rem, k2 = this._key, n = a.length, m = r.length, x2 = Array(n - m), map2 = {};
  let i, j, v;
  for (i = 0; i < m; ++i) {
    map2[k2(r[i])] = 1;
  }
  for (i = 0, j = 0; i < n; ++i) {
    if (map2[k2(v = a[i])]) {
      map2[k2(v)] = 0;
    } else {
      x2[j++] = v;
    }
  }
  this._rem = [];
  return this._add = x2;
};
prototype$1.distinct = function(get5) {
  const v = this.values(), map2 = {};
  let n = v.length, count = 0, s;
  while (--n >= 0) {
    s = get5(v[n]) + "";
    if (!has(map2, s)) {
      map2[s] = 1;
      ++count;
    }
  }
  return count;
};
prototype$1.extent = function(get5) {
  if (this._get !== get5 || !this._ext) {
    const v = this.values(), i = extentIndex(v, get5);
    this._ext = [v[i[0]], v[i[1]]];
    this._get = get5;
  }
  return this._ext;
};
prototype$1.argmin = function(get5) {
  return this.extent(get5)[0] || {};
};
prototype$1.argmax = function(get5) {
  return this.extent(get5)[1] || {};
};
prototype$1.min = function(get5) {
  const m = this.extent(get5)[0];
  return m != null ? get5(m) : void 0;
};
prototype$1.max = function(get5) {
  const m = this.extent(get5)[1];
  return m != null ? get5(m) : void 0;
};
prototype$1.quartile = function(get5) {
  if (this._get !== get5 || !this._q) {
    this._q = quartiles(this.values(), get5);
    this._get = get5;
  }
  return this._q;
};
prototype$1.q1 = function(get5) {
  return this.quartile(get5)[0];
};
prototype$1.q2 = function(get5) {
  return this.quartile(get5)[1];
};
prototype$1.q3 = function(get5) {
  return this.quartile(get5)[2];
};
prototype$1.ci = function(get5) {
  if (this._get !== get5 || !this._ci) {
    this._ci = bootstrapCI(this.values(), 1e3, 0.05, get5);
    this._get = get5;
  }
  return this._ci;
};
prototype$1.ci0 = function(get5) {
  return this.ci(get5)[0];
};
prototype$1.ci1 = function(get5) {
  return this.ci(get5)[1];
};
function Aggregate(params2) {
  Transform.call(this, null, params2);
  this._adds = [];
  this._mods = [];
  this._alen = 0;
  this._mlen = 0;
  this._drop = true;
  this._cross = false;
  this._dims = [];
  this._dnames = [];
  this._measures = [];
  this._countOnly = false;
  this._counts = null;
  this._prev = null;
  this._inputs = null;
  this._outputs = null;
}
Aggregate.Definition = {
  "type": "Aggregate",
  "metadata": {
    "generates": true,
    "changes": true
  },
  "params": [{
    "name": "groupby",
    "type": "field",
    "array": true
  }, {
    "name": "ops",
    "type": "enum",
    "array": true,
    "values": ValidAggregateOps
  }, {
    "name": "aggregate_params",
    "type": "number",
    "null": true,
    "array": true
  }, {
    "name": "fields",
    "type": "field",
    "null": true,
    "array": true
  }, {
    "name": "as",
    "type": "string",
    "null": true,
    "array": true
  }, {
    "name": "drop",
    "type": "boolean",
    "default": true
  }, {
    "name": "cross",
    "type": "boolean",
    "default": false
  }, {
    "name": "key",
    "type": "field"
  }]
};
inherits(Aggregate, Transform, {
  transform(_, pulse2) {
    const aggr = this, out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS), mod = _.modified();
    aggr.stamp = out.stamp;
    if (aggr.value && (mod || pulse2.modified(aggr._inputs, true))) {
      aggr._prev = aggr.value;
      aggr.value = mod ? aggr.init(_) : /* @__PURE__ */ Object.create(null);
      pulse2.visit(pulse2.SOURCE, (t) => aggr.add(t));
    } else {
      aggr.value = aggr.value || aggr.init(_);
      pulse2.visit(pulse2.REM, (t) => aggr.rem(t));
      pulse2.visit(pulse2.ADD, (t) => aggr.add(t));
    }
    out.modifies(aggr._outputs);
    aggr._drop = _.drop !== false;
    if (_.cross && aggr._dims.length > 1) {
      aggr._drop = false;
      aggr.cross();
    }
    if (pulse2.clean() && aggr._drop) {
      out.clean(true).runAfter(() => this.clean());
    }
    return aggr.changes(out);
  },
  cross() {
    const aggr = this, curr = aggr.value, dims = aggr._dnames, vals = dims.map(() => ({})), n = dims.length;
    function collect2(cells) {
      let key2, i, t, v;
      for (key2 in cells) {
        t = cells[key2].tuple;
        for (i = 0; i < n; ++i) {
          vals[i][v = t[dims[i]]] = v;
        }
      }
    }
    collect2(aggr._prev);
    collect2(curr);
    function generate2(base2, tuple, index2) {
      const name = dims[index2], v = vals[index2++];
      for (const k2 in v) {
        const key2 = base2 ? base2 + "|" + k2 : k2;
        tuple[name] = v[k2];
        if (index2 < n)
          generate2(key2, tuple, index2);
        else if (!curr[key2])
          aggr.cell(key2, tuple);
      }
    }
    generate2("", {}, 0);
  },
  init(_) {
    const inputs = this._inputs = [], outputs = this._outputs = [], inputMap = {};
    function inputVisit(get5) {
      const fields2 = array(accessorFields(get5)), n2 = fields2.length;
      let i2 = 0, f;
      for (; i2 < n2; ++i2) {
        if (!inputMap[f = fields2[i2]]) {
          inputMap[f] = 1;
          inputs.push(f);
        }
      }
    }
    this._dims = array(_.groupby);
    this._dnames = this._dims.map((d) => {
      const dname = accessorName(d);
      inputVisit(d);
      outputs.push(dname);
      return dname;
    });
    this.cellkey = _.key ? _.key : groupkey(this._dims);
    this._countOnly = true;
    this._counts = [];
    this._measures = [];
    const fields = _.fields || [null], ops2 = _.ops || ["count"], aggregate_params = _.aggregate_params || [null], as = _.as || [], n = fields.length, map2 = {};
    let field3, op, aggregate_param, m, mname, outname, i;
    if (n !== ops2.length) {
      error("Unmatched number of fields and aggregate ops.");
    }
    for (i = 0; i < n; ++i) {
      field3 = fields[i];
      op = ops2[i];
      aggregate_param = aggregate_params[i] || null;
      if (field3 == null && op !== "count") {
        error("Null aggregate field specified.");
      }
      mname = accessorName(field3);
      outname = measureName(op, mname, as[i]);
      outputs.push(outname);
      if (op === "count") {
        this._counts.push(outname);
        continue;
      }
      m = map2[mname];
      if (!m) {
        inputVisit(field3);
        m = map2[mname] = [];
        m.field = field3;
        this._measures.push(m);
      }
      if (op !== "count")
        this._countOnly = false;
      m.push(createMeasure(op, aggregate_param, outname));
    }
    this._measures = this._measures.map((m2) => compileMeasures(m2, m2.field));
    return /* @__PURE__ */ Object.create(null);
  },
  // -- Cell Management -----
  cellkey: groupkey(),
  cell(key2, t) {
    let cell2 = this.value[key2];
    if (!cell2) {
      cell2 = this.value[key2] = this.newcell(key2, t);
      this._adds[this._alen++] = cell2;
    } else if (cell2.num === 0 && this._drop && cell2.stamp < this.stamp) {
      cell2.stamp = this.stamp;
      this._adds[this._alen++] = cell2;
    } else if (cell2.stamp < this.stamp) {
      cell2.stamp = this.stamp;
      this._mods[this._mlen++] = cell2;
    }
    return cell2;
  },
  newcell(key2, t) {
    const cell2 = {
      key: key2,
      num: 0,
      agg: null,
      tuple: this.newtuple(t, this._prev && this._prev[key2]),
      stamp: this.stamp,
      store: false
    };
    if (!this._countOnly) {
      const measures = this._measures, n = measures.length;
      cell2.agg = Array(n);
      for (let i = 0; i < n; ++i) {
        cell2.agg[i] = new measures[i](cell2);
      }
    }
    if (cell2.store) {
      cell2.data = new TupleStore();
    }
    return cell2;
  },
  newtuple(t, p) {
    const names = this._dnames, dims = this._dims, n = dims.length, x2 = {};
    for (let i = 0; i < n; ++i) {
      x2[names[i]] = dims[i](t);
    }
    return p ? replace(p.tuple, x2) : ingest$1(x2);
  },
  clean() {
    const cells = this.value;
    for (const key2 in cells) {
      if (cells[key2].num === 0) {
        delete cells[key2];
      }
    }
  },
  // -- Process Tuples -----
  add(t) {
    const key2 = this.cellkey(t), cell2 = this.cell(key2, t);
    cell2.num += 1;
    if (this._countOnly)
      return;
    if (cell2.store)
      cell2.data.add(t);
    const agg = cell2.agg;
    for (let i = 0, n = agg.length; i < n; ++i) {
      agg[i].add(agg[i].get(t), t);
    }
  },
  rem(t) {
    const key2 = this.cellkey(t), cell2 = this.cell(key2, t);
    cell2.num -= 1;
    if (this._countOnly)
      return;
    if (cell2.store)
      cell2.data.rem(t);
    const agg = cell2.agg;
    for (let i = 0, n = agg.length; i < n; ++i) {
      agg[i].rem(agg[i].get(t), t);
    }
  },
  celltuple(cell2) {
    const tuple = cell2.tuple, counts = this._counts;
    if (cell2.store) {
      cell2.data.values();
    }
    for (let i = 0, n = counts.length; i < n; ++i) {
      tuple[counts[i]] = cell2.num;
    }
    if (!this._countOnly) {
      const agg = cell2.agg;
      for (let i = 0, n = agg.length; i < n; ++i) {
        agg[i].set(tuple);
      }
    }
    return tuple;
  },
  changes(out) {
    const adds = this._adds, mods = this._mods, prev = this._prev, drop = this._drop, add4 = out.add, rem2 = out.rem, mod = out.mod;
    let cell2, key2, i, n;
    if (prev)
      for (key2 in prev) {
        cell2 = prev[key2];
        if (!drop || cell2.num)
          rem2.push(cell2.tuple);
      }
    for (i = 0, n = this._alen; i < n; ++i) {
      add4.push(this.celltuple(adds[i]));
      adds[i] = null;
    }
    for (i = 0, n = this._mlen; i < n; ++i) {
      cell2 = mods[i];
      (cell2.num === 0 && drop ? rem2 : mod).push(this.celltuple(cell2));
      mods[i] = null;
    }
    this._alen = this._mlen = 0;
    this._prev = null;
    return out;
  }
});
var EPSILON$1 = 1e-14;
function Bin(params2) {
  Transform.call(this, null, params2);
}
Bin.Definition = {
  "type": "Bin",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "field",
    "type": "field",
    "required": true
  }, {
    "name": "interval",
    "type": "boolean",
    "default": true
  }, {
    "name": "anchor",
    "type": "number"
  }, {
    "name": "maxbins",
    "type": "number",
    "default": 20
  }, {
    "name": "base",
    "type": "number",
    "default": 10
  }, {
    "name": "divide",
    "type": "number",
    "array": true,
    "default": [5, 2]
  }, {
    "name": "extent",
    "type": "number",
    "array": true,
    "length": 2,
    "required": true
  }, {
    "name": "span",
    "type": "number"
  }, {
    "name": "step",
    "type": "number"
  }, {
    "name": "steps",
    "type": "number",
    "array": true
  }, {
    "name": "minstep",
    "type": "number",
    "default": 0
  }, {
    "name": "nice",
    "type": "boolean",
    "default": true
  }, {
    "name": "name",
    "type": "string"
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "length": 2,
    "default": ["bin0", "bin1"]
  }]
};
inherits(Bin, Transform, {
  transform(_, pulse2) {
    const band2 = _.interval !== false, bins = this._bins(_), start = bins.start, step = bins.step, as = _.as || ["bin0", "bin1"], b0 = as[0], b1 = as[1];
    let flag2;
    if (_.modified()) {
      pulse2 = pulse2.reflow(true);
      flag2 = pulse2.SOURCE;
    } else {
      flag2 = pulse2.modified(accessorFields(_.field)) ? pulse2.ADD_MOD : pulse2.ADD;
    }
    pulse2.visit(flag2, band2 ? (t) => {
      const v = bins(t);
      t[b0] = v;
      t[b1] = v == null ? null : start + step * (1 + (v - start) / step);
    } : (t) => t[b0] = bins(t));
    return pulse2.modifies(band2 ? as : b0);
  },
  _bins(_) {
    if (this.value && !_.modified()) {
      return this.value;
    }
    const field3 = _.field, bins = bin2(_), step = bins.step;
    let start = bins.start, stop2 = start + Math.ceil((bins.stop - start) / step) * step, a, d;
    if ((a = _.anchor) != null) {
      d = a - (start + step * Math.floor((a - start) / step));
      start += d;
      stop2 += d;
    }
    const f = function(t) {
      let v = toNumber(field3(t));
      return v == null ? null : v < start ? -Infinity : v > stop2 ? Infinity : (v = Math.max(start, Math.min(v, stop2 - step)), start + step * Math.floor(EPSILON$1 + (v - start) / step));
    };
    f.start = start;
    f.stop = bins.stop;
    f.step = step;
    return this.value = accessor(f, accessorFields(field3), _.name || "bin_" + accessorName(field3));
  }
});
function SortedList(idFunc, source3, input) {
  const $2 = idFunc;
  let data3 = source3 || [], add4 = input || [], rem2 = {}, cnt = 0;
  return {
    add: (t) => add4.push(t),
    remove: (t) => rem2[$2(t)] = ++cnt,
    size: () => data3.length,
    data: (compare3, resort) => {
      if (cnt) {
        data3 = data3.filter((t) => !rem2[$2(t)]);
        rem2 = {};
        cnt = 0;
      }
      if (resort && compare3) {
        data3.sort(compare3);
      }
      if (add4.length) {
        data3 = compare3 ? merge(compare3, data3, add4.sort(compare3)) : data3.concat(add4);
        add4 = [];
      }
      return data3;
    }
  };
}
function Collect(params2) {
  Transform.call(this, [], params2);
}
Collect.Definition = {
  "type": "Collect",
  "metadata": {
    "source": true
  },
  "params": [{
    "name": "sort",
    "type": "compare"
  }]
};
inherits(Collect, Transform, {
  transform(_, pulse2) {
    const out = pulse2.fork(pulse2.ALL), list = SortedList(tupleid, this.value, out.materialize(out.ADD).add), sort2 = _.sort, mod = pulse2.changed() || sort2 && (_.modified("sort") || pulse2.modified(sort2.fields));
    out.visit(out.REM, list.remove);
    this.modified(mod);
    this.value = out.source = list.data(stableCompare(sort2), mod);
    if (pulse2.source && pulse2.source.root) {
      this.value.root = pulse2.source.root;
    }
    return out;
  }
});
function Compare(params2) {
  Operator.call(this, null, update$5, params2);
}
inherits(Compare, Operator);
function update$5(_) {
  return this.value && !_.modified() ? this.value : compare(_.fields, _.orders);
}
function CountPattern(params2) {
  Transform.call(this, null, params2);
}
CountPattern.Definition = {
  "type": "CountPattern",
  "metadata": {
    "generates": true,
    "changes": true
  },
  "params": [{
    "name": "field",
    "type": "field",
    "required": true
  }, {
    "name": "case",
    "type": "enum",
    "values": ["upper", "lower", "mixed"],
    "default": "mixed"
  }, {
    "name": "pattern",
    "type": "string",
    "default": '[\\w"]+'
  }, {
    "name": "stopwords",
    "type": "string",
    "default": ""
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "length": 2,
    "default": ["text", "count"]
  }]
};
function tokenize(text2, tcase, match2) {
  switch (tcase) {
    case "upper":
      text2 = text2.toUpperCase();
      break;
    case "lower":
      text2 = text2.toLowerCase();
      break;
  }
  return text2.match(match2);
}
inherits(CountPattern, Transform, {
  transform(_, pulse2) {
    const process = (update3) => (tuple) => {
      var tokens = tokenize(get5(tuple), _.case, match2) || [], t;
      for (var i = 0, n = tokens.length; i < n; ++i) {
        if (!stop2.test(t = tokens[i]))
          update3(t);
      }
    };
    const init2 = this._parameterCheck(_, pulse2), counts = this._counts, match2 = this._match, stop2 = this._stop, get5 = _.field, as = _.as || ["text", "count"], add4 = process((t) => counts[t] = 1 + (counts[t] || 0)), rem2 = process((t) => counts[t] -= 1);
    if (init2) {
      pulse2.visit(pulse2.SOURCE, add4);
    } else {
      pulse2.visit(pulse2.ADD, add4);
      pulse2.visit(pulse2.REM, rem2);
    }
    return this._finish(pulse2, as);
  },
  _parameterCheck(_, pulse2) {
    let init2 = false;
    if (_.modified("stopwords") || !this._stop) {
      this._stop = new RegExp("^" + (_.stopwords || "") + "$", "i");
      init2 = true;
    }
    if (_.modified("pattern") || !this._match) {
      this._match = new RegExp(_.pattern || "[\\w']+", "g");
      init2 = true;
    }
    if (_.modified("field") || pulse2.modified(_.field.fields)) {
      init2 = true;
    }
    if (init2)
      this._counts = {};
    return init2;
  },
  _finish(pulse2, as) {
    const counts = this._counts, tuples = this._tuples || (this._tuples = {}), text2 = as[0], count = as[1], out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS);
    let w3, t, c;
    for (w3 in counts) {
      t = tuples[w3];
      c = counts[w3] || 0;
      if (!t && c) {
        tuples[w3] = t = ingest$1({});
        t[text2] = w3;
        t[count] = c;
        out.add.push(t);
      } else if (c === 0) {
        if (t)
          out.rem.push(t);
        counts[w3] = null;
        tuples[w3] = null;
      } else if (t[count] !== c) {
        t[count] = c;
        out.mod.push(t);
      }
    }
    return out.modifies(as);
  }
});
function Cross(params2) {
  Transform.call(this, null, params2);
}
Cross.Definition = {
  "type": "Cross",
  "metadata": {
    "generates": true
  },
  "params": [{
    "name": "filter",
    "type": "expr"
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "length": 2,
    "default": ["a", "b"]
  }]
};
inherits(Cross, Transform, {
  transform(_, pulse2) {
    const out = pulse2.fork(pulse2.NO_SOURCE), as = _.as || ["a", "b"], a = as[0], b2 = as[1], reset2 = !this.value || pulse2.changed(pulse2.ADD_REM) || _.modified("as") || _.modified("filter");
    let data3 = this.value;
    if (reset2) {
      if (data3)
        out.rem = data3;
      data3 = pulse2.materialize(pulse2.SOURCE).source;
      out.add = this.value = cross(data3, a, b2, _.filter || truthy);
    } else {
      out.mod = data3;
    }
    out.source = this.value;
    return out.modifies(as);
  }
});
function cross(input, a, b2, filter3) {
  var data3 = [], t = {}, n = input.length, i = 0, j, left;
  for (; i < n; ++i) {
    t[a] = left = input[i];
    for (j = 0; j < n; ++j) {
      t[b2] = input[j];
      if (filter3(t)) {
        data3.push(ingest$1(t));
        t = {};
        t[a] = left;
      }
    }
  }
  return data3;
}
var Distributions = {
  kde,
  mixture,
  normal: gaussian,
  lognormal,
  uniform
};
var DISTRIBUTIONS = "distributions";
var FUNCTION = "function";
var FIELD = "field";
function parse3(def2, data3) {
  const func = def2[FUNCTION];
  if (!has(Distributions, func)) {
    error("Unknown distribution function: " + func);
  }
  const d = Distributions[func]();
  for (const name in def2) {
    if (name === FIELD) {
      d.data((def2.from || data3()).map(def2[name]));
    } else if (name === DISTRIBUTIONS) {
      d[name](def2[name].map((_) => parse3(_, data3)));
    } else if (typeof d[name] === FUNCTION) {
      d[name](def2[name]);
    }
  }
  return d;
}
function Density(params2) {
  Transform.call(this, null, params2);
}
var distributions = [{
  "key": {
    "function": "normal"
  },
  "params": [{
    "name": "mean",
    "type": "number",
    "default": 0
  }, {
    "name": "stdev",
    "type": "number",
    "default": 1
  }]
}, {
  "key": {
    "function": "lognormal"
  },
  "params": [{
    "name": "mean",
    "type": "number",
    "default": 0
  }, {
    "name": "stdev",
    "type": "number",
    "default": 1
  }]
}, {
  "key": {
    "function": "uniform"
  },
  "params": [{
    "name": "min",
    "type": "number",
    "default": 0
  }, {
    "name": "max",
    "type": "number",
    "default": 1
  }]
}, {
  "key": {
    "function": "kde"
  },
  "params": [{
    "name": "field",
    "type": "field",
    "required": true
  }, {
    "name": "from",
    "type": "data"
  }, {
    "name": "bandwidth",
    "type": "number",
    "default": 0
  }]
}];
var mixture2 = {
  "key": {
    "function": "mixture"
  },
  "params": [{
    "name": "distributions",
    "type": "param",
    "array": true,
    "params": distributions
  }, {
    "name": "weights",
    "type": "number",
    "array": true
  }]
};
Density.Definition = {
  "type": "Density",
  "metadata": {
    "generates": true
  },
  "params": [{
    "name": "extent",
    "type": "number",
    "array": true,
    "length": 2
  }, {
    "name": "steps",
    "type": "number"
  }, {
    "name": "minsteps",
    "type": "number",
    "default": 25
  }, {
    "name": "maxsteps",
    "type": "number",
    "default": 200
  }, {
    "name": "method",
    "type": "string",
    "default": "pdf",
    "values": ["pdf", "cdf"]
  }, {
    "name": "distribution",
    "type": "param",
    "params": distributions.concat(mixture2)
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "default": ["value", "density"]
  }]
};
inherits(Density, Transform, {
  transform(_, pulse2) {
    const out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS);
    if (!this.value || pulse2.changed() || _.modified()) {
      const dist = parse3(_.distribution, source(pulse2)), minsteps = _.steps || _.minsteps || 25, maxsteps = _.steps || _.maxsteps || 200;
      let method2 = _.method || "pdf";
      if (method2 !== "pdf" && method2 !== "cdf") {
        error("Invalid density method: " + method2);
      }
      if (!_.extent && !dist.data) {
        error("Missing density extent parameter.");
      }
      method2 = dist[method2];
      const as = _.as || ["value", "density"], domain2 = _.extent || extent(dist.data()), values2 = sampleCurve(method2, domain2, minsteps, maxsteps).map((v) => {
        const tuple = {};
        tuple[as[0]] = v[0];
        tuple[as[1]] = v[1];
        return ingest$1(tuple);
      });
      if (this.value)
        out.rem = this.value;
      this.value = out.add = out.source = values2;
    }
    return out;
  }
});
function source(pulse2) {
  return () => pulse2.materialize(pulse2.SOURCE).source;
}
function fieldNames(fields, as) {
  if (!fields)
    return null;
  return fields.map((f, i) => as[i] || accessorName(f));
}
function partition$1(data3, groupby, field3) {
  const groups = [], get5 = (f) => f(t);
  let map2, i, n, t, k2, g;
  if (groupby == null) {
    groups.push(data3.map(field3));
  } else {
    for (map2 = {}, i = 0, n = data3.length; i < n; ++i) {
      t = data3[i];
      k2 = groupby.map(get5);
      g = map2[k2];
      if (!g) {
        map2[k2] = g = [];
        g.dims = k2;
        groups.push(g);
      }
      g.push(field3(t));
    }
  }
  return groups;
}
var Output = "bin";
function DotBin(params2) {
  Transform.call(this, null, params2);
}
DotBin.Definition = {
  "type": "DotBin",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "field",
    "type": "field",
    "required": true
  }, {
    "name": "groupby",
    "type": "field",
    "array": true
  }, {
    "name": "step",
    "type": "number"
  }, {
    "name": "smooth",
    "type": "boolean",
    "default": false
  }, {
    "name": "as",
    "type": "string",
    "default": Output
  }]
};
var autostep = (data3, field3) => span(extent(data3, field3)) / 30;
inherits(DotBin, Transform, {
  transform(_, pulse2) {
    if (this.value && !(_.modified() || pulse2.changed())) {
      return pulse2;
    }
    const source3 = pulse2.materialize(pulse2.SOURCE).source, groups = partition$1(pulse2.source, _.groupby, identity2), smooth = _.smooth || false, field3 = _.field, step = _.step || autostep(source3, field3), sort2 = stableCompare((a, b2) => field3(a) - field3(b2)), as = _.as || Output, n = groups.length;
    let min4 = Infinity, max4 = -Infinity, i = 0, j;
    for (; i < n; ++i) {
      const g = groups[i].sort(sort2);
      j = -1;
      for (const v of dotbin(g, step, smooth, field3)) {
        if (v < min4)
          min4 = v;
        if (v > max4)
          max4 = v;
        g[++j][as] = v;
      }
    }
    this.value = {
      start: min4,
      stop: max4,
      step
    };
    return pulse2.reflow(true).modifies(as);
  }
});
function Expression(params2) {
  Operator.call(this, null, update$4, params2);
  this.modified(true);
}
inherits(Expression, Operator);
function update$4(_) {
  const expr2 = _.expr;
  return this.value && !_.modified("expr") ? this.value : accessor((datum2) => expr2(datum2, _), accessorFields(expr2), accessorName(expr2));
}
function Extent(params2) {
  Transform.call(this, [void 0, void 0], params2);
}
Extent.Definition = {
  "type": "Extent",
  "metadata": {},
  "params": [{
    "name": "field",
    "type": "field",
    "required": true
  }]
};
inherits(Extent, Transform, {
  transform(_, pulse2) {
    const extent2 = this.value, field3 = _.field, mod = pulse2.changed() || pulse2.modified(field3.fields) || _.modified("field");
    let min4 = extent2[0], max4 = extent2[1];
    if (mod || min4 == null) {
      min4 = Infinity;
      max4 = -Infinity;
    }
    pulse2.visit(mod ? pulse2.SOURCE : pulse2.ADD, (t) => {
      const v = toNumber(field3(t));
      if (v != null) {
        if (v < min4)
          min4 = v;
        if (v > max4)
          max4 = v;
      }
    });
    if (!Number.isFinite(min4) || !Number.isFinite(max4)) {
      let name = accessorName(field3);
      if (name)
        name = ` for field "${name}"`;
      pulse2.dataflow.warn(`Infinite extent${name}: [${min4}, ${max4}]`);
      min4 = max4 = void 0;
    }
    this.value = [min4, max4];
  }
});
function Subflow(pulse2, parent) {
  Operator.call(this, pulse2);
  this.parent = parent;
  this.count = 0;
}
inherits(Subflow, Operator, {
  /**
   * Routes pulses from this subflow to a target transform.
   * @param {Transform} target - A transform that receives the subflow of tuples.
   */
  connect(target2) {
    this.detachSubflow = target2.detachSubflow;
    this.targets().add(target2);
    return target2.source = this;
  },
  /**
   * Add an 'add' tuple to the subflow pulse.
   * @param {Tuple} t - The tuple being added.
   */
  add(t) {
    this.count += 1;
    this.value.add.push(t);
  },
  /**
   * Add a 'rem' tuple to the subflow pulse.
   * @param {Tuple} t - The tuple being removed.
   */
  rem(t) {
    this.count -= 1;
    this.value.rem.push(t);
  },
  /**
   * Add a 'mod' tuple to the subflow pulse.
   * @param {Tuple} t - The tuple being modified.
   */
  mod(t) {
    this.value.mod.push(t);
  },
  /**
   * Re-initialize this operator's pulse value.
   * @param {Pulse} pulse - The pulse to copy from.
   * @see Pulse.init
   */
  init(pulse2) {
    this.value.init(pulse2, pulse2.NO_SOURCE);
  },
  /**
   * Evaluate this operator. This method overrides the
   * default behavior to simply return the contained pulse value.
   * @return {Pulse}
   */
  evaluate() {
    return this.value;
  }
});
function Facet(params2) {
  Transform.call(this, {}, params2);
  this._keys = fastmap();
  const a = this._targets = [];
  a.active = 0;
  a.forEach = (f) => {
    for (let i = 0, n = a.active; i < n; ++i) {
      f(a[i], i, a);
    }
  };
}
inherits(Facet, Transform, {
  activate(flow) {
    this._targets[this._targets.active++] = flow;
  },
  // parent argument provided by PreFacet subclass
  subflow(key2, flow, pulse2, parent) {
    const flows = this.value;
    let sf = has(flows, key2) && flows[key2], df, p;
    if (!sf) {
      p = parent || (p = this._group[key2]) && p.tuple;
      df = pulse2.dataflow;
      sf = new Subflow(pulse2.fork(pulse2.NO_SOURCE), this);
      df.add(sf).connect(flow(df, key2, p));
      flows[key2] = sf;
      this.activate(sf);
    } else if (sf.value.stamp < pulse2.stamp) {
      sf.init(pulse2);
      this.activate(sf);
    }
    return sf;
  },
  clean() {
    const flows = this.value;
    let detached = 0;
    for (const key2 in flows) {
      if (flows[key2].count === 0) {
        const detach = flows[key2].detachSubflow;
        if (detach)
          detach();
        delete flows[key2];
        ++detached;
      }
    }
    if (detached) {
      const active = this._targets.filter((sf) => sf && sf.count > 0);
      this.initTargets(active);
    }
  },
  initTargets(act) {
    const a = this._targets, n = a.length, m = act ? act.length : 0;
    let i = 0;
    for (; i < m; ++i) {
      a[i] = act[i];
    }
    for (; i < n && a[i] != null; ++i) {
      a[i] = null;
    }
    a.active = m;
  },
  transform(_, pulse2) {
    const df = pulse2.dataflow, key2 = _.key, flow = _.subflow, cache2 = this._keys, rekey = _.modified("key"), subflow = (key3) => this.subflow(key3, flow, pulse2);
    this._group = _.group || {};
    this.initTargets();
    pulse2.visit(pulse2.REM, (t) => {
      const id2 = tupleid(t), k2 = cache2.get(id2);
      if (k2 !== void 0) {
        cache2.delete(id2);
        subflow(k2).rem(t);
      }
    });
    pulse2.visit(pulse2.ADD, (t) => {
      const k2 = key2(t);
      cache2.set(tupleid(t), k2);
      subflow(k2).add(t);
    });
    if (rekey || pulse2.modified(key2.fields)) {
      pulse2.visit(pulse2.MOD, (t) => {
        const id2 = tupleid(t), k0 = cache2.get(id2), k1 = key2(t);
        if (k0 === k1) {
          subflow(k1).mod(t);
        } else {
          cache2.set(id2, k1);
          subflow(k0).rem(t);
          subflow(k1).add(t);
        }
      });
    } else if (pulse2.changed(pulse2.MOD)) {
      pulse2.visit(pulse2.MOD, (t) => {
        subflow(cache2.get(tupleid(t))).mod(t);
      });
    }
    if (rekey) {
      pulse2.visit(pulse2.REFLOW, (t) => {
        const id2 = tupleid(t), k0 = cache2.get(id2), k1 = key2(t);
        if (k0 !== k1) {
          cache2.set(id2, k1);
          subflow(k0).rem(t);
          subflow(k1).add(t);
        }
      });
    }
    if (pulse2.clean()) {
      df.runAfter(() => {
        this.clean();
        cache2.clean();
      });
    } else if (cache2.empty > df.cleanThreshold) {
      df.runAfter(cache2.clean);
    }
    return pulse2;
  }
});
function Field(params2) {
  Operator.call(this, null, update$3, params2);
}
inherits(Field, Operator);
function update$3(_) {
  return this.value && !_.modified() ? this.value : isArray(_.name) ? array(_.name).map((f) => field(f)) : field(_.name, _.as);
}
function Filter(params2) {
  Transform.call(this, fastmap(), params2);
}
Filter.Definition = {
  "type": "Filter",
  "metadata": {
    "changes": true
  },
  "params": [{
    "name": "expr",
    "type": "expr",
    "required": true
  }]
};
inherits(Filter, Transform, {
  transform(_, pulse2) {
    const df = pulse2.dataflow, cache2 = this.value, output3 = pulse2.fork(), add4 = output3.add, rem2 = output3.rem, mod = output3.mod, test2 = _.expr;
    let isMod = true;
    pulse2.visit(pulse2.REM, (t) => {
      const id2 = tupleid(t);
      if (!cache2.has(id2))
        rem2.push(t);
      else
        cache2.delete(id2);
    });
    pulse2.visit(pulse2.ADD, (t) => {
      if (test2(t, _))
        add4.push(t);
      else
        cache2.set(tupleid(t), 1);
    });
    function revisit(t) {
      const id2 = tupleid(t), b2 = test2(t, _), s = cache2.get(id2);
      if (b2 && s) {
        cache2.delete(id2);
        add4.push(t);
      } else if (!b2 && !s) {
        cache2.set(id2, 1);
        rem2.push(t);
      } else if (isMod && b2 && !s) {
        mod.push(t);
      }
    }
    pulse2.visit(pulse2.MOD, revisit);
    if (_.modified()) {
      isMod = false;
      pulse2.visit(pulse2.REFLOW, revisit);
    }
    if (cache2.empty > df.cleanThreshold)
      df.runAfter(cache2.clean);
    return output3;
  }
});
function Flatten(params2) {
  Transform.call(this, [], params2);
}
Flatten.Definition = {
  "type": "Flatten",
  "metadata": {
    "generates": true
  },
  "params": [{
    "name": "fields",
    "type": "field",
    "array": true,
    "required": true
  }, {
    "name": "index",
    "type": "string"
  }, {
    "name": "as",
    "type": "string",
    "array": true
  }]
};
inherits(Flatten, Transform, {
  transform(_, pulse2) {
    const out = pulse2.fork(pulse2.NO_SOURCE), fields = _.fields, as = fieldNames(fields, _.as || []), index2 = _.index || null, m = as.length;
    out.rem = this.value;
    pulse2.visit(pulse2.SOURCE, (t) => {
      const arrays = fields.map((f) => f(t)), maxlen = arrays.reduce((l, a) => Math.max(l, a.length), 0);
      let i = 0, j, d, v;
      for (; i < maxlen; ++i) {
        d = derive(t);
        for (j = 0; j < m; ++j) {
          d[as[j]] = (v = arrays[j][i]) == null ? null : v;
        }
        if (index2) {
          d[index2] = i;
        }
        out.add.push(d);
      }
    });
    this.value = out.source = out.add;
    if (index2)
      out.modifies(index2);
    return out.modifies(as);
  }
});
function Fold(params2) {
  Transform.call(this, [], params2);
}
Fold.Definition = {
  "type": "Fold",
  "metadata": {
    "generates": true
  },
  "params": [{
    "name": "fields",
    "type": "field",
    "array": true,
    "required": true
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "length": 2,
    "default": ["key", "value"]
  }]
};
inherits(Fold, Transform, {
  transform(_, pulse2) {
    const out = pulse2.fork(pulse2.NO_SOURCE), fields = _.fields, fnames = fields.map(accessorName), as = _.as || ["key", "value"], k2 = as[0], v = as[1], n = fields.length;
    out.rem = this.value;
    pulse2.visit(pulse2.SOURCE, (t) => {
      for (let i = 0, d; i < n; ++i) {
        d = derive(t);
        d[k2] = fnames[i];
        d[v] = fields[i](t);
        out.add.push(d);
      }
    });
    this.value = out.source = out.add;
    return out.modifies(as);
  }
});
function Formula(params2) {
  Transform.call(this, null, params2);
}
Formula.Definition = {
  "type": "Formula",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "expr",
    "type": "expr",
    "required": true
  }, {
    "name": "as",
    "type": "string",
    "required": true
  }, {
    "name": "initonly",
    "type": "boolean"
  }]
};
inherits(Formula, Transform, {
  transform(_, pulse2) {
    const func = _.expr, as = _.as, mod = _.modified(), flag2 = _.initonly ? pulse2.ADD : mod ? pulse2.SOURCE : pulse2.modified(func.fields) || pulse2.modified(as) ? pulse2.ADD_MOD : pulse2.ADD;
    if (mod) {
      pulse2 = pulse2.materialize().reflow(true);
    }
    if (!_.initonly) {
      pulse2.modifies(as);
    }
    return pulse2.visit(flag2, (t) => t[as] = func(t, _));
  }
});
function Generate(params2) {
  Transform.call(this, [], params2);
}
inherits(Generate, Transform, {
  transform(_, pulse2) {
    const out = pulse2.fork(pulse2.ALL), gen = _.generator;
    let data3 = this.value, num = _.size - data3.length, add4, rem2, t;
    if (num > 0) {
      for (add4 = []; --num >= 0; ) {
        add4.push(t = ingest$1(gen(_)));
        data3.push(t);
      }
      out.add = out.add.length ? out.materialize(out.ADD).add.concat(add4) : add4;
    } else {
      rem2 = data3.slice(0, -num);
      out.rem = out.rem.length ? out.materialize(out.REM).rem.concat(rem2) : rem2;
      data3 = data3.slice(-num);
    }
    out.source = this.value = data3;
    return out;
  }
});
var Methods = {
  value: "value",
  median,
  mean,
  min,
  max
};
var Empty = [];
function Impute(params2) {
  Transform.call(this, [], params2);
}
Impute.Definition = {
  "type": "Impute",
  "metadata": {
    "changes": true
  },
  "params": [{
    "name": "field",
    "type": "field",
    "required": true
  }, {
    "name": "key",
    "type": "field",
    "required": true
  }, {
    "name": "keyvals",
    "array": true
  }, {
    "name": "groupby",
    "type": "field",
    "array": true
  }, {
    "name": "method",
    "type": "enum",
    "default": "value",
    "values": ["value", "mean", "median", "max", "min"]
  }, {
    "name": "value",
    "default": 0
  }]
};
function getValue(_) {
  var m = _.method || Methods.value, v;
  if (Methods[m] == null) {
    error("Unrecognized imputation method: " + m);
  } else if (m === Methods.value) {
    v = _.value !== void 0 ? _.value : 0;
    return () => v;
  } else {
    return Methods[m];
  }
}
function getField(_) {
  const f = _.field;
  return (t) => t ? f(t) : NaN;
}
inherits(Impute, Transform, {
  transform(_, pulse2) {
    var out = pulse2.fork(pulse2.ALL), impute = getValue(_), field3 = getField(_), fName = accessorName(_.field), kName = accessorName(_.key), gNames = (_.groupby || []).map(accessorName), groups = partition(pulse2.source, _.groupby, _.key, _.keyvals), curr = [], prev = this.value, m = groups.domain.length, group2, value3, gVals, kVal, g, i, j, l, n, t;
    for (g = 0, l = groups.length; g < l; ++g) {
      group2 = groups[g];
      gVals = group2.values;
      value3 = NaN;
      for (j = 0; j < m; ++j) {
        if (group2[j] != null)
          continue;
        kVal = groups.domain[j];
        t = {
          _impute: true
        };
        for (i = 0, n = gVals.length; i < n; ++i)
          t[gNames[i]] = gVals[i];
        t[kName] = kVal;
        t[fName] = Number.isNaN(value3) ? value3 = impute(group2, field3) : value3;
        curr.push(ingest$1(t));
      }
    }
    if (curr.length)
      out.add = out.materialize(out.ADD).add.concat(curr);
    if (prev.length)
      out.rem = out.materialize(out.REM).rem.concat(prev);
    this.value = curr;
    return out;
  }
});
function partition(data3, groupby, key2, keyvals) {
  var get5 = (f) => f(t), groups = [], domain2 = keyvals ? keyvals.slice() : [], kMap = {}, gMap = {}, gVals, gKey, group2, i, j, k2, n, t;
  domain2.forEach((k3, i2) => kMap[k3] = i2 + 1);
  for (i = 0, n = data3.length; i < n; ++i) {
    t = data3[i];
    k2 = key2(t);
    j = kMap[k2] || (kMap[k2] = domain2.push(k2));
    gKey = (gVals = groupby ? groupby.map(get5) : Empty) + "";
    if (!(group2 = gMap[gKey])) {
      group2 = gMap[gKey] = [];
      groups.push(group2);
      group2.values = gVals;
    }
    group2[j - 1] = t;
  }
  groups.domain = domain2;
  return groups;
}
function JoinAggregate(params2) {
  Aggregate.call(this, params2);
}
JoinAggregate.Definition = {
  "type": "JoinAggregate",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "groupby",
    "type": "field",
    "array": true
  }, {
    "name": "fields",
    "type": "field",
    "null": true,
    "array": true
  }, {
    "name": "ops",
    "type": "enum",
    "array": true,
    "values": ValidAggregateOps
  }, {
    "name": "as",
    "type": "string",
    "null": true,
    "array": true
  }, {
    "name": "key",
    "type": "field"
  }]
};
inherits(JoinAggregate, Aggregate, {
  transform(_, pulse2) {
    const aggr = this, mod = _.modified();
    let cells;
    if (aggr.value && (mod || pulse2.modified(aggr._inputs, true))) {
      cells = aggr.value = mod ? aggr.init(_) : {};
      pulse2.visit(pulse2.SOURCE, (t) => aggr.add(t));
    } else {
      cells = aggr.value = aggr.value || this.init(_);
      pulse2.visit(pulse2.REM, (t) => aggr.rem(t));
      pulse2.visit(pulse2.ADD, (t) => aggr.add(t));
    }
    aggr.changes();
    pulse2.visit(pulse2.SOURCE, (t) => {
      extend(t, cells[aggr.cellkey(t)].tuple);
    });
    return pulse2.reflow(mod).modifies(this._outputs);
  },
  changes() {
    const adds = this._adds, mods = this._mods;
    let i, n;
    for (i = 0, n = this._alen; i < n; ++i) {
      this.celltuple(adds[i]);
      adds[i] = null;
    }
    for (i = 0, n = this._mlen; i < n; ++i) {
      this.celltuple(mods[i]);
      mods[i] = null;
    }
    this._alen = this._mlen = 0;
  }
});
function KDE(params2) {
  Transform.call(this, null, params2);
}
KDE.Definition = {
  "type": "KDE",
  "metadata": {
    "generates": true
  },
  "params": [{
    "name": "groupby",
    "type": "field",
    "array": true
  }, {
    "name": "field",
    "type": "field",
    "required": true
  }, {
    "name": "cumulative",
    "type": "boolean",
    "default": false
  }, {
    "name": "counts",
    "type": "boolean",
    "default": false
  }, {
    "name": "bandwidth",
    "type": "number",
    "default": 0
  }, {
    "name": "extent",
    "type": "number",
    "array": true,
    "length": 2
  }, {
    "name": "resolve",
    "type": "enum",
    "values": ["shared", "independent"],
    "default": "independent"
  }, {
    "name": "steps",
    "type": "number"
  }, {
    "name": "minsteps",
    "type": "number",
    "default": 25
  }, {
    "name": "maxsteps",
    "type": "number",
    "default": 200
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "default": ["value", "density"]
  }]
};
inherits(KDE, Transform, {
  transform(_, pulse2) {
    const out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS);
    if (!this.value || pulse2.changed() || _.modified()) {
      const source3 = pulse2.materialize(pulse2.SOURCE).source, groups = partition$1(source3, _.groupby, _.field), names = (_.groupby || []).map(accessorName), bandwidth2 = _.bandwidth, method2 = _.cumulative ? "cdf" : "pdf", as = _.as || ["value", "density"], values2 = [];
      let domain2 = _.extent, minsteps = _.steps || _.minsteps || 25, maxsteps = _.steps || _.maxsteps || 200;
      if (method2 !== "pdf" && method2 !== "cdf") {
        error("Invalid density method: " + method2);
      }
      if (_.resolve === "shared") {
        if (!domain2)
          domain2 = extent(source3, _.field);
        minsteps = maxsteps = _.steps || maxsteps;
      }
      groups.forEach((g) => {
        const density = kde(g, bandwidth2)[method2], scale6 = _.counts ? g.length : 1, local = domain2 || extent(g);
        sampleCurve(density, local, minsteps, maxsteps).forEach((v) => {
          const t = {};
          for (let i = 0; i < names.length; ++i) {
            t[names[i]] = g.dims[i];
          }
          t[as[0]] = v[0];
          t[as[1]] = v[1] * scale6;
          values2.push(ingest$1(t));
        });
      });
      if (this.value)
        out.rem = this.value;
      this.value = out.add = out.source = values2;
    }
    return out;
  }
});
function Key(params2) {
  Operator.call(this, null, update$2, params2);
}
inherits(Key, Operator);
function update$2(_) {
  return this.value && !_.modified() ? this.value : key(_.fields, _.flat);
}
function Load(params2) {
  Transform.call(this, [], params2);
  this._pending = null;
}
inherits(Load, Transform, {
  transform(_, pulse2) {
    const df = pulse2.dataflow;
    if (this._pending) {
      return output2(this, pulse2, this._pending);
    }
    if (stop(_))
      return pulse2.StopPropagation;
    if (_.values) {
      return output2(this, pulse2, df.parse(_.values, _.format));
    } else if (_.async) {
      const p = df.request(_.url, _.format).then((res) => {
        this._pending = array(res.data);
        return (df2) => df2.touch(this);
      });
      return {
        async: p
      };
    } else {
      return df.request(_.url, _.format).then((res) => output2(this, pulse2, array(res.data)));
    }
  }
});
function stop(_) {
  return _.modified("async") && !(_.modified("values") || _.modified("url") || _.modified("format"));
}
function output2(op, pulse2, data3) {
  data3.forEach(ingest$1);
  const out = pulse2.fork(pulse2.NO_FIELDS & pulse2.NO_SOURCE);
  out.rem = op.value;
  op.value = out.source = out.add = data3;
  op._pending = null;
  if (out.rem.length)
    out.clean(true);
  return out;
}
function Lookup(params2) {
  Transform.call(this, {}, params2);
}
Lookup.Definition = {
  "type": "Lookup",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "index",
    "type": "index",
    "params": [{
      "name": "from",
      "type": "data",
      "required": true
    }, {
      "name": "key",
      "type": "field",
      "required": true
    }]
  }, {
    "name": "values",
    "type": "field",
    "array": true
  }, {
    "name": "fields",
    "type": "field",
    "array": true,
    "required": true
  }, {
    "name": "as",
    "type": "string",
    "array": true
  }, {
    "name": "default",
    "default": null
  }]
};
inherits(Lookup, Transform, {
  transform(_, pulse2) {
    const keys3 = _.fields, index2 = _.index, values2 = _.values, defaultValue = _.default == null ? null : _.default, reset2 = _.modified(), n = keys3.length;
    let flag2 = reset2 ? pulse2.SOURCE : pulse2.ADD, out = pulse2, as = _.as, set4, m, mods;
    if (values2) {
      m = values2.length;
      if (n > 1 && !as) {
        error('Multi-field lookup requires explicit "as" parameter.');
      }
      if (as && as.length !== n * m) {
        error('The "as" parameter has too few output field names.');
      }
      as = as || values2.map(accessorName);
      set4 = function(t) {
        for (var i = 0, k2 = 0, j, v; i < n; ++i) {
          v = index2.get(keys3[i](t));
          if (v == null)
            for (j = 0; j < m; ++j, ++k2)
              t[as[k2]] = defaultValue;
          else
            for (j = 0; j < m; ++j, ++k2)
              t[as[k2]] = values2[j](v);
        }
      };
    } else {
      if (!as) {
        error("Missing output field names.");
      }
      set4 = function(t) {
        for (var i = 0, v; i < n; ++i) {
          v = index2.get(keys3[i](t));
          t[as[i]] = v == null ? defaultValue : v;
        }
      };
    }
    if (reset2) {
      out = pulse2.reflow(true);
    } else {
      mods = keys3.some((k2) => pulse2.modified(k2.fields));
      flag2 |= mods ? pulse2.MOD : 0;
    }
    pulse2.visit(flag2, set4);
    return out.modifies(as);
  }
});
function MultiExtent(params2) {
  Operator.call(this, null, update$1, params2);
}
inherits(MultiExtent, Operator);
function update$1(_) {
  if (this.value && !_.modified()) {
    return this.value;
  }
  const ext = _.extents, n = ext.length;
  let min4 = Infinity, max4 = -Infinity, i, e;
  for (i = 0; i < n; ++i) {
    e = ext[i];
    if (e[0] < min4)
      min4 = e[0];
    if (e[1] > max4)
      max4 = e[1];
  }
  return [min4, max4];
}
function MultiValues(params2) {
  Operator.call(this, null, update2, params2);
}
inherits(MultiValues, Operator);
function update2(_) {
  return this.value && !_.modified() ? this.value : _.values.reduce((data3, _2) => data3.concat(_2), []);
}
function Params(params2) {
  Transform.call(this, null, params2);
}
inherits(Params, Transform, {
  transform(_, pulse2) {
    this.modified(_.modified());
    this.value = _;
    return pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS);
  }
});
function Pivot(params2) {
  Aggregate.call(this, params2);
}
Pivot.Definition = {
  "type": "Pivot",
  "metadata": {
    "generates": true,
    "changes": true
  },
  "params": [{
    "name": "groupby",
    "type": "field",
    "array": true
  }, {
    "name": "field",
    "type": "field",
    "required": true
  }, {
    "name": "value",
    "type": "field",
    "required": true
  }, {
    "name": "op",
    "type": "enum",
    "values": ValidAggregateOps,
    "default": "sum"
  }, {
    "name": "limit",
    "type": "number",
    "default": 0
  }, {
    "name": "key",
    "type": "field"
  }]
};
inherits(Pivot, Aggregate, {
  _transform: Aggregate.prototype.transform,
  transform(_, pulse2) {
    return this._transform(aggregateParams(_, pulse2), pulse2);
  }
});
function aggregateParams(_, pulse2) {
  const key2 = _.field, value3 = _.value, op = (_.op === "count" ? "__count__" : _.op) || "sum", fields = accessorFields(key2).concat(accessorFields(value3)), keys3 = pivotKeys(key2, _.limit || 0, pulse2);
  if (pulse2.changed())
    _.set("__pivot__", null, null, true);
  return {
    key: _.key,
    groupby: _.groupby,
    ops: keys3.map(() => op),
    fields: keys3.map((k2) => get(k2, key2, value3, fields)),
    as: keys3.map((k2) => k2 + ""),
    modified: _.modified.bind(_)
  };
}
function get(k2, key2, value3, fields) {
  return accessor((d) => key2(d) === k2 ? value3(d) : NaN, fields, k2 + "");
}
function pivotKeys(key2, limit, pulse2) {
  const map2 = {}, list = [];
  pulse2.visit(pulse2.SOURCE, (t) => {
    const k2 = key2(t);
    if (!map2[k2]) {
      map2[k2] = 1;
      list.push(k2);
    }
  });
  list.sort(ascending2);
  return limit ? list.slice(0, limit) : list;
}
function PreFacet(params2) {
  Facet.call(this, params2);
}
inherits(PreFacet, Facet, {
  transform(_, pulse2) {
    const flow = _.subflow, field3 = _.field, subflow = (t) => this.subflow(tupleid(t), flow, pulse2, t);
    if (_.modified("field") || field3 && pulse2.modified(accessorFields(field3))) {
      error("PreFacet does not support field modification.");
    }
    this.initTargets();
    if (field3) {
      pulse2.visit(pulse2.MOD, (t) => {
        const sf = subflow(t);
        field3(t).forEach((_2) => sf.mod(_2));
      });
      pulse2.visit(pulse2.ADD, (t) => {
        const sf = subflow(t);
        field3(t).forEach((_2) => sf.add(ingest$1(_2)));
      });
      pulse2.visit(pulse2.REM, (t) => {
        const sf = subflow(t);
        field3(t).forEach((_2) => sf.rem(_2));
      });
    } else {
      pulse2.visit(pulse2.MOD, (t) => subflow(t).mod(t));
      pulse2.visit(pulse2.ADD, (t) => subflow(t).add(t));
      pulse2.visit(pulse2.REM, (t) => subflow(t).rem(t));
    }
    if (pulse2.clean()) {
      pulse2.runAfter(() => this.clean());
    }
    return pulse2;
  }
});
function Project(params2) {
  Transform.call(this, null, params2);
}
Project.Definition = {
  "type": "Project",
  "metadata": {
    "generates": true,
    "changes": true
  },
  "params": [{
    "name": "fields",
    "type": "field",
    "array": true
  }, {
    "name": "as",
    "type": "string",
    "null": true,
    "array": true
  }]
};
inherits(Project, Transform, {
  transform(_, pulse2) {
    const out = pulse2.fork(pulse2.NO_SOURCE), fields = _.fields, as = fieldNames(_.fields, _.as || []), derive2 = fields ? (s, t) => project(s, t, fields, as) : rederive;
    let lut;
    if (this.value) {
      lut = this.value;
    } else {
      pulse2 = pulse2.addAll();
      lut = this.value = {};
    }
    pulse2.visit(pulse2.REM, (t) => {
      const id2 = tupleid(t);
      out.rem.push(lut[id2]);
      lut[id2] = null;
    });
    pulse2.visit(pulse2.ADD, (t) => {
      const dt = derive2(t, ingest$1({}));
      lut[tupleid(t)] = dt;
      out.add.push(dt);
    });
    pulse2.visit(pulse2.MOD, (t) => {
      out.mod.push(derive2(t, lut[tupleid(t)]));
    });
    return out;
  }
});
function project(s, t, fields, as) {
  for (let i = 0, n = fields.length; i < n; ++i) {
    t[as[i]] = fields[i](s);
  }
  return t;
}
function Proxy(params2) {
  Transform.call(this, null, params2);
}
inherits(Proxy, Transform, {
  transform(_, pulse2) {
    this.value = _.value;
    return _.modified("value") ? pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS) : pulse2.StopPropagation;
  }
});
function Quantile(params2) {
  Transform.call(this, null, params2);
}
Quantile.Definition = {
  "type": "Quantile",
  "metadata": {
    "generates": true,
    "changes": true
  },
  "params": [{
    "name": "groupby",
    "type": "field",
    "array": true
  }, {
    "name": "field",
    "type": "field",
    "required": true
  }, {
    "name": "probs",
    "type": "number",
    "array": true
  }, {
    "name": "step",
    "type": "number",
    "default": 0.01
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "default": ["prob", "value"]
  }]
};
var EPSILON = 1e-14;
inherits(Quantile, Transform, {
  transform(_, pulse2) {
    const out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS), as = _.as || ["prob", "value"];
    if (this.value && !_.modified() && !pulse2.changed()) {
      out.source = this.value;
      return out;
    }
    const source3 = pulse2.materialize(pulse2.SOURCE).source, groups = partition$1(source3, _.groupby, _.field), names = (_.groupby || []).map(accessorName), values2 = [], step = _.step || 0.01, p = _.probs || range(step / 2, 1 - EPSILON, step), n = p.length;
    groups.forEach((g) => {
      const q = quantiles(g, p);
      for (let i = 0; i < n; ++i) {
        const t = {};
        for (let i2 = 0; i2 < names.length; ++i2) {
          t[names[i2]] = g.dims[i2];
        }
        t[as[0]] = p[i];
        t[as[1]] = q[i];
        values2.push(ingest$1(t));
      }
    });
    if (this.value)
      out.rem = this.value;
    this.value = out.add = out.source = values2;
    return out;
  }
});
function Relay(params2) {
  Transform.call(this, null, params2);
}
inherits(Relay, Transform, {
  transform(_, pulse2) {
    let out, lut;
    if (this.value) {
      lut = this.value;
    } else {
      out = pulse2 = pulse2.addAll();
      lut = this.value = {};
    }
    if (_.derive) {
      out = pulse2.fork(pulse2.NO_SOURCE);
      pulse2.visit(pulse2.REM, (t) => {
        const id2 = tupleid(t);
        out.rem.push(lut[id2]);
        lut[id2] = null;
      });
      pulse2.visit(pulse2.ADD, (t) => {
        const dt = derive(t);
        lut[tupleid(t)] = dt;
        out.add.push(dt);
      });
      pulse2.visit(pulse2.MOD, (t) => {
        const dt = lut[tupleid(t)];
        for (const k2 in t) {
          dt[k2] = t[k2];
          out.modifies(k2);
        }
        out.mod.push(dt);
      });
    }
    return out;
  }
});
function Sample(params2) {
  Transform.call(this, [], params2);
  this.count = 0;
}
Sample.Definition = {
  "type": "Sample",
  "metadata": {},
  "params": [{
    "name": "size",
    "type": "number",
    "default": 1e3
  }]
};
inherits(Sample, Transform, {
  transform(_, pulse2) {
    const out = pulse2.fork(pulse2.NO_SOURCE), mod = _.modified("size"), num = _.size, map2 = this.value.reduce((m, t) => (m[tupleid(t)] = 1, m), {});
    let res = this.value, cnt = this.count, cap = 0;
    function update3(t) {
      let p, idx;
      if (res.length < num) {
        res.push(t);
      } else {
        idx = ~~((cnt + 1) * random());
        if (idx < res.length && idx >= cap) {
          p = res[idx];
          if (map2[tupleid(p)])
            out.rem.push(p);
          res[idx] = t;
        }
      }
      ++cnt;
    }
    if (pulse2.rem.length) {
      pulse2.visit(pulse2.REM, (t) => {
        const id2 = tupleid(t);
        if (map2[id2]) {
          map2[id2] = -1;
          out.rem.push(t);
        }
        --cnt;
      });
      res = res.filter((t) => map2[tupleid(t)] !== -1);
    }
    if ((pulse2.rem.length || mod) && res.length < num && pulse2.source) {
      cap = cnt = res.length;
      pulse2.visit(pulse2.SOURCE, (t) => {
        if (!map2[tupleid(t)])
          update3(t);
      });
      cap = -1;
    }
    if (mod && res.length > num) {
      const n = res.length - num;
      for (let i = 0; i < n; ++i) {
        map2[tupleid(res[i])] = -1;
        out.rem.push(res[i]);
      }
      res = res.slice(n);
    }
    if (pulse2.mod.length) {
      pulse2.visit(pulse2.MOD, (t) => {
        if (map2[tupleid(t)])
          out.mod.push(t);
      });
    }
    if (pulse2.add.length) {
      pulse2.visit(pulse2.ADD, update3);
    }
    if (pulse2.add.length || cap < 0) {
      out.add = res.filter((t) => !map2[tupleid(t)]);
    }
    this.count = cnt;
    this.value = out.source = res;
    return out;
  }
});
function Sequence(params2) {
  Transform.call(this, null, params2);
}
Sequence.Definition = {
  "type": "Sequence",
  "metadata": {
    "generates": true,
    "changes": true
  },
  "params": [{
    "name": "start",
    "type": "number",
    "required": true
  }, {
    "name": "stop",
    "type": "number",
    "required": true
  }, {
    "name": "step",
    "type": "number",
    "default": 1
  }, {
    "name": "as",
    "type": "string",
    "default": "data"
  }]
};
inherits(Sequence, Transform, {
  transform(_, pulse2) {
    if (this.value && !_.modified())
      return;
    const out = pulse2.materialize().fork(pulse2.MOD), as = _.as || "data";
    out.rem = this.value ? pulse2.rem.concat(this.value) : pulse2.rem;
    this.value = range(_.start, _.stop, _.step || 1).map((v) => {
      const t = {};
      t[as] = v;
      return ingest$1(t);
    });
    out.add = pulse2.add.concat(this.value);
    return out;
  }
});
function Sieve(params2) {
  Transform.call(this, null, params2);
  this.modified(true);
}
inherits(Sieve, Transform, {
  transform(_, pulse2) {
    this.value = pulse2.source;
    return pulse2.changed() ? pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS) : pulse2.StopPropagation;
  }
});
function TimeUnit(params2) {
  Transform.call(this, null, params2);
}
var OUTPUT = ["unit0", "unit1"];
TimeUnit.Definition = {
  "type": "TimeUnit",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "field",
    "type": "field",
    "required": true
  }, {
    "name": "interval",
    "type": "boolean",
    "default": true
  }, {
    "name": "units",
    "type": "enum",
    "values": TIME_UNITS,
    "array": true
  }, {
    "name": "step",
    "type": "number",
    "default": 1
  }, {
    "name": "maxbins",
    "type": "number",
    "default": 40
  }, {
    "name": "extent",
    "type": "date",
    "array": true
  }, {
    "name": "timezone",
    "type": "enum",
    "default": "local",
    "values": ["local", "utc"]
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "length": 2,
    "default": OUTPUT
  }]
};
inherits(TimeUnit, Transform, {
  transform(_, pulse2) {
    const field3 = _.field, band2 = _.interval !== false, utc = _.timezone === "utc", floor3 = this._floor(_, pulse2), offset4 = (utc ? utcInterval : timeInterval)(floor3.unit).offset, as = _.as || OUTPUT, u0 = as[0], u1 = as[1], step = floor3.step;
    let min4 = floor3.start || Infinity, max4 = floor3.stop || -Infinity, flag2 = pulse2.ADD;
    if (_.modified() || pulse2.changed(pulse2.REM) || pulse2.modified(accessorFields(field3))) {
      pulse2 = pulse2.reflow(true);
      flag2 = pulse2.SOURCE;
      min4 = Infinity;
      max4 = -Infinity;
    }
    pulse2.visit(flag2, (t) => {
      const v = field3(t);
      let a, b2;
      if (v == null) {
        t[u0] = null;
        if (band2)
          t[u1] = null;
      } else {
        t[u0] = a = b2 = floor3(v);
        if (band2)
          t[u1] = b2 = offset4(a, step);
        if (a < min4)
          min4 = a;
        if (b2 > max4)
          max4 = b2;
      }
    });
    floor3.start = min4;
    floor3.stop = max4;
    return pulse2.modifies(band2 ? as : u0);
  },
  _floor(_, pulse2) {
    const utc = _.timezone === "utc";
    const {
      units,
      step
    } = _.units ? {
      units: _.units,
      step: _.step || 1
    } : bin({
      extent: _.extent || extent(pulse2.materialize(pulse2.SOURCE).source, _.field),
      maxbins: _.maxbins
    });
    const tunits = timeUnits(units), prev = this.value || {}, floor3 = (utc ? utcFloor : timeFloor)(tunits, step);
    floor3.unit = peek(tunits);
    floor3.units = tunits;
    floor3.step = step;
    floor3.start = prev.start;
    floor3.stop = prev.stop;
    return this.value = floor3;
  }
});
function TupleIndex(params2) {
  Transform.call(this, fastmap(), params2);
}
inherits(TupleIndex, Transform, {
  transform(_, pulse2) {
    const df = pulse2.dataflow, field3 = _.field, index2 = this.value, set4 = (t) => index2.set(field3(t), t);
    let mod = true;
    if (_.modified("field") || pulse2.modified(field3.fields)) {
      index2.clear();
      pulse2.visit(pulse2.SOURCE, set4);
    } else if (pulse2.changed()) {
      pulse2.visit(pulse2.REM, (t) => index2.delete(field3(t)));
      pulse2.visit(pulse2.ADD, set4);
    } else {
      mod = false;
    }
    this.modified(mod);
    if (index2.empty > df.cleanThreshold)
      df.runAfter(index2.clean);
    return pulse2.fork();
  }
});
function Values(params2) {
  Transform.call(this, null, params2);
}
inherits(Values, Transform, {
  transform(_, pulse2) {
    const run2 = !this.value || _.modified("field") || _.modified("sort") || pulse2.changed() || _.sort && pulse2.modified(_.sort.fields);
    if (run2) {
      this.value = (_.sort ? pulse2.source.slice().sort(stableCompare(_.sort)) : pulse2.source).map(_.field);
    }
  }
});
function WindowOp(op, field3, param2, as) {
  const fn = WindowOps[op](field3, param2);
  return {
    init: fn.init || zero,
    update: function(w3, t) {
      t[as] = fn.next(w3);
    }
  };
}
var WindowOps = {
  row_number: function() {
    return {
      next: (w3) => w3.index + 1
    };
  },
  rank: function() {
    let rank2;
    return {
      init: () => rank2 = 1,
      next: (w3) => {
        const i = w3.index, data3 = w3.data;
        return i && w3.compare(data3[i - 1], data3[i]) ? rank2 = i + 1 : rank2;
      }
    };
  },
  dense_rank: function() {
    let drank;
    return {
      init: () => drank = 1,
      next: (w3) => {
        const i = w3.index, d = w3.data;
        return i && w3.compare(d[i - 1], d[i]) ? ++drank : drank;
      }
    };
  },
  percent_rank: function() {
    const rank2 = WindowOps.rank(), next = rank2.next;
    return {
      init: rank2.init,
      next: (w3) => (next(w3) - 1) / (w3.data.length - 1)
    };
  },
  cume_dist: function() {
    let cume;
    return {
      init: () => cume = 0,
      next: (w3) => {
        const d = w3.data, c = w3.compare;
        let i = w3.index;
        if (cume < i) {
          while (i + 1 < d.length && !c(d[i], d[i + 1]))
            ++i;
          cume = i;
        }
        return (1 + cume) / d.length;
      }
    };
  },
  ntile: function(field3, num) {
    num = +num;
    if (!(num > 0))
      error("ntile num must be greater than zero.");
    const cume = WindowOps.cume_dist(), next = cume.next;
    return {
      init: cume.init,
      next: (w3) => Math.ceil(num * next(w3))
    };
  },
  lag: function(field3, offset4) {
    offset4 = +offset4 || 1;
    return {
      next: (w3) => {
        const i = w3.index - offset4;
        return i >= 0 ? field3(w3.data[i]) : null;
      }
    };
  },
  lead: function(field3, offset4) {
    offset4 = +offset4 || 1;
    return {
      next: (w3) => {
        const i = w3.index + offset4, d = w3.data;
        return i < d.length ? field3(d[i]) : null;
      }
    };
  },
  first_value: function(field3) {
    return {
      next: (w3) => field3(w3.data[w3.i0])
    };
  },
  last_value: function(field3) {
    return {
      next: (w3) => field3(w3.data[w3.i1 - 1])
    };
  },
  nth_value: function(field3, nth) {
    nth = +nth;
    if (!(nth > 0))
      error("nth_value nth must be greater than zero.");
    return {
      next: (w3) => {
        const i = w3.i0 + (nth - 1);
        return i < w3.i1 ? field3(w3.data[i]) : null;
      }
    };
  },
  prev_value: function(field3) {
    let prev;
    return {
      init: () => prev = null,
      next: (w3) => {
        const v = field3(w3.data[w3.index]);
        return v != null ? prev = v : prev;
      }
    };
  },
  next_value: function(field3) {
    let v, i;
    return {
      init: () => (v = null, i = -1),
      next: (w3) => {
        const d = w3.data;
        return w3.index <= i ? v : (i = find(field3, d, w3.index)) < 0 ? (i = d.length, v = null) : v = field3(d[i]);
      }
    };
  }
};
function find(field3, data3, index2) {
  for (let n = data3.length; index2 < n; ++index2) {
    const v = field3(data3[index2]);
    if (v != null)
      return index2;
  }
  return -1;
}
var ValidWindowOps = Object.keys(WindowOps);
function WindowState(_) {
  const ops2 = array(_.ops), fields = array(_.fields), params2 = array(_.params), aggregate_params = array(_.aggregate_params), as = array(_.as), outputs = this.outputs = [], windows = this.windows = [], inputs = {}, map2 = {}, counts = [], measures = [];
  let countOnly = true;
  function visitInputs(f) {
    array(accessorFields(f)).forEach((_2) => inputs[_2] = 1);
  }
  visitInputs(_.sort);
  ops2.forEach((op, i) => {
    const field3 = fields[i], param2 = params2[i], aggregate_param = aggregate_params[i] || null, mname = accessorName(field3), name = measureName(op, mname, as[i]);
    visitInputs(field3);
    outputs.push(name);
    if (has(WindowOps, op)) {
      windows.push(WindowOp(op, field3, param2, name));
    } else {
      if (field3 == null && op !== "count") {
        error("Null aggregate field specified.");
      }
      if (op === "count") {
        counts.push(name);
        return;
      }
      countOnly = false;
      let m = map2[mname];
      if (!m) {
        m = map2[mname] = [];
        m.field = field3;
        measures.push(m);
      }
      m.push(createMeasure(op, aggregate_param, name));
    }
  });
  if (counts.length || measures.length) {
    this.cell = cell(measures, counts, countOnly);
  }
  this.inputs = Object.keys(inputs);
}
var prototype = WindowState.prototype;
prototype.init = function() {
  this.windows.forEach((_) => _.init());
  if (this.cell)
    this.cell.init();
};
prototype.update = function(w3, t) {
  const cell2 = this.cell, wind = this.windows, data3 = w3.data, m = wind && wind.length;
  let j;
  if (cell2) {
    for (j = w3.p0; j < w3.i0; ++j)
      cell2.rem(data3[j]);
    for (j = w3.p1; j < w3.i1; ++j)
      cell2.add(data3[j]);
    cell2.set(t);
  }
  for (j = 0; j < m; ++j)
    wind[j].update(w3, t);
};
function cell(measures, counts, countOnly) {
  measures = measures.map((m) => compileMeasures(m, m.field));
  const cell2 = {
    num: 0,
    agg: null,
    store: false,
    count: counts
  };
  if (!countOnly) {
    var n = measures.length, a = cell2.agg = Array(n), i = 0;
    for (; i < n; ++i)
      a[i] = new measures[i](cell2);
  }
  if (cell2.store) {
    var store = cell2.data = new TupleStore();
  }
  cell2.add = function(t) {
    cell2.num += 1;
    if (countOnly)
      return;
    if (store)
      store.add(t);
    for (let i2 = 0; i2 < n; ++i2) {
      a[i2].add(a[i2].get(t), t);
    }
  };
  cell2.rem = function(t) {
    cell2.num -= 1;
    if (countOnly)
      return;
    if (store)
      store.rem(t);
    for (let i2 = 0; i2 < n; ++i2) {
      a[i2].rem(a[i2].get(t), t);
    }
  };
  cell2.set = function(t) {
    let i2, n2;
    if (store)
      store.values();
    for (i2 = 0, n2 = counts.length; i2 < n2; ++i2)
      t[counts[i2]] = cell2.num;
    if (!countOnly)
      for (i2 = 0, n2 = a.length; i2 < n2; ++i2)
        a[i2].set(t);
  };
  cell2.init = function() {
    cell2.num = 0;
    if (store)
      store.reset();
    for (let i2 = 0; i2 < n; ++i2)
      a[i2].init();
  };
  return cell2;
}
function Window(params2) {
  Transform.call(this, {}, params2);
  this._mlen = 0;
  this._mods = [];
}
Window.Definition = {
  "type": "Window",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "sort",
    "type": "compare"
  }, {
    "name": "groupby",
    "type": "field",
    "array": true
  }, {
    "name": "ops",
    "type": "enum",
    "array": true,
    "values": ValidWindowOps.concat(ValidAggregateOps)
  }, {
    "name": "params",
    "type": "number",
    "null": true,
    "array": true
  }, {
    "name": "aggregate_params",
    "type": "number",
    "null": true,
    "array": true
  }, {
    "name": "fields",
    "type": "field",
    "null": true,
    "array": true
  }, {
    "name": "as",
    "type": "string",
    "null": true,
    "array": true
  }, {
    "name": "frame",
    "type": "number",
    "null": true,
    "array": true,
    "length": 2,
    "default": [null, 0]
  }, {
    "name": "ignorePeers",
    "type": "boolean",
    "default": false
  }]
};
inherits(Window, Transform, {
  transform(_, pulse2) {
    this.stamp = pulse2.stamp;
    const mod = _.modified(), cmp = stableCompare(_.sort), key2 = groupkey(_.groupby), group2 = (t) => this.group(key2(t));
    let state = this.state;
    if (!state || mod) {
      state = this.state = new WindowState(_);
    }
    if (mod || pulse2.modified(state.inputs)) {
      this.value = {};
      pulse2.visit(pulse2.SOURCE, (t) => group2(t).add(t));
    } else {
      pulse2.visit(pulse2.REM, (t) => group2(t).remove(t));
      pulse2.visit(pulse2.ADD, (t) => group2(t).add(t));
    }
    for (let i = 0, n = this._mlen; i < n; ++i) {
      processPartition(this._mods[i], state, cmp, _);
    }
    this._mlen = 0;
    this._mods = [];
    return pulse2.reflow(mod).modifies(state.outputs);
  },
  group(key2) {
    let group2 = this.value[key2];
    if (!group2) {
      group2 = this.value[key2] = SortedList(tupleid);
      group2.stamp = -1;
    }
    if (group2.stamp < this.stamp) {
      group2.stamp = this.stamp;
      this._mods[this._mlen++] = group2;
    }
    return group2;
  }
});
function processPartition(list, state, cmp, _) {
  const sort2 = _.sort, range4 = sort2 && !_.ignorePeers, frame = _.frame || [null, 0], data3 = list.data(cmp), n = data3.length, b2 = range4 ? bisector(sort2) : null, w3 = {
    i0: 0,
    i1: 0,
    p0: 0,
    p1: 0,
    index: 0,
    data: data3,
    compare: sort2 || constant(-1)
  };
  state.init();
  for (let i = 0; i < n; ++i) {
    setWindow(w3, frame, i, n);
    if (range4)
      adjustRange(w3, b2);
    state.update(w3, data3[i]);
  }
}
function setWindow(w3, f, i, n) {
  w3.p0 = w3.i0;
  w3.p1 = w3.i1;
  w3.i0 = f[0] == null ? 0 : Math.max(0, i - Math.abs(f[0]));
  w3.i1 = f[1] == null ? n : Math.min(n, i + Math.abs(f[1]) + 1);
  w3.index = i;
}
function adjustRange(w3, bisect2) {
  const r0 = w3.i0, r1 = w3.i1 - 1, c = w3.compare, d = w3.data, n = d.length - 1;
  if (r0 > 0 && !c(d[r0], d[r0 - 1]))
    w3.i0 = bisect2.left(d, d[r0]);
  if (r1 < n && !c(d[r1], d[r1 + 1]))
    w3.i1 = bisect2.right(d, d[r1]);
}

// node_modules/vega-view-transforms/build/vega-view-transforms.module.js
var vega_view_transforms_module_exports = {};
__export(vega_view_transforms_module_exports, {
  bound: () => Bound,
  identifier: () => Identifier,
  mark: () => Mark,
  overlap: () => Overlap,
  render: () => Render,
  viewlayout: () => ViewLayout
});

// node_modules/vega-canvas/build/vega-canvas.browser.module.js
function domCanvas(w3, h2) {
  if (typeof document !== "undefined" && document.createElement) {
    const c = document.createElement("canvas");
    if (c && c.getContext) {
      c.width = w3;
      c.height = h2;
      return c;
    }
  }
  return null;
}
var domImage = () => typeof Image !== "undefined" ? Image : null;

// node_modules/vega-scale/build/vega-scale.module.js
function bandSpace(count, paddingInner, paddingOuter) {
  const space = count - paddingInner + paddingOuter * 2;
  return count ? space > 0 ? space : 1 : 0;
}
var Identity = "identity";
var Linear = "linear";
var Log = "log";
var Pow = "pow";
var Sqrt = "sqrt";
var Symlog = "symlog";
var Time = "time";
var UTC = "utc";
var Sequential = "sequential";
var Diverging = "diverging";
var Quantile2 = "quantile";
var Quantize = "quantize";
var Threshold = "threshold";
var Ordinal = "ordinal";
var Point = "point";
var Band = "band";
var BinOrdinal = "bin-ordinal";
var Continuous = "continuous";
var Discrete = "discrete";
var Discretizing = "discretizing";
var Interpolating = "interpolating";
var Temporal = "temporal";
function invertRange(scale6) {
  return function(_) {
    let lo = _[0], hi = _[1], t;
    if (hi < lo) {
      t = lo;
      lo = hi;
      hi = t;
    }
    return [scale6.invert(lo), scale6.invert(hi)];
  };
}
function invertRangeExtent(scale6) {
  return function(_) {
    const range4 = scale6.range();
    let lo = _[0], hi = _[1], min4 = -1, max4, t, i, n;
    if (hi < lo) {
      t = lo;
      lo = hi;
      hi = t;
    }
    for (i = 0, n = range4.length; i < n; ++i) {
      if (range4[i] >= lo && range4[i] <= hi) {
        if (min4 < 0)
          min4 = i;
        max4 = i;
      }
    }
    if (min4 < 0)
      return void 0;
    lo = scale6.invertExtent(range4[min4]);
    hi = scale6.invertExtent(range4[max4]);
    return [lo[0] === void 0 ? lo[1] : lo[0], hi[1] === void 0 ? hi[0] : hi[1]];
  };
}
function band() {
  const scale6 = ordinal().unknown(void 0), domain2 = scale6.domain, ordinalRange = scale6.range;
  let range$1 = [0, 1], step, bandwidth2, round2 = false, paddingInner = 0, paddingOuter = 0, align = 0.5;
  delete scale6.unknown;
  function rescale() {
    const n = domain2().length, reverse2 = range$1[1] < range$1[0], stop2 = range$1[1 - reverse2], space = bandSpace(n, paddingInner, paddingOuter);
    let start = range$1[reverse2 - 0];
    step = (stop2 - start) / (space || 1);
    if (round2) {
      step = Math.floor(step);
    }
    start += (stop2 - start - step * (n - paddingInner)) * align;
    bandwidth2 = step * (1 - paddingInner);
    if (round2) {
      start = Math.round(start);
      bandwidth2 = Math.round(bandwidth2);
    }
    const values2 = range(n).map((i) => start + step * i);
    return ordinalRange(reverse2 ? values2.reverse() : values2);
  }
  scale6.domain = function(_) {
    if (arguments.length) {
      domain2(_);
      return rescale();
    } else {
      return domain2();
    }
  };
  scale6.range = function(_) {
    if (arguments.length) {
      range$1 = [+_[0], +_[1]];
      return rescale();
    } else {
      return range$1.slice();
    }
  };
  scale6.rangeRound = function(_) {
    range$1 = [+_[0], +_[1]];
    round2 = true;
    return rescale();
  };
  scale6.bandwidth = function() {
    return bandwidth2;
  };
  scale6.step = function() {
    return step;
  };
  scale6.round = function(_) {
    if (arguments.length) {
      round2 = !!_;
      return rescale();
    } else {
      return round2;
    }
  };
  scale6.padding = function(_) {
    if (arguments.length) {
      paddingOuter = Math.max(0, Math.min(1, _));
      paddingInner = paddingOuter;
      return rescale();
    } else {
      return paddingInner;
    }
  };
  scale6.paddingInner = function(_) {
    if (arguments.length) {
      paddingInner = Math.max(0, Math.min(1, _));
      return rescale();
    } else {
      return paddingInner;
    }
  };
  scale6.paddingOuter = function(_) {
    if (arguments.length) {
      paddingOuter = Math.max(0, Math.min(1, _));
      return rescale();
    } else {
      return paddingOuter;
    }
  };
  scale6.align = function(_) {
    if (arguments.length) {
      align = Math.max(0, Math.min(1, _));
      return rescale();
    } else {
      return align;
    }
  };
  scale6.invertRange = function(_) {
    if (_[0] == null || _[1] == null)
      return;
    const reverse2 = range$1[1] < range$1[0], values2 = reverse2 ? ordinalRange().reverse() : ordinalRange(), n = values2.length - 1;
    let lo = +_[0], hi = +_[1], a, b2, t;
    if (lo !== lo || hi !== hi)
      return;
    if (hi < lo) {
      t = lo;
      lo = hi;
      hi = t;
    }
    if (hi < values2[0] || lo > range$1[1 - reverse2])
      return;
    a = Math.max(0, bisectRight(values2, lo) - 1);
    b2 = lo === hi ? a : bisectRight(values2, hi) - 1;
    if (lo - values2[a] > bandwidth2 + 1e-10)
      ++a;
    if (reverse2) {
      t = a;
      a = n - b2;
      b2 = n - t;
    }
    return a > b2 ? void 0 : domain2().slice(a, b2 + 1);
  };
  scale6.invert = function(_) {
    const value3 = scale6.invertRange([_, _]);
    return value3 ? value3[0] : value3;
  };
  scale6.copy = function() {
    return band().domain(domain2()).range(range$1).round(round2).paddingInner(paddingInner).paddingOuter(paddingOuter).align(align);
  };
  return rescale();
}
function pointish(scale6) {
  const copy2 = scale6.copy;
  scale6.padding = scale6.paddingOuter;
  delete scale6.paddingInner;
  scale6.copy = function() {
    return pointish(copy2());
  };
  return scale6;
}
function point() {
  return pointish(band().paddingInner(1));
}
var map = Array.prototype.map;
function numbers2(_) {
  return map.call(_, toNumber);
}
var slice = Array.prototype.slice;
function scaleBinOrdinal() {
  let domain2 = [], range4 = [];
  function scale6(x2) {
    return x2 == null || x2 !== x2 ? void 0 : range4[(bisect_default(domain2, x2) - 1) % range4.length];
  }
  scale6.domain = function(_) {
    if (arguments.length) {
      domain2 = numbers2(_);
      return scale6;
    } else {
      return domain2.slice();
    }
  };
  scale6.range = function(_) {
    if (arguments.length) {
      range4 = slice.call(_);
      return scale6;
    } else {
      return range4.slice();
    }
  };
  scale6.tickFormat = function(count, specifier) {
    return tickFormat(domain2[0], peek(domain2), count == null ? 10 : count, specifier);
  };
  scale6.copy = function() {
    return scaleBinOrdinal().domain(scale6.domain()).range(scale6.range());
  };
  return scale6;
}
var scales = /* @__PURE__ */ new Map();
var VEGA_SCALE = Symbol("vega_scale");
function registerScale(scale6) {
  scale6[VEGA_SCALE] = true;
  return scale6;
}
function isRegisteredScale(scale6) {
  return scale6 && scale6[VEGA_SCALE] === true;
}
function create(type2, constructor, metadata2) {
  const ctr = function scale6() {
    const s = constructor();
    if (!s.invertRange) {
      s.invertRange = s.invert ? invertRange(s) : s.invertExtent ? invertRangeExtent(s) : void 0;
    }
    s.type = type2;
    return registerScale(s);
  };
  ctr.metadata = toSet(array(metadata2));
  return ctr;
}
function scale(type2, scale6, metadata2) {
  if (arguments.length > 1) {
    scales.set(type2, create(type2, scale6, metadata2));
    return this;
  } else {
    return isValidScaleType(type2) ? scales.get(type2) : void 0;
  }
}
scale(Identity, identity);
scale(Linear, linear, Continuous);
scale(Log, log, [Continuous, Log]);
scale(Pow, pow, Continuous);
scale(Sqrt, sqrt, Continuous);
scale(Symlog, symlog, Continuous);
scale(Time, time, [Continuous, Temporal]);
scale(UTC, utcTime, [Continuous, Temporal]);
scale(Sequential, sequential, [Continuous, Interpolating]);
scale(`${Sequential}-${Linear}`, sequential, [Continuous, Interpolating]);
scale(`${Sequential}-${Log}`, sequentialLog, [Continuous, Interpolating, Log]);
scale(`${Sequential}-${Pow}`, sequentialPow, [Continuous, Interpolating]);
scale(`${Sequential}-${Sqrt}`, sequentialSqrt, [Continuous, Interpolating]);
scale(`${Sequential}-${Symlog}`, sequentialSymlog, [Continuous, Interpolating]);
scale(`${Diverging}-${Linear}`, diverging, [Continuous, Interpolating]);
scale(`${Diverging}-${Log}`, divergingLog, [Continuous, Interpolating, Log]);
scale(`${Diverging}-${Pow}`, divergingPow, [Continuous, Interpolating]);
scale(`${Diverging}-${Sqrt}`, divergingSqrt, [Continuous, Interpolating]);
scale(`${Diverging}-${Symlog}`, divergingSymlog, [Continuous, Interpolating]);
scale(Quantile2, quantile2, [Discretizing, Quantile2]);
scale(Quantize, quantize, Discretizing);
scale(Threshold, threshold, Discretizing);
scale(BinOrdinal, scaleBinOrdinal, [Discrete, Discretizing]);
scale(Ordinal, ordinal, Discrete);
scale(Band, band, Discrete);
scale(Point, point, Discrete);
function isValidScaleType(type2) {
  return scales.has(type2);
}
function hasType(key2, type2) {
  const s = scales.get(key2);
  return s && s.metadata[type2];
}
function isContinuous(key2) {
  return hasType(key2, Continuous);
}
function isDiscrete(key2) {
  return hasType(key2, Discrete);
}
function isDiscretizing(key2) {
  return hasType(key2, Discretizing);
}
function isLogarithmic(key2) {
  return hasType(key2, Log);
}
function isTemporal(key2) {
  return hasType(key2, Temporal);
}
function isInterpolating(key2) {
  return hasType(key2, Interpolating);
}
function isQuantile(key2) {
  return hasType(key2, Quantile2);
}
var scaleProps = ["clamp", "base", "constant", "exponent"];
function interpolateRange(interpolator, range4) {
  const start = range4[0], span2 = peek(range4) - start;
  return function(i) {
    return interpolator(start + i * span2);
  };
}
function interpolateColors(colors2, type2, gamma) {
  return piecewise(interpolate(type2 || "rgb", gamma), colors2);
}
function quantizeInterpolator(interpolator, count) {
  const samples = new Array(count), n = count + 1;
  for (let i = 0; i < count; )
    samples[i] = interpolator(++i / n);
  return samples;
}
function scaleFraction(scale$12, min4, max4) {
  const delta = max4 - min4;
  let i, t, s;
  if (!delta || !Number.isFinite(delta)) {
    return constant(0.5);
  } else {
    i = (t = scale$12.type).indexOf("-");
    t = i < 0 ? t : t.slice(i + 1);
    s = scale(t)().domain([min4, max4]).range([0, 1]);
    scaleProps.forEach((m) => scale$12[m] ? s[m](scale$12[m]()) : 0);
    return s;
  }
}
function interpolate(type2, gamma) {
  const interp = src_exports[method(type2)];
  return gamma != null && interp && interp.gamma ? interp.gamma(gamma) : interp;
}
function method(type2) {
  return "interpolate" + type2.toLowerCase().split("-").map((s) => s[0].toUpperCase() + s.slice(1)).join("");
}
var continuous = {
  blues: "cfe1f2bed8eca8cee58fc1de74b2d75ba3cf4592c63181bd206fb2125ca40a4a90",
  greens: "d3eecdc0e6baabdda594d3917bc77d60ba6c46ab5e329a512089430e7735036429",
  greys: "e2e2e2d4d4d4c4c4c4b1b1b19d9d9d8888887575756262624d4d4d3535351e1e1e",
  oranges: "fdd8b3fdc998fdb87bfda55efc9244f87f2cf06b18e4580bd14904b93d029f3303",
  purples: "e2e1efd4d4e8c4c5e0b4b3d6a3a0cc928ec3827cb97566ae684ea25c3696501f8c",
  reds: "fdc9b4fcb49afc9e80fc8767fa7051f6573fec3f2fdc2a25c81b1db21218970b13",
  blueGreen: "d5efedc1e8e0a7ddd18bd2be70c6a958ba9144ad77319c5d2089460e7736036429",
  bluePurple: "ccddecbad0e4a8c2dd9ab0d4919cc98d85be8b6db28a55a6873c99822287730f71",
  greenBlue: "d3eecec5e8c3b1e1bb9bd8bb82cec269c2ca51b2cd3c9fc7288abd1675b10b60a1",
  orangeRed: "fddcaffdcf9bfdc18afdad77fb9562f67d53ee6545e24932d32d1ebf130da70403",
  purpleBlue: "dbdaebc8cee4b1c3de97b7d87bacd15b9fc93a90c01e7fb70b70ab056199045281",
  purpleBlueGreen: "dbd8eac8cee4b0c3de93b7d872acd1549fc83892bb1c88a3097f8702736b016353",
  purpleRed: "dcc9e2d3b3d7ce9eccd186c0da6bb2e14da0e23189d91e6fc61159ab07498f023a",
  redPurple: "fccfccfcbec0faa9b8f98faff571a5ec539ddb3695c41b8aa908808d0179700174",
  yellowGreen: "e4f4acd1eca0b9e2949ed68880c97c62bb6e47aa5e3297502083440e723b036034",
  yellowOrangeBrown: "feeaa1fedd84fecc63feb746fca031f68921eb7215db5e0bc54c05ab3d038f3204",
  yellowOrangeRed: "fee087fed16ffebd59fea849fd903efc7335f9522bee3423de1b20ca0b22af0225",
  blueOrange: "134b852f78b35da2cb9dcae1d2e5eff2f0ebfce0bafbbf74e8932fc5690d994a07",
  brownBlueGreen: "704108a0651ac79548e3c78af3e6c6eef1eac9e9e48ed1c74da79e187a72025147",
  purpleGreen: "5b1667834792a67fb6c9aed3e6d6e8eff0efd9efd5aedda971bb75368e490e5e29",
  purpleOrange: "4114696647968f83b7b9b4d6dadbebf3eeeafce0bafbbf74e8932fc5690d994a07",
  redBlue: "8c0d25bf363adf745ef4ae91fbdbc9f2efeed2e5ef9dcae15da2cb2f78b3134b85",
  redGrey: "8c0d25bf363adf745ef4ae91fcdccbfaf4f1e2e2e2c0c0c0969696646464343434",
  yellowGreenBlue: "eff9bddbf1b4bde5b594d5b969c5be45b4c22c9ec02182b82163aa23479c1c3185",
  redYellowBlue: "a50026d4322cf16e43fcac64fedd90faf8c1dcf1ecabd6e875abd04a74b4313695",
  redYellowGreen: "a50026d4322cf16e43fcac63fedd8df9f7aed7ee8ea4d86e64bc6122964f006837",
  pinkYellowGreen: "8e0152c0267edd72adf0b3d6faddedf5f3efe1f2cab6de8780bb474f9125276419",
  spectral: "9e0142d13c4bf0704afcac63fedd8dfbf8b0e0f3a1a9dda269bda94288b55e4fa2",
  viridis: "440154470e61481a6c482575472f7d443a834144873d4e8a39568c35608d31688e2d708e2a788e27818e23888e21918d1f988b1fa08822a8842ab07f35b77943bf7154c56866cc5d7ad1518fd744a5db36bcdf27d2e21be9e51afde725",
  magma: "0000040404130b0924150e3720114b2c11603b0f704a107957157e651a80721f817f24828c29819a2e80a8327db6377ac43c75d1426fde4968e95462f1605df76f5cfa7f5efc8f65fe9f6dfeaf78febf84fece91fddea0fcedaffcfdbf",
  inferno: "0000040403130c0826170c3b240c4f330a5f420a68500d6c5d126e6b176e781c6d86216b932667a12b62ae305cbb3755c73e4cd24644dd513ae65c30ed6925f3771af8850ffb9506fca50afcb519fac62df6d645f2e661f3f484fcffa4",
  plasma: "0d088723069033059742039d5002a25d01a66a00a87801a88405a7900da49c179ea72198b12a90ba3488c33d80cb4779d35171da5a69e16462e76e5bed7953f2834cf68f44fa9a3dfca636fdb32ffec029fcce25f9dc24f5ea27f0f921",
  cividis: "00205100235800265d002961012b65042e670831690d346b11366c16396d1c3c6e213f6e26426e2c456e31476e374a6e3c4d6e42506e47536d4c566d51586e555b6e5a5e6e5e616e62646f66676f6a6a706e6d717270717573727976737c79747f7c75827f758682768985778c8877908b78938e789691789a94789e9778a19b78a59e77a9a177aea575b2a874b6ab73bbaf71c0b26fc5b66dc9b96acebd68d3c065d8c462ddc85fe2cb5ce7cf58ebd355f0d652f3da4ff7de4cfae249fce647",
  rainbow: "6e40aa883eb1a43db3bf3cafd83fa4ee4395fe4b83ff576eff6659ff7847ff8c38f3a130e2b72fcfcc36bee044aff05b8ff4576ff65b52f6673af27828ea8d1ddfa319d0b81cbecb23abd82f96e03d82e14c6edb5a5dd0664dbf6e40aa",
  sinebow: "ff4040fc582af47218e78d0bd5a703bfbf00a7d5038de70b72f41858fc2a40ff402afc5818f4720be78d03d5a700bfbf03a7d50b8de71872f42a58fc4040ff582afc7218f48d0be7a703d5bf00bfd503a7e70b8df41872fc2a58ff4040",
  turbo: "23171b32204a3e2a71453493493eae4b49c54a53d7485ee44569ee4074f53c7ff8378af93295f72e9ff42ba9ef28b3e926bce125c5d925cdcf27d5c629dcbc2de3b232e9a738ee9d3ff39347f68950f9805afc7765fd6e70fe667cfd5e88fc5795fb51a1f84badf545b9f140c5ec3cd0e637dae034e4d931ecd12ef4c92bfac029ffb626ffad24ffa223ff9821ff8d1fff821dff771cfd6c1af76118f05616e84b14df4111d5380fcb2f0dc0260ab61f07ac1805a313029b0f00950c00910b00",
  browns: "eedbbdecca96e9b97ae4a865dc9856d18954c7784cc0673fb85536ad44339f3632",
  tealBlues: "bce4d89dd3d181c3cb65b3c245a2b9368fae347da0306a932c5985",
  teals: "bbdfdfa2d4d58ac9c975bcbb61b0af4da5a43799982b8b8c1e7f7f127273006667",
  warmGreys: "dcd4d0cec5c1c0b8b4b3aaa7a59c9998908c8b827f7e7673726866665c5a59504e",
  goldGreen: "f4d166d5ca60b6c35c98bb597cb25760a6564b9c533f8f4f33834a257740146c36",
  goldOrange: "f4d166f8be5cf8aa4cf5983bf3852aef701be2621fd65322c54923b142239e3a26",
  goldRed: "f4d166f6be59f9aa51fc964ef6834bee734ae56249db5247cf4244c43141b71d3e",
  lightGreyRed: "efe9e6e1dad7d5cbc8c8bdb9bbaea9cd967ddc7b43e15f19df4011dc000b",
  lightGreyTeal: "e4eaead6dcddc8ced2b7c2c7a6b4bc64b0bf22a6c32295c11f85be1876bc",
  lightMulti: "e0f1f2c4e9d0b0de9fd0e181f6e072f6c053f3993ef77440ef4a3c",
  lightOrange: "f2e7daf7d5baf9c499fab184fa9c73f68967ef7860e8645bde515bd43d5b",
  lightTealBlue: "e3e9e0c0dccf9aceca7abfc859afc0389fb9328dad2f7ca0276b95255988",
  darkBlue: "3232322d46681a5c930074af008cbf05a7ce25c0dd38daed50f3faffffff",
  darkGold: "3c3c3c584b37725e348c7631ae8b2bcfa424ecc31ef9de30fff184ffffff",
  darkGreen: "3a3a3a215748006f4d048942489e4276b340a6c63dd2d836ffeb2cffffaa",
  darkMulti: "3737371f5287197d8c29a86995ce3fffe800ffffff",
  darkRed: "3434347036339e3c38cc4037e75d1eec8620eeab29f0ce32ffeb2c"
};
var discrete = {
  category10: "1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf",
  category20: "1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5",
  category20b: "393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6",
  category20c: "3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9",
  tableau10: "4c78a8f58518e4575672b7b254a24beeca3bb279a2ff9da69d755dbab0ac",
  tableau20: "4c78a89ecae9f58518ffbf7954a24b88d27ab79a20f2cf5b43989483bcb6e45756ff9d9879706ebab0acd67195fcbfd2b279a2d6a5c99e765fd8b5a5",
  accent: "7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666",
  dark2: "1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666",
  paired: "a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928",
  pastel1: "fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2",
  pastel2: "b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc",
  set1: "e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999",
  set2: "66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3",
  set3: "8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f"
};
function colors(palette) {
  const n = palette.length / 6 | 0, c = new Array(n);
  for (let i = 0; i < n; ) {
    c[i] = "#" + palette.slice(i * 6, ++i * 6);
  }
  return c;
}
function apply(_, f) {
  for (const k2 in _)
    scheme(k2, f(_[k2]));
}
var schemes = {};
apply(discrete, colors);
apply(continuous, (_) => interpolateColors(colors(_)));
function scheme(name, scheme2) {
  name = name && name.toLowerCase();
  if (arguments.length > 1) {
    schemes[name] = scheme2;
    return this;
  } else {
    return schemes[name];
  }
}
var SymbolLegend = "symbol";
var DiscreteLegend = "discrete";
var GradientLegend = "gradient";
var defaultFormatter = (value3) => isArray(value3) ? value3.map((v) => String(v)) : String(value3);
var ascending3 = (a, b2) => a[1] - b2[1];
var descending = (a, b2) => b2[1] - a[1];
function tickCount(scale6, count, minStep) {
  let step;
  if (isNumber(count)) {
    if (scale6.bins) {
      count = Math.max(count, scale6.bins.length);
    }
    if (minStep != null) {
      count = Math.min(count, Math.floor(span(scale6.domain()) / minStep || 1) + 1);
    }
  }
  if (isObject(count)) {
    step = count.step;
    count = count.interval;
  }
  if (isString(count)) {
    count = scale6.type === Time ? timeInterval(count) : scale6.type == UTC ? utcInterval(count) : error("Only time and utc scales accept interval strings.");
    if (step)
      count = count.every(step);
  }
  return count;
}
function validTicks(scale6, ticks, count) {
  let range4 = scale6.range(), lo = range4[0], hi = peek(range4), cmp = ascending3;
  if (lo > hi) {
    range4 = hi;
    hi = lo;
    lo = range4;
    cmp = descending;
  }
  lo = Math.floor(lo);
  hi = Math.ceil(hi);
  ticks = ticks.map((v) => [v, scale6(v)]).filter((_) => lo <= _[1] && _[1] <= hi).sort(cmp).map((_) => _[0]);
  if (count > 0 && ticks.length > 1) {
    const endpoints = [ticks[0], peek(ticks)];
    while (ticks.length > count && ticks.length >= 3) {
      ticks = ticks.filter((_, i) => !(i % 2));
    }
    if (ticks.length < 3) {
      ticks = endpoints;
    }
  }
  return ticks;
}
function tickValues(scale6, count) {
  return scale6.bins ? validTicks(scale6, scale6.bins) : scale6.ticks ? scale6.ticks(count) : scale6.domain();
}
function tickFormat2(locale2, scale6, count, specifier, formatType, noSkip) {
  const type2 = scale6.type;
  let format5 = defaultFormatter;
  if (type2 === Time || formatType === Time) {
    format5 = locale2.timeFormat(specifier);
  } else if (type2 === UTC || formatType === UTC) {
    format5 = locale2.utcFormat(specifier);
  } else if (isLogarithmic(type2)) {
    const varfmt = locale2.formatFloat(specifier);
    if (noSkip || scale6.bins) {
      format5 = varfmt;
    } else {
      const test2 = tickLog(scale6, count, false);
      format5 = (_) => test2(_) ? varfmt(_) : "";
    }
  } else if (scale6.tickFormat) {
    const d = scale6.domain();
    format5 = locale2.formatSpan(d[0], d[d.length - 1], count, specifier);
  } else if (specifier) {
    format5 = locale2.format(specifier);
  }
  return format5;
}
function tickLog(scale6, count, values2) {
  const ticks = tickValues(scale6, count), base2 = scale6.base(), logb = Math.log(base2), k2 = Math.max(1, base2 * count / ticks.length);
  const test2 = (d) => {
    let i = d / Math.pow(base2, Math.round(Math.log(d) / logb));
    if (i * base2 < base2 - 0.5)
      i *= base2;
    return i <= k2;
  };
  return values2 ? ticks.filter(test2) : test2;
}
var symbols = {
  [Quantile2]: "quantiles",
  [Quantize]: "thresholds",
  [Threshold]: "domain"
};
var formats2 = {
  [Quantile2]: "quantiles",
  [Quantize]: "domain"
};
function labelValues(scale6, count) {
  return scale6.bins ? binValues(scale6.bins) : scale6.type === Log ? tickLog(scale6, count, true) : symbols[scale6.type] ? thresholdValues(scale6[symbols[scale6.type]]()) : tickValues(scale6, count);
}
function thresholdFormat(locale2, scale6, specifier) {
  const _ = scale6[formats2[scale6.type]](), n = _.length;
  let d = n > 1 ? _[1] - _[0] : _[0], i;
  for (i = 1; i < n; ++i) {
    d = Math.min(d, _[i] - _[i - 1]);
  }
  return locale2.formatSpan(0, d, 3 * 10, specifier);
}
function thresholdValues(thresholds) {
  const values2 = [-Infinity].concat(thresholds);
  values2.max = Infinity;
  return values2;
}
function binValues(bins) {
  const values2 = bins.slice(0, -1);
  values2.max = peek(bins);
  return values2;
}
var isDiscreteRange = (scale6) => symbols[scale6.type] || scale6.bins;
function labelFormat(locale2, scale6, count, type2, specifier, formatType, noSkip) {
  const format5 = formats2[scale6.type] && formatType !== Time && formatType !== UTC ? thresholdFormat(locale2, scale6, specifier) : tickFormat2(locale2, scale6, count, specifier, formatType, noSkip);
  return type2 === SymbolLegend && isDiscreteRange(scale6) ? formatRange(format5) : type2 === DiscreteLegend ? formatDiscrete(format5) : formatPoint(format5);
}
var formatRange = (format5) => (value3, index2, array4) => {
  const limit = get2(array4[index2 + 1], get2(array4.max, Infinity)), lo = formatValue(value3, format5), hi = formatValue(limit, format5);
  return lo && hi ? lo + " – " + hi : hi ? "< " + hi : "≥ " + lo;
};
var get2 = (value3, dflt) => value3 != null ? value3 : dflt;
var formatDiscrete = (format5) => (value3, index2) => index2 ? format5(value3) : null;
var formatPoint = (format5) => (value3) => format5(value3);
var formatValue = (value3, format5) => Number.isFinite(value3) ? format5(value3) : null;
function labelFraction(scale6) {
  const domain2 = scale6.domain(), count = domain2.length - 1;
  let lo = +domain2[0], hi = +peek(domain2), span2 = hi - lo;
  if (scale6.type === Threshold) {
    const adjust = count ? span2 / count : 0.1;
    lo -= adjust;
    hi += adjust;
    span2 = hi - lo;
  }
  return (value3) => (value3 - lo) / span2;
}
function format3(locale2, scale6, specifier, formatType) {
  const type2 = formatType || scale6.type;
  if (isString(specifier) && isTemporal(type2)) {
    specifier = specifier.replace(/%a/g, "%A").replace(/%b/g, "%B");
  }
  return !specifier && type2 === Time ? locale2.timeFormat("%A, %d %B %Y, %X") : !specifier && type2 === UTC ? locale2.utcFormat("%A, %d %B %Y, %X UTC") : labelFormat(locale2, scale6, 5, null, specifier, formatType, true);
}
function domainCaption(locale2, scale6, opt) {
  opt = opt || {};
  const max4 = Math.max(3, opt.maxlen || 7), fmt = format3(locale2, scale6, opt.format, opt.formatType);
  if (isDiscretizing(scale6.type)) {
    const v = labelValues(scale6).slice(1).map(fmt), n = v.length;
    return `${n} boundar${n === 1 ? "y" : "ies"}: ${v.join(", ")}`;
  } else if (isDiscrete(scale6.type)) {
    const d = scale6.domain(), n = d.length, v = n > max4 ? d.slice(0, max4 - 2).map(fmt).join(", ") + ", ending with " + d.slice(-1).map(fmt) : d.map(fmt).join(", ");
    return `${n} value${n === 1 ? "" : "s"}: ${v}`;
  } else {
    const d = scale6.domain();
    return `values from ${fmt(d[0])} to ${fmt(peek(d))}`;
  }
}

// node_modules/vega-scenegraph/build/vega-scenegraph.module.js
var gradient_id = 0;
function resetSVGGradientId() {
  gradient_id = 0;
}
var patternPrefix = "p_";
function isGradient(value3) {
  return value3 && value3.gradient;
}
function gradientRef(g, defs, base2) {
  const type2 = g.gradient;
  let id2 = g.id, prefix = type2 === "radial" ? patternPrefix : "";
  if (!id2) {
    id2 = g.id = "gradient_" + gradient_id++;
    if (type2 === "radial") {
      g.x1 = get3(g.x1, 0.5);
      g.y1 = get3(g.y1, 0.5);
      g.r1 = get3(g.r1, 0);
      g.x2 = get3(g.x2, 0.5);
      g.y2 = get3(g.y2, 0.5);
      g.r2 = get3(g.r2, 0.5);
      prefix = patternPrefix;
    } else {
      g.x1 = get3(g.x1, 0);
      g.y1 = get3(g.y1, 0);
      g.x2 = get3(g.x2, 1);
      g.y2 = get3(g.y2, 0);
    }
  }
  defs[id2] = g;
  return "url(" + (base2 || "") + "#" + prefix + id2 + ")";
}
function get3(val, def2) {
  return val != null ? val : def2;
}
function Gradient(p0, p1) {
  var stops = [], gradient3;
  return gradient3 = {
    gradient: "linear",
    x1: p0 ? p0[0] : 0,
    y1: p0 ? p0[1] : 0,
    x2: p1 ? p1[0] : 1,
    y2: p1 ? p1[1] : 0,
    stops,
    stop: function(offset4, color3) {
      stops.push({
        offset: offset4,
        color: color3
      });
      return gradient3;
    }
  };
}
var lookup = {
  "basis": {
    curve: basis_default
  },
  "basis-closed": {
    curve: basisClosed_default
  },
  "basis-open": {
    curve: basisOpen_default
  },
  "bundle": {
    curve: bundle_default,
    tension: "beta",
    value: 0.85
  },
  "cardinal": {
    curve: cardinal_default,
    tension: "tension",
    value: 0
  },
  "cardinal-open": {
    curve: cardinalOpen_default,
    tension: "tension",
    value: 0
  },
  "cardinal-closed": {
    curve: cardinalClosed_default,
    tension: "tension",
    value: 0
  },
  "catmull-rom": {
    curve: catmullRom_default,
    tension: "alpha",
    value: 0.5
  },
  "catmull-rom-closed": {
    curve: catmullRomClosed_default,
    tension: "alpha",
    value: 0.5
  },
  "catmull-rom-open": {
    curve: catmullRomOpen_default,
    tension: "alpha",
    value: 0.5
  },
  "linear": {
    curve: linear_default
  },
  "linear-closed": {
    curve: linearClosed_default
  },
  "monotone": {
    horizontal: monotoneY,
    vertical: monotoneX
  },
  "natural": {
    curve: natural_default
  },
  "step": {
    curve: step_default
  },
  "step-after": {
    curve: stepAfter
  },
  "step-before": {
    curve: stepBefore
  }
};
function curves(type2, orientation, tension) {
  var entry2 = has(lookup, type2) && lookup[type2], curve2 = null;
  if (entry2) {
    curve2 = entry2.curve || entry2[orientation || "vertical"];
    if (entry2.tension && tension != null) {
      curve2 = curve2[entry2.tension](tension);
    }
  }
  return curve2;
}
var paramCounts = {
  m: 2,
  l: 2,
  h: 1,
  v: 1,
  z: 0,
  c: 6,
  s: 4,
  q: 4,
  t: 2,
  a: 7
};
var commandPattern = /[mlhvzcsqta]([^mlhvzcsqta]+|$)/gi;
var numberPattern = /^[+-]?(([0-9]*\.[0-9]+)|([0-9]+\.)|([0-9]+))([eE][+-]?[0-9]+)?/;
var spacePattern = /^((\s+,?\s*)|(,\s*))/;
var flagPattern = /^[01]/;
function parse4(path3) {
  const commands = [];
  const matches = path3.match(commandPattern) || [];
  matches.forEach((str) => {
    let cmd = str[0];
    const type2 = cmd.toLowerCase();
    const paramCount = paramCounts[type2];
    const params2 = parseParams(type2, paramCount, str.slice(1).trim());
    const count = params2.length;
    if (count < paramCount || count && count % paramCount !== 0) {
      throw Error("Invalid SVG path, incorrect parameter count");
    }
    commands.push([cmd, ...params2.slice(0, paramCount)]);
    if (count === paramCount) {
      return;
    }
    if (type2 === "m") {
      cmd = cmd === "M" ? "L" : "l";
    }
    for (let i = paramCount; i < count; i += paramCount) {
      commands.push([cmd, ...params2.slice(i, i + paramCount)]);
    }
  });
  return commands;
}
function parseParams(type2, paramCount, segment) {
  const params2 = [];
  for (let index2 = 0; paramCount && index2 < segment.length; ) {
    for (let i = 0; i < paramCount; ++i) {
      const pattern = type2 === "a" && (i === 3 || i === 4) ? flagPattern : numberPattern;
      const match2 = segment.slice(index2).match(pattern);
      if (match2 === null) {
        throw Error("Invalid SVG path, incorrect parameter type");
      }
      index2 += match2[0].length;
      params2.push(+match2[0]);
      const ws = segment.slice(index2).match(spacePattern);
      if (ws !== null) {
        index2 += ws[0].length;
      }
    }
  }
  return params2;
}
var DegToRad = Math.PI / 180;
var Epsilon = 1e-14;
var HalfPi = Math.PI / 2;
var Tau = Math.PI * 2;
var HalfSqrt3 = Math.sqrt(3) / 2;
var segmentCache = {};
var bezierCache = {};
var join = [].join;
function segments(x2, y2, rx, ry, large, sweep, rotateX, ox, oy) {
  const key2 = join.call(arguments);
  if (segmentCache[key2]) {
    return segmentCache[key2];
  }
  const th = rotateX * DegToRad;
  const sin_th = Math.sin(th);
  const cos_th = Math.cos(th);
  rx = Math.abs(rx);
  ry = Math.abs(ry);
  const px2 = cos_th * (ox - x2) * 0.5 + sin_th * (oy - y2) * 0.5;
  const py2 = cos_th * (oy - y2) * 0.5 - sin_th * (ox - x2) * 0.5;
  let pl = px2 * px2 / (rx * rx) + py2 * py2 / (ry * ry);
  if (pl > 1) {
    pl = Math.sqrt(pl);
    rx *= pl;
    ry *= pl;
  }
  const a00 = cos_th / rx;
  const a01 = sin_th / rx;
  const a10 = -sin_th / ry;
  const a11 = cos_th / ry;
  const x02 = a00 * ox + a01 * oy;
  const y02 = a10 * ox + a11 * oy;
  const x12 = a00 * x2 + a01 * y2;
  const y12 = a10 * x2 + a11 * y2;
  const d = (x12 - x02) * (x12 - x02) + (y12 - y02) * (y12 - y02);
  let sfactor_sq = 1 / d - 0.25;
  if (sfactor_sq < 0)
    sfactor_sq = 0;
  let sfactor = Math.sqrt(sfactor_sq);
  if (sweep == large)
    sfactor = -sfactor;
  const xc = 0.5 * (x02 + x12) - sfactor * (y12 - y02);
  const yc = 0.5 * (y02 + y12) + sfactor * (x12 - x02);
  const th0 = Math.atan2(y02 - yc, x02 - xc);
  const th1 = Math.atan2(y12 - yc, x12 - xc);
  let th_arc = th1 - th0;
  if (th_arc < 0 && sweep === 1) {
    th_arc += Tau;
  } else if (th_arc > 0 && sweep === 0) {
    th_arc -= Tau;
  }
  const segs = Math.ceil(Math.abs(th_arc / (HalfPi + 1e-3)));
  const result = [];
  for (let i = 0; i < segs; ++i) {
    const th2 = th0 + i * th_arc / segs;
    const th3 = th0 + (i + 1) * th_arc / segs;
    result[i] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];
  }
  return segmentCache[key2] = result;
}
function bezier(params2) {
  const key2 = join.call(params2);
  if (bezierCache[key2]) {
    return bezierCache[key2];
  }
  var cx = params2[0], cy = params2[1], th0 = params2[2], th1 = params2[3], rx = params2[4], ry = params2[5], sin_th = params2[6], cos_th = params2[7];
  const a00 = cos_th * rx;
  const a01 = -sin_th * ry;
  const a10 = sin_th * rx;
  const a11 = cos_th * ry;
  const cos_th0 = Math.cos(th0);
  const sin_th0 = Math.sin(th0);
  const cos_th1 = Math.cos(th1);
  const sin_th1 = Math.sin(th1);
  const th_half = 0.5 * (th1 - th0);
  const sin_th_h2 = Math.sin(th_half * 0.5);
  const t = 8 / 3 * sin_th_h2 * sin_th_h2 / Math.sin(th_half);
  const x12 = cx + cos_th0 - t * sin_th0;
  const y12 = cy + sin_th0 + t * cos_th0;
  const x3 = cx + cos_th1;
  const y3 = cy + sin_th1;
  const x2 = x3 + t * sin_th1;
  const y2 = y3 - t * cos_th1;
  return bezierCache[key2] = [a00 * x12 + a01 * y12, a10 * x12 + a11 * y12, a00 * x2 + a01 * y2, a10 * x2 + a11 * y2, a00 * x3 + a01 * y3, a10 * x3 + a11 * y3];
}
var temp = ["l", 0, 0, 0, 0, 0, 0, 0];
function scale$1(current, sX, sY) {
  const c = temp[0] = current[0];
  if (c === "a" || c === "A") {
    temp[1] = sX * current[1];
    temp[2] = sY * current[2];
    temp[3] = current[3];
    temp[4] = current[4];
    temp[5] = current[5];
    temp[6] = sX * current[6];
    temp[7] = sY * current[7];
  } else if (c === "h" || c === "H") {
    temp[1] = sX * current[1];
  } else if (c === "v" || c === "V") {
    temp[1] = sY * current[1];
  } else {
    for (var i = 1, n = current.length; i < n; ++i) {
      temp[i] = (i % 2 == 1 ? sX : sY) * current[i];
    }
  }
  return temp;
}
function pathRender(context3, path3, l, t, sX, sY) {
  var current, previous = null, x2 = 0, y2 = 0, controlX = 0, controlY = 0, tempX, tempY, tempControlX, tempControlY, anchorX = 0, anchorY = 0;
  if (l == null)
    l = 0;
  if (t == null)
    t = 0;
  if (sX == null)
    sX = 1;
  if (sY == null)
    sY = sX;
  if (context3.beginPath)
    context3.beginPath();
  for (var i = 0, len = path3.length; i < len; ++i) {
    current = path3[i];
    if (sX !== 1 || sY !== 1) {
      current = scale$1(current, sX, sY);
    }
    switch (current[0]) {
      case "l":
        x2 += current[1];
        y2 += current[2];
        context3.lineTo(x2 + l, y2 + t);
        break;
      case "L":
        x2 = current[1];
        y2 = current[2];
        context3.lineTo(x2 + l, y2 + t);
        break;
      case "h":
        x2 += current[1];
        context3.lineTo(x2 + l, y2 + t);
        break;
      case "H":
        x2 = current[1];
        context3.lineTo(x2 + l, y2 + t);
        break;
      case "v":
        y2 += current[1];
        context3.lineTo(x2 + l, y2 + t);
        break;
      case "V":
        y2 = current[1];
        context3.lineTo(x2 + l, y2 + t);
        break;
      case "m":
        x2 += current[1];
        y2 += current[2];
        anchorX = x2;
        anchorY = y2;
        context3.moveTo(x2 + l, y2 + t);
        break;
      case "M":
        x2 = current[1];
        y2 = current[2];
        anchorX = x2;
        anchorY = y2;
        context3.moveTo(x2 + l, y2 + t);
        break;
      case "c":
        tempX = x2 + current[5];
        tempY = y2 + current[6];
        controlX = x2 + current[3];
        controlY = y2 + current[4];
        context3.bezierCurveTo(
          x2 + current[1] + l,
          // x1
          y2 + current[2] + t,
          // y1
          controlX + l,
          // x2
          controlY + t,
          // y2
          tempX + l,
          tempY + t
        );
        x2 = tempX;
        y2 = tempY;
        break;
      case "C":
        x2 = current[5];
        y2 = current[6];
        controlX = current[3];
        controlY = current[4];
        context3.bezierCurveTo(current[1] + l, current[2] + t, controlX + l, controlY + t, x2 + l, y2 + t);
        break;
      case "s":
        tempX = x2 + current[3];
        tempY = y2 + current[4];
        controlX = 2 * x2 - controlX;
        controlY = 2 * y2 - controlY;
        context3.bezierCurveTo(controlX + l, controlY + t, x2 + current[1] + l, y2 + current[2] + t, tempX + l, tempY + t);
        controlX = x2 + current[1];
        controlY = y2 + current[2];
        x2 = tempX;
        y2 = tempY;
        break;
      case "S":
        tempX = current[3];
        tempY = current[4];
        controlX = 2 * x2 - controlX;
        controlY = 2 * y2 - controlY;
        context3.bezierCurveTo(controlX + l, controlY + t, current[1] + l, current[2] + t, tempX + l, tempY + t);
        x2 = tempX;
        y2 = tempY;
        controlX = current[1];
        controlY = current[2];
        break;
      case "q":
        tempX = x2 + current[3];
        tempY = y2 + current[4];
        controlX = x2 + current[1];
        controlY = y2 + current[2];
        context3.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);
        x2 = tempX;
        y2 = tempY;
        break;
      case "Q":
        tempX = current[3];
        tempY = current[4];
        context3.quadraticCurveTo(current[1] + l, current[2] + t, tempX + l, tempY + t);
        x2 = tempX;
        y2 = tempY;
        controlX = current[1];
        controlY = current[2];
        break;
      case "t":
        tempX = x2 + current[1];
        tempY = y2 + current[2];
        if (previous[0].match(/[QqTt]/) === null) {
          controlX = x2;
          controlY = y2;
        } else if (previous[0] === "t") {
          controlX = 2 * x2 - tempControlX;
          controlY = 2 * y2 - tempControlY;
        } else if (previous[0] === "q") {
          controlX = 2 * x2 - controlX;
          controlY = 2 * y2 - controlY;
        }
        tempControlX = controlX;
        tempControlY = controlY;
        context3.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);
        x2 = tempX;
        y2 = tempY;
        controlX = x2 + current[1];
        controlY = y2 + current[2];
        break;
      case "T":
        tempX = current[1];
        tempY = current[2];
        controlX = 2 * x2 - controlX;
        controlY = 2 * y2 - controlY;
        context3.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);
        x2 = tempX;
        y2 = tempY;
        break;
      case "a":
        drawArc(context3, x2 + l, y2 + t, [current[1], current[2], current[3], current[4], current[5], current[6] + x2 + l, current[7] + y2 + t]);
        x2 += current[6];
        y2 += current[7];
        break;
      case "A":
        drawArc(context3, x2 + l, y2 + t, [current[1], current[2], current[3], current[4], current[5], current[6] + l, current[7] + t]);
        x2 = current[6];
        y2 = current[7];
        break;
      case "z":
      case "Z":
        x2 = anchorX;
        y2 = anchorY;
        context3.closePath();
        break;
    }
    previous = current;
  }
}
function drawArc(context3, x2, y2, coords) {
  const seg = segments(
    coords[5],
    // end x
    coords[6],
    // end y
    coords[0],
    // radius x
    coords[1],
    // radius y
    coords[3],
    // large flag
    coords[4],
    // sweep flag
    coords[2],
    // rotation
    x2,
    y2
  );
  for (let i = 0; i < seg.length; ++i) {
    const bez = bezier(seg[i]);
    context3.bezierCurveTo(bez[0], bez[1], bez[2], bez[3], bez[4], bez[5]);
  }
}
var Tan30 = 0.5773502691896257;
var builtins = {
  "circle": {
    draw: function(context3, size) {
      const r = Math.sqrt(size) / 2;
      context3.moveTo(r, 0);
      context3.arc(0, 0, r, 0, Tau);
    }
  },
  "cross": {
    draw: function(context3, size) {
      var r = Math.sqrt(size) / 2, s = r / 2.5;
      context3.moveTo(-r, -s);
      context3.lineTo(-r, s);
      context3.lineTo(-s, s);
      context3.lineTo(-s, r);
      context3.lineTo(s, r);
      context3.lineTo(s, s);
      context3.lineTo(r, s);
      context3.lineTo(r, -s);
      context3.lineTo(s, -s);
      context3.lineTo(s, -r);
      context3.lineTo(-s, -r);
      context3.lineTo(-s, -s);
      context3.closePath();
    }
  },
  "diamond": {
    draw: function(context3, size) {
      const r = Math.sqrt(size) / 2;
      context3.moveTo(-r, 0);
      context3.lineTo(0, -r);
      context3.lineTo(r, 0);
      context3.lineTo(0, r);
      context3.closePath();
    }
  },
  "square": {
    draw: function(context3, size) {
      var w3 = Math.sqrt(size), x2 = -w3 / 2;
      context3.rect(x2, x2, w3, w3);
    }
  },
  "arrow": {
    draw: function(context3, size) {
      var r = Math.sqrt(size) / 2, s = r / 7, t = r / 2.5, v = r / 8;
      context3.moveTo(-s, r);
      context3.lineTo(s, r);
      context3.lineTo(s, -v);
      context3.lineTo(t, -v);
      context3.lineTo(0, -r);
      context3.lineTo(-t, -v);
      context3.lineTo(-s, -v);
      context3.closePath();
    }
  },
  "wedge": {
    draw: function(context3, size) {
      var r = Math.sqrt(size) / 2, h2 = HalfSqrt3 * r, o = h2 - r * Tan30, b2 = r / 4;
      context3.moveTo(0, -h2 - o);
      context3.lineTo(-b2, h2 - o);
      context3.lineTo(b2, h2 - o);
      context3.closePath();
    }
  },
  "triangle": {
    draw: function(context3, size) {
      var r = Math.sqrt(size) / 2, h2 = HalfSqrt3 * r, o = h2 - r * Tan30;
      context3.moveTo(0, -h2 - o);
      context3.lineTo(-r, h2 - o);
      context3.lineTo(r, h2 - o);
      context3.closePath();
    }
  },
  "triangle-up": {
    draw: function(context3, size) {
      var r = Math.sqrt(size) / 2, h2 = HalfSqrt3 * r;
      context3.moveTo(0, -h2);
      context3.lineTo(-r, h2);
      context3.lineTo(r, h2);
      context3.closePath();
    }
  },
  "triangle-down": {
    draw: function(context3, size) {
      var r = Math.sqrt(size) / 2, h2 = HalfSqrt3 * r;
      context3.moveTo(0, h2);
      context3.lineTo(-r, -h2);
      context3.lineTo(r, -h2);
      context3.closePath();
    }
  },
  "triangle-right": {
    draw: function(context3, size) {
      var r = Math.sqrt(size) / 2, h2 = HalfSqrt3 * r;
      context3.moveTo(h2, 0);
      context3.lineTo(-h2, -r);
      context3.lineTo(-h2, r);
      context3.closePath();
    }
  },
  "triangle-left": {
    draw: function(context3, size) {
      var r = Math.sqrt(size) / 2, h2 = HalfSqrt3 * r;
      context3.moveTo(-h2, 0);
      context3.lineTo(h2, -r);
      context3.lineTo(h2, r);
      context3.closePath();
    }
  },
  "stroke": {
    draw: function(context3, size) {
      const r = Math.sqrt(size) / 2;
      context3.moveTo(-r, 0);
      context3.lineTo(r, 0);
    }
  }
};
function symbols2(_) {
  return has(builtins, _) ? builtins[_] : customSymbol(_);
}
var custom = {};
function customSymbol(path3) {
  if (!has(custom, path3)) {
    const parsed = parse4(path3);
    custom[path3] = {
      draw: function(context3, size) {
        pathRender(context3, parsed, 0, 0, Math.sqrt(size) / 2);
      }
    };
  }
  return custom[path3];
}
var C = 0.448084975506;
function rectangleX(d) {
  return d.x;
}
function rectangleY(d) {
  return d.y;
}
function rectangleWidth(d) {
  return d.width;
}
function rectangleHeight(d) {
  return d.height;
}
function number(_) {
  return typeof _ === "function" ? _ : () => +_;
}
function clamp(value3, min4, max4) {
  return Math.max(min4, Math.min(value3, max4));
}
function vg_rect() {
  var x2 = rectangleX, y2 = rectangleY, width2 = rectangleWidth, height2 = rectangleHeight, crTL = number(0), crTR = crTL, crBL = crTL, crBR = crTL, context3 = null;
  function rectangle2(_, x02, y02) {
    var buffer, x12 = x02 != null ? x02 : +x2.call(this, _), y12 = y02 != null ? y02 : +y2.call(this, _), w3 = +width2.call(this, _), h2 = +height2.call(this, _), s = Math.min(w3, h2) / 2, tl2 = clamp(+crTL.call(this, _), 0, s), tr2 = clamp(+crTR.call(this, _), 0, s), bl2 = clamp(+crBL.call(this, _), 0, s), br2 = clamp(+crBR.call(this, _), 0, s);
    if (!context3)
      context3 = buffer = path();
    if (tl2 <= 0 && tr2 <= 0 && bl2 <= 0 && br2 <= 0) {
      context3.rect(x12, y12, w3, h2);
    } else {
      var x22 = x12 + w3, y22 = y12 + h2;
      context3.moveTo(x12 + tl2, y12);
      context3.lineTo(x22 - tr2, y12);
      context3.bezierCurveTo(x22 - C * tr2, y12, x22, y12 + C * tr2, x22, y12 + tr2);
      context3.lineTo(x22, y22 - br2);
      context3.bezierCurveTo(x22, y22 - C * br2, x22 - C * br2, y22, x22 - br2, y22);
      context3.lineTo(x12 + bl2, y22);
      context3.bezierCurveTo(x12 + C * bl2, y22, x12, y22 - C * bl2, x12, y22 - bl2);
      context3.lineTo(x12, y12 + tl2);
      context3.bezierCurveTo(x12, y12 + C * tl2, x12 + C * tl2, y12, x12 + tl2, y12);
      context3.closePath();
    }
    if (buffer) {
      context3 = null;
      return buffer + "" || null;
    }
  }
  rectangle2.x = function(_) {
    if (arguments.length) {
      x2 = number(_);
      return rectangle2;
    } else {
      return x2;
    }
  };
  rectangle2.y = function(_) {
    if (arguments.length) {
      y2 = number(_);
      return rectangle2;
    } else {
      return y2;
    }
  };
  rectangle2.width = function(_) {
    if (arguments.length) {
      width2 = number(_);
      return rectangle2;
    } else {
      return width2;
    }
  };
  rectangle2.height = function(_) {
    if (arguments.length) {
      height2 = number(_);
      return rectangle2;
    } else {
      return height2;
    }
  };
  rectangle2.cornerRadius = function(tl2, tr2, br2, bl2) {
    if (arguments.length) {
      crTL = number(tl2);
      crTR = tr2 != null ? number(tr2) : crTL;
      crBR = br2 != null ? number(br2) : crTL;
      crBL = bl2 != null ? number(bl2) : crTR;
      return rectangle2;
    } else {
      return crTL;
    }
  };
  rectangle2.context = function(_) {
    if (arguments.length) {
      context3 = _ == null ? null : _;
      return rectangle2;
    } else {
      return context3;
    }
  };
  return rectangle2;
}
function vg_trail() {
  var x2, y2, size, defined, context3 = null, ready, x12, y12, r1;
  function point3(x22, y22, w22) {
    const r2 = w22 / 2;
    if (ready) {
      var ux = y12 - y22, uy = x22 - x12;
      if (ux || uy) {
        var ud = Math.hypot(ux, uy), rx = (ux /= ud) * r1, ry = (uy /= ud) * r1, t = Math.atan2(uy, ux);
        context3.moveTo(x12 - rx, y12 - ry);
        context3.lineTo(x22 - ux * r2, y22 - uy * r2);
        context3.arc(x22, y22, r2, t - Math.PI, t);
        context3.lineTo(x12 + rx, y12 + ry);
        context3.arc(x12, y12, r1, t, t + Math.PI);
      } else {
        context3.arc(x22, y22, r2, 0, Tau);
      }
      context3.closePath();
    } else {
      ready = 1;
    }
    x12 = x22;
    y12 = y22;
    r1 = r2;
  }
  function trail2(data3) {
    var i, n = data3.length, d, defined0 = false, buffer;
    if (context3 == null)
      context3 = buffer = path();
    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data3[i], i, data3)) === defined0) {
        if (defined0 = !defined0)
          ready = 0;
      }
      if (defined0)
        point3(+x2(d, i, data3), +y2(d, i, data3), +size(d, i, data3));
    }
    if (buffer) {
      context3 = null;
      return buffer + "" || null;
    }
  }
  trail2.x = function(_) {
    if (arguments.length) {
      x2 = _;
      return trail2;
    } else {
      return x2;
    }
  };
  trail2.y = function(_) {
    if (arguments.length) {
      y2 = _;
      return trail2;
    } else {
      return y2;
    }
  };
  trail2.size = function(_) {
    if (arguments.length) {
      size = _;
      return trail2;
    } else {
      return size;
    }
  };
  trail2.defined = function(_) {
    if (arguments.length) {
      defined = _;
      return trail2;
    } else {
      return defined;
    }
  };
  trail2.context = function(_) {
    if (arguments.length) {
      if (_ == null) {
        context3 = null;
      } else {
        context3 = _;
      }
      return trail2;
    } else {
      return context3;
    }
  };
  return trail2;
}
function value$1(a, b2) {
  return a != null ? a : b2;
}
var x = (item) => item.x || 0;
var y = (item) => item.y || 0;
var w = (item) => item.width || 0;
var h = (item) => item.height || 0;
var xw = (item) => (item.x || 0) + (item.width || 0);
var yh = (item) => (item.y || 0) + (item.height || 0);
var sa = (item) => item.startAngle || 0;
var ea = (item) => item.endAngle || 0;
var pa = (item) => item.padAngle || 0;
var ir = (item) => item.innerRadius || 0;
var or = (item) => item.outerRadius || 0;
var cr = (item) => item.cornerRadius || 0;
var tl = (item) => value$1(item.cornerRadiusTopLeft, item.cornerRadius) || 0;
var tr = (item) => value$1(item.cornerRadiusTopRight, item.cornerRadius) || 0;
var br = (item) => value$1(item.cornerRadiusBottomRight, item.cornerRadius) || 0;
var bl = (item) => value$1(item.cornerRadiusBottomLeft, item.cornerRadius) || 0;
var sz = (item) => value$1(item.size, 64);
var ts = (item) => item.size || 1;
var def = (item) => !(item.defined === false);
var type = (item) => symbols2(item.shape || "circle");
var arcShape = arc_default().startAngle(sa).endAngle(ea).padAngle(pa).innerRadius(ir).outerRadius(or).cornerRadius(cr);
var areavShape = area_default().x(x).y1(y).y0(yh).defined(def);
var areahShape = area_default().y(y).x1(x).x0(xw).defined(def);
var lineShape = line_default().x(x).y(y).defined(def);
var rectShape = vg_rect().x(x).y(y).width(w).height(h).cornerRadius(tl, tr, br, bl);
var symbolShape = Symbol2().type(type).size(sz);
var trailShape = vg_trail().x(x).y(y).defined(def).size(ts);
function hasCornerRadius(item) {
  return item.cornerRadius || item.cornerRadiusTopLeft || item.cornerRadiusTopRight || item.cornerRadiusBottomRight || item.cornerRadiusBottomLeft;
}
function arc$1(context3, item) {
  return arcShape.context(context3)(item);
}
function area$1(context3, items) {
  const item = items[0], interp = item.interpolate || "linear";
  return (item.orient === "horizontal" ? areahShape : areavShape).curve(curves(interp, item.orient, item.tension)).context(context3)(items);
}
function line$1(context3, items) {
  const item = items[0], interp = item.interpolate || "linear";
  return lineShape.curve(curves(interp, item.orient, item.tension)).context(context3)(items);
}
function rectangle(context3, item, x2, y2) {
  return rectShape.context(context3)(item, x2, y2);
}
function shape$1(context3, item) {
  return (item.mark.shape || item.shape).context(context3)(item);
}
function symbol$1(context3, item) {
  return symbolShape.context(context3)(item);
}
function trail$1(context3, items) {
  return trailShape.context(context3)(items);
}
var clip_id = 1;
function resetSVGClipId() {
  clip_id = 1;
}
function clip$1(renderer, item, size) {
  var clip3 = item.clip, defs = renderer._defs, id2 = item.clip_id || (item.clip_id = "clip" + clip_id++), c = defs.clipping[id2] || (defs.clipping[id2] = {
    id: id2
  });
  if (isFunction(clip3)) {
    c.path = clip3(null);
  } else if (hasCornerRadius(size)) {
    c.path = rectangle(null, size, 0, 0);
  } else {
    c.width = size.width || 0;
    c.height = size.height || 0;
  }
  return "url(#" + id2 + ")";
}
function Bounds(b2) {
  this.clear();
  if (b2)
    this.union(b2);
}
Bounds.prototype = {
  clone() {
    return new Bounds(this);
  },
  clear() {
    this.x1 = +Number.MAX_VALUE;
    this.y1 = +Number.MAX_VALUE;
    this.x2 = -Number.MAX_VALUE;
    this.y2 = -Number.MAX_VALUE;
    return this;
  },
  empty() {
    return this.x1 === +Number.MAX_VALUE && this.y1 === +Number.MAX_VALUE && this.x2 === -Number.MAX_VALUE && this.y2 === -Number.MAX_VALUE;
  },
  equals(b2) {
    return this.x1 === b2.x1 && this.y1 === b2.y1 && this.x2 === b2.x2 && this.y2 === b2.y2;
  },
  set(x12, y12, x2, y2) {
    if (x2 < x12) {
      this.x2 = x12;
      this.x1 = x2;
    } else {
      this.x1 = x12;
      this.x2 = x2;
    }
    if (y2 < y12) {
      this.y2 = y12;
      this.y1 = y2;
    } else {
      this.y1 = y12;
      this.y2 = y2;
    }
    return this;
  },
  add(x2, y2) {
    if (x2 < this.x1)
      this.x1 = x2;
    if (y2 < this.y1)
      this.y1 = y2;
    if (x2 > this.x2)
      this.x2 = x2;
    if (y2 > this.y2)
      this.y2 = y2;
    return this;
  },
  expand(d) {
    this.x1 -= d;
    this.y1 -= d;
    this.x2 += d;
    this.y2 += d;
    return this;
  },
  round() {
    this.x1 = Math.floor(this.x1);
    this.y1 = Math.floor(this.y1);
    this.x2 = Math.ceil(this.x2);
    this.y2 = Math.ceil(this.y2);
    return this;
  },
  scale(s) {
    this.x1 *= s;
    this.y1 *= s;
    this.x2 *= s;
    this.y2 *= s;
    return this;
  },
  translate(dx, dy) {
    this.x1 += dx;
    this.x2 += dx;
    this.y1 += dy;
    this.y2 += dy;
    return this;
  },
  rotate(angle, x2, y2) {
    const p = this.rotatedPoints(angle, x2, y2);
    return this.clear().add(p[0], p[1]).add(p[2], p[3]).add(p[4], p[5]).add(p[6], p[7]);
  },
  rotatedPoints(angle, x2, y2) {
    var {
      x1: x12,
      y1: y12,
      x2: x22,
      y2: y22
    } = this, cos2 = Math.cos(angle), sin2 = Math.sin(angle), cx = x2 - x2 * cos2 + y2 * sin2, cy = y2 - x2 * sin2 - y2 * cos2;
    return [cos2 * x12 - sin2 * y12 + cx, sin2 * x12 + cos2 * y12 + cy, cos2 * x12 - sin2 * y22 + cx, sin2 * x12 + cos2 * y22 + cy, cos2 * x22 - sin2 * y12 + cx, sin2 * x22 + cos2 * y12 + cy, cos2 * x22 - sin2 * y22 + cx, sin2 * x22 + cos2 * y22 + cy];
  },
  union(b2) {
    if (b2.x1 < this.x1)
      this.x1 = b2.x1;
    if (b2.y1 < this.y1)
      this.y1 = b2.y1;
    if (b2.x2 > this.x2)
      this.x2 = b2.x2;
    if (b2.y2 > this.y2)
      this.y2 = b2.y2;
    return this;
  },
  intersect(b2) {
    if (b2.x1 > this.x1)
      this.x1 = b2.x1;
    if (b2.y1 > this.y1)
      this.y1 = b2.y1;
    if (b2.x2 < this.x2)
      this.x2 = b2.x2;
    if (b2.y2 < this.y2)
      this.y2 = b2.y2;
    return this;
  },
  encloses(b2) {
    return b2 && this.x1 <= b2.x1 && this.x2 >= b2.x2 && this.y1 <= b2.y1 && this.y2 >= b2.y2;
  },
  alignsWith(b2) {
    return b2 && (this.x1 == b2.x1 || this.x2 == b2.x2 || this.y1 == b2.y1 || this.y2 == b2.y2);
  },
  intersects(b2) {
    return b2 && !(this.x2 < b2.x1 || this.x1 > b2.x2 || this.y2 < b2.y1 || this.y1 > b2.y2);
  },
  contains(x2, y2) {
    return !(x2 < this.x1 || x2 > this.x2 || y2 < this.y1 || y2 > this.y2);
  },
  width() {
    return this.x2 - this.x1;
  },
  height() {
    return this.y2 - this.y1;
  }
};
function Item(mark) {
  this.mark = mark;
  this.bounds = this.bounds || new Bounds();
}
function GroupItem(mark) {
  Item.call(this, mark);
  this.items = this.items || [];
}
inherits(GroupItem, Item);
function ResourceLoader(customLoader) {
  this._pending = 0;
  this._loader = customLoader || loader();
}
function increment(loader2) {
  loader2._pending += 1;
}
function decrement(loader2) {
  loader2._pending -= 1;
}
ResourceLoader.prototype = {
  pending() {
    return this._pending;
  },
  sanitizeURL(uri) {
    const loader2 = this;
    increment(loader2);
    return loader2._loader.sanitize(uri, {
      context: "href"
    }).then((opt) => {
      decrement(loader2);
      return opt;
    }).catch(() => {
      decrement(loader2);
      return null;
    });
  },
  loadImage(uri) {
    const loader2 = this, Image2 = domImage();
    increment(loader2);
    return loader2._loader.sanitize(uri, {
      context: "image"
    }).then((opt) => {
      const url = opt.href;
      if (!url || !Image2)
        throw {
          url
        };
      const img = new Image2();
      const cors = has(opt, "crossOrigin") ? opt.crossOrigin : "anonymous";
      if (cors != null)
        img.crossOrigin = cors;
      img.onload = () => decrement(loader2);
      img.onerror = () => decrement(loader2);
      img.src = url;
      return img;
    }).catch((e) => {
      decrement(loader2);
      return {
        complete: false,
        width: 0,
        height: 0,
        src: e && e.url || ""
      };
    });
  },
  ready() {
    const loader2 = this;
    return new Promise((accept) => {
      function poll(value3) {
        if (!loader2.pending())
          accept(value3);
        else
          setTimeout(() => {
            poll(true);
          }, 10);
      }
      poll(false);
    });
  }
};
function boundStroke(bounds2, item, miter) {
  if (item.stroke && item.opacity !== 0 && item.strokeOpacity !== 0) {
    const sw = item.strokeWidth != null ? +item.strokeWidth : 1;
    bounds2.expand(sw + (miter ? miterAdjustment(item, sw) : 0));
  }
  return bounds2;
}
function miterAdjustment(item, strokeWidth) {
  return item.strokeJoin && item.strokeJoin !== "miter" ? 0 : strokeWidth;
}
var circleThreshold = Tau - 1e-8;
var bounds;
var lx;
var ly;
var rot;
var ma;
var mb;
var mc;
var md;
var add3 = (x2, y2) => bounds.add(x2, y2);
var addL = (x2, y2) => add3(lx = x2, ly = y2);
var addX = (x2) => add3(x2, bounds.y1);
var addY = (y2) => add3(bounds.x1, y2);
var px = (x2, y2) => ma * x2 + mc * y2;
var py = (x2, y2) => mb * x2 + md * y2;
var addp = (x2, y2) => add3(px(x2, y2), py(x2, y2));
var addpL = (x2, y2) => addL(px(x2, y2), py(x2, y2));
function boundContext(_, deg) {
  bounds = _;
  if (deg) {
    rot = deg * DegToRad;
    ma = md = Math.cos(rot);
    mb = Math.sin(rot);
    mc = -mb;
  } else {
    ma = md = 1;
    rot = mb = mc = 0;
  }
  return context$1;
}
var context$1 = {
  beginPath() {
  },
  closePath() {
  },
  moveTo: addpL,
  lineTo: addpL,
  rect(x2, y2, w3, h2) {
    if (rot) {
      addp(x2 + w3, y2);
      addp(x2 + w3, y2 + h2);
      addp(x2, y2 + h2);
      addpL(x2, y2);
    } else {
      add3(x2 + w3, y2 + h2);
      addL(x2, y2);
    }
  },
  quadraticCurveTo(x12, y12, x2, y2) {
    const px1 = px(x12, y12), py1 = py(x12, y12), px2 = px(x2, y2), py2 = py(x2, y2);
    quadExtrema(lx, px1, px2, addX);
    quadExtrema(ly, py1, py2, addY);
    addL(px2, py2);
  },
  bezierCurveTo(x12, y12, x2, y2, x3, y3) {
    const px1 = px(x12, y12), py1 = py(x12, y12), px2 = px(x2, y2), py2 = py(x2, y2), px3 = px(x3, y3), py3 = py(x3, y3);
    cubicExtrema(lx, px1, px2, px3, addX);
    cubicExtrema(ly, py1, py2, py3, addY);
    addL(px3, py3);
  },
  arc(cx, cy, r, sa2, ea2, ccw) {
    sa2 += rot;
    ea2 += rot;
    lx = r * Math.cos(ea2) + cx;
    ly = r * Math.sin(ea2) + cy;
    if (Math.abs(ea2 - sa2) > circleThreshold) {
      add3(cx - r, cy - r);
      add3(cx + r, cy + r);
    } else {
      const update3 = (a) => add3(r * Math.cos(a) + cx, r * Math.sin(a) + cy);
      let s, i;
      update3(sa2);
      update3(ea2);
      if (ea2 !== sa2) {
        sa2 = sa2 % Tau;
        if (sa2 < 0)
          sa2 += Tau;
        ea2 = ea2 % Tau;
        if (ea2 < 0)
          ea2 += Tau;
        if (ea2 < sa2) {
          ccw = !ccw;
          s = sa2;
          sa2 = ea2;
          ea2 = s;
        }
        if (ccw) {
          ea2 -= Tau;
          s = sa2 - sa2 % HalfPi;
          for (i = 0; i < 4 && s > ea2; ++i, s -= HalfPi)
            update3(s);
        } else {
          s = sa2 - sa2 % HalfPi + HalfPi;
          for (i = 0; i < 4 && s < ea2; ++i, s = s + HalfPi)
            update3(s);
        }
      }
    }
  }
};
function quadExtrema(x02, x12, x2, cb) {
  const t = (x02 - x12) / (x02 + x2 - 2 * x12);
  if (0 < t && t < 1)
    cb(x02 + (x12 - x02) * t);
}
function cubicExtrema(x02, x12, x2, x3, cb) {
  const a = x3 - x02 + 3 * x12 - 3 * x2, b2 = x02 + x2 - 2 * x12, c = x02 - x12;
  let t02 = 0, t1 = 0, r;
  if (Math.abs(a) > Epsilon) {
    r = b2 * b2 + c * a;
    if (r >= 0) {
      r = Math.sqrt(r);
      t02 = (-b2 + r) / a;
      t1 = (-b2 - r) / a;
    }
  } else {
    t02 = 0.5 * c / b2;
  }
  if (0 < t02 && t02 < 1)
    cb(cubic(t02, x02, x12, x2, x3));
  if (0 < t1 && t1 < 1)
    cb(cubic(t1, x02, x12, x2, x3));
}
function cubic(t, x02, x12, x2, x3) {
  const s = 1 - t, s2 = s * s, t2 = t * t;
  return s2 * s * x02 + 3 * s2 * t * x12 + 3 * s * t2 * x2 + t2 * t * x3;
}
var context = (context = domCanvas(1, 1)) ? context.getContext("2d") : null;
var b = new Bounds();
function intersectPath(draw3) {
  return function(item, brush) {
    if (!context)
      return true;
    draw3(context, item);
    b.clear().union(item.bounds).intersect(brush).round();
    const {
      x1: x12,
      y1: y12,
      x2,
      y2
    } = b;
    for (let y3 = y12; y3 <= y2; ++y3) {
      for (let x3 = x12; x3 <= x2; ++x3) {
        if (context.isPointInPath(x3, y3)) {
          return true;
        }
      }
    }
    return false;
  };
}
function intersectPoint(item, box) {
  return box.contains(item.x || 0, item.y || 0);
}
function intersectRect(item, box) {
  const x2 = item.x || 0, y2 = item.y || 0, w3 = item.width || 0, h2 = item.height || 0;
  return box.intersects(b.set(x2, y2, x2 + w3, y2 + h2));
}
function intersectRule(item, box) {
  const x2 = item.x || 0, y2 = item.y || 0, x22 = item.x2 != null ? item.x2 : x2, y22 = item.y2 != null ? item.y2 : y2;
  return intersectBoxLine(box, x2, y2, x22, y22);
}
function intersectBoxLine(box, x2, y2, u, v) {
  const {
    x1: x12,
    y1: y12,
    x2: x22,
    y2: y22
  } = box, dx = u - x2, dy = v - y2;
  let t02 = 0, t1 = 1, p, q, r, e;
  for (e = 0; e < 4; ++e) {
    if (e === 0) {
      p = -dx;
      q = -(x12 - x2);
    }
    if (e === 1) {
      p = dx;
      q = x22 - x2;
    }
    if (e === 2) {
      p = -dy;
      q = -(y12 - y2);
    }
    if (e === 3) {
      p = dy;
      q = y22 - y2;
    }
    if (Math.abs(p) < 1e-10 && q < 0)
      return false;
    r = q / p;
    if (p < 0) {
      if (r > t1)
        return false;
      else if (r > t02)
        t02 = r;
    } else if (p > 0) {
      if (r < t02)
        return false;
      else if (r < t1)
        t1 = r;
    }
  }
  return true;
}
function blend(context3, item) {
  context3.globalCompositeOperation = item.blend || "source-over";
}
function value(value3, dflt) {
  return value3 == null ? dflt : value3;
}
function addStops(gradient3, stops) {
  const n = stops.length;
  for (let i = 0; i < n; ++i) {
    gradient3.addColorStop(stops[i].offset, stops[i].color);
  }
  return gradient3;
}
function gradient(context3, spec, bounds2) {
  const w3 = bounds2.width(), h2 = bounds2.height();
  let gradient3;
  if (spec.gradient === "radial") {
    gradient3 = context3.createRadialGradient(bounds2.x1 + value(spec.x1, 0.5) * w3, bounds2.y1 + value(spec.y1, 0.5) * h2, Math.max(w3, h2) * value(spec.r1, 0), bounds2.x1 + value(spec.x2, 0.5) * w3, bounds2.y1 + value(spec.y2, 0.5) * h2, Math.max(w3, h2) * value(spec.r2, 0.5));
  } else {
    const x12 = value(spec.x1, 0), y12 = value(spec.y1, 0), x2 = value(spec.x2, 1), y2 = value(spec.y2, 0);
    if (x12 === x2 || y12 === y2 || w3 === h2) {
      gradient3 = context3.createLinearGradient(bounds2.x1 + x12 * w3, bounds2.y1 + y12 * h2, bounds2.x1 + x2 * w3, bounds2.y1 + y2 * h2);
    } else {
      const image2 = domCanvas(Math.ceil(w3), Math.ceil(h2)), ictx = image2.getContext("2d");
      ictx.scale(w3, h2);
      ictx.fillStyle = addStops(ictx.createLinearGradient(x12, y12, x2, y2), spec.stops);
      ictx.fillRect(0, 0, w3, h2);
      return context3.createPattern(image2, "no-repeat");
    }
  }
  return addStops(gradient3, spec.stops);
}
function color(context3, item, value3) {
  return isGradient(value3) ? gradient(context3, value3, item.bounds) : value3;
}
function fill(context3, item, opacity) {
  opacity *= item.fillOpacity == null ? 1 : item.fillOpacity;
  if (opacity > 0) {
    context3.globalAlpha = opacity;
    context3.fillStyle = color(context3, item, item.fill);
    return true;
  } else {
    return false;
  }
}
var Empty2 = [];
function stroke(context3, item, opacity) {
  var lw = (lw = item.strokeWidth) != null ? lw : 1;
  if (lw <= 0)
    return false;
  opacity *= item.strokeOpacity == null ? 1 : item.strokeOpacity;
  if (opacity > 0) {
    context3.globalAlpha = opacity;
    context3.strokeStyle = color(context3, item, item.stroke);
    context3.lineWidth = lw;
    context3.lineCap = item.strokeCap || "butt";
    context3.lineJoin = item.strokeJoin || "miter";
    context3.miterLimit = item.strokeMiterLimit || 10;
    if (context3.setLineDash) {
      context3.setLineDash(item.strokeDash || Empty2);
      context3.lineDashOffset = item.strokeDashOffset || 0;
    }
    return true;
  } else {
    return false;
  }
}
function compare2(a, b2) {
  return a.zindex - b2.zindex || a.index - b2.index;
}
function zorder(scene) {
  if (!scene.zdirty)
    return scene.zitems;
  var items = scene.items, output3 = [], item, i, n;
  for (i = 0, n = items.length; i < n; ++i) {
    item = items[i];
    item.index = i;
    if (item.zindex)
      output3.push(item);
  }
  scene.zdirty = false;
  return scene.zitems = output3.sort(compare2);
}
function visit(scene, visitor) {
  var items = scene.items, i, n;
  if (!items || !items.length)
    return;
  const zitems = zorder(scene);
  if (zitems && zitems.length) {
    for (i = 0, n = items.length; i < n; ++i) {
      if (!items[i].zindex)
        visitor(items[i]);
    }
    items = zitems;
  }
  for (i = 0, n = items.length; i < n; ++i) {
    visitor(items[i]);
  }
}
function pickVisit(scene, visitor) {
  var items = scene.items, hit2, i;
  if (!items || !items.length)
    return null;
  const zitems = zorder(scene);
  if (zitems && zitems.length)
    items = zitems;
  for (i = items.length; --i >= 0; ) {
    if (hit2 = visitor(items[i]))
      return hit2;
  }
  if (items === zitems) {
    for (items = scene.items, i = items.length; --i >= 0; ) {
      if (!items[i].zindex) {
        if (hit2 = visitor(items[i]))
          return hit2;
      }
    }
  }
  return null;
}
function drawAll(path3) {
  return function(context3, scene, bounds2) {
    visit(scene, (item) => {
      if (!bounds2 || bounds2.intersects(item.bounds)) {
        drawPath(path3, context3, item, item);
      }
    });
  };
}
function drawOne(path3) {
  return function(context3, scene, bounds2) {
    if (scene.items.length && (!bounds2 || bounds2.intersects(scene.bounds))) {
      drawPath(path3, context3, scene.items[0], scene.items);
    }
  };
}
function drawPath(path3, context3, item, items) {
  var opacity = item.opacity == null ? 1 : item.opacity;
  if (opacity === 0)
    return;
  if (path3(context3, items))
    return;
  blend(context3, item);
  if (item.fill && fill(context3, item, opacity)) {
    context3.fill();
  }
  if (item.stroke && stroke(context3, item, opacity)) {
    context3.stroke();
  }
}
function pick$1(test2) {
  test2 = test2 || truthy;
  return function(context3, scene, x2, y2, gx, gy) {
    x2 *= context3.pixelRatio;
    y2 *= context3.pixelRatio;
    return pickVisit(scene, (item) => {
      const b2 = item.bounds;
      if (b2 && !b2.contains(gx, gy) || !b2)
        return;
      if (test2(context3, item, x2, y2, gx, gy))
        return item;
    });
  };
}
function hitPath(path3, filled) {
  return function(context3, o, x2, y2) {
    var item = Array.isArray(o) ? o[0] : o, fill2 = filled == null ? item.fill : filled, stroke2 = item.stroke && context3.isPointInStroke, lw, lc;
    if (stroke2) {
      lw = item.strokeWidth;
      lc = item.strokeCap;
      context3.lineWidth = lw != null ? lw : 1;
      context3.lineCap = lc != null ? lc : "butt";
    }
    return path3(context3, o) ? false : fill2 && context3.isPointInPath(x2, y2) || stroke2 && context3.isPointInStroke(x2, y2);
  };
}
function pickPath(path3) {
  return pick$1(hitPath(path3));
}
function translate(x2, y2) {
  return "translate(" + x2 + "," + y2 + ")";
}
function rotate(a) {
  return "rotate(" + a + ")";
}
function scale2(scaleX, scaleY2) {
  return "scale(" + scaleX + "," + scaleY2 + ")";
}
function translateItem(item) {
  return translate(item.x || 0, item.y || 0);
}
function rotateItem(item) {
  return translate(item.x || 0, item.y || 0) + (item.angle ? " " + rotate(item.angle) : "");
}
function transformItem(item) {
  return translate(item.x || 0, item.y || 0) + (item.angle ? " " + rotate(item.angle) : "") + (item.scaleX || item.scaleY ? " " + scale2(item.scaleX || 1, item.scaleY || 1) : "");
}
function markItemPath(type2, shape2, isect) {
  function attr2(emit2, item) {
    emit2("transform", rotateItem(item));
    emit2("d", shape2(null, item));
  }
  function bound2(bounds2, item) {
    shape2(boundContext(bounds2, item.angle), item);
    return boundStroke(bounds2, item).translate(item.x || 0, item.y || 0);
  }
  function draw3(context3, item) {
    var x2 = item.x || 0, y2 = item.y || 0, a = item.angle || 0;
    context3.translate(x2, y2);
    if (a)
      context3.rotate(a *= DegToRad);
    context3.beginPath();
    shape2(context3, item);
    if (a)
      context3.rotate(-a);
    context3.translate(-x2, -y2);
  }
  return {
    type: type2,
    tag: "path",
    nested: false,
    attr: attr2,
    bound: bound2,
    draw: drawAll(draw3),
    pick: pickPath(draw3),
    isect: isect || intersectPath(draw3)
  };
}
var arc = markItemPath("arc", arc$1);
function pickArea(a, p) {
  var v = a[0].orient === "horizontal" ? p[1] : p[0], z = a[0].orient === "horizontal" ? "y" : "x", i = a.length, min4 = Infinity, hit2, d;
  while (--i >= 0) {
    if (a[i].defined === false)
      continue;
    d = Math.abs(a[i][z] - v);
    if (d < min4) {
      min4 = d;
      hit2 = a[i];
    }
  }
  return hit2;
}
function pickLine(a, p) {
  var t = Math.pow(a[0].strokeWidth || 1, 2), i = a.length, dx, dy, dd;
  while (--i >= 0) {
    if (a[i].defined === false)
      continue;
    dx = a[i].x - p[0];
    dy = a[i].y - p[1];
    dd = dx * dx + dy * dy;
    if (dd < t)
      return a[i];
  }
  return null;
}
function pickTrail(a, p) {
  var i = a.length, dx, dy, dd;
  while (--i >= 0) {
    if (a[i].defined === false)
      continue;
    dx = a[i].x - p[0];
    dy = a[i].y - p[1];
    dd = dx * dx + dy * dy;
    dx = a[i].size || 1;
    if (dd < dx * dx)
      return a[i];
  }
  return null;
}
function markMultiItemPath(type2, shape2, tip) {
  function attr2(emit2, item) {
    var items = item.mark.items;
    if (items.length)
      emit2("d", shape2(null, items));
  }
  function bound2(bounds2, mark) {
    var items = mark.items;
    if (items.length === 0) {
      return bounds2;
    } else {
      shape2(boundContext(bounds2), items);
      return boundStroke(bounds2, items[0]);
    }
  }
  function draw3(context3, items) {
    context3.beginPath();
    shape2(context3, items);
  }
  const hit2 = hitPath(draw3);
  function pick2(context3, scene, x2, y2, gx, gy) {
    var items = scene.items, b2 = scene.bounds;
    if (!items || !items.length || b2 && !b2.contains(gx, gy)) {
      return null;
    }
    x2 *= context3.pixelRatio;
    y2 *= context3.pixelRatio;
    return hit2(context3, items, x2, y2) ? items[0] : null;
  }
  return {
    type: type2,
    tag: "path",
    nested: true,
    attr: attr2,
    bound: bound2,
    draw: drawOne(draw3),
    pick: pick2,
    isect: intersectPoint,
    tip
  };
}
var area = markMultiItemPath("area", area$1, pickArea);
function clip(context3, scene) {
  var clip3 = scene.clip;
  context3.save();
  if (isFunction(clip3)) {
    context3.beginPath();
    clip3(context3);
    context3.clip();
  } else {
    clipGroup(context3, scene.group);
  }
}
function clipGroup(context3, group2) {
  context3.beginPath();
  hasCornerRadius(group2) ? rectangle(context3, group2, 0, 0) : context3.rect(0, 0, group2.width || 0, group2.height || 0);
  context3.clip();
}
function offset$1(item) {
  const sw = value(item.strokeWidth, 1);
  return item.strokeOffset != null ? item.strokeOffset : item.stroke && sw > 0.5 && sw < 1.5 ? 0.5 - Math.abs(sw - 1) : 0;
}
function attr$5(emit2, item) {
  emit2("transform", translateItem(item));
}
function emitRectangle(emit2, item) {
  const off = offset$1(item);
  emit2("d", rectangle(null, item, off, off));
}
function background(emit2, item) {
  emit2("class", "background");
  emit2("aria-hidden", true);
  emitRectangle(emit2, item);
}
function foreground(emit2, item) {
  emit2("class", "foreground");
  emit2("aria-hidden", true);
  if (item.strokeForeground) {
    emitRectangle(emit2, item);
  } else {
    emit2("d", "");
  }
}
function content(emit2, item, renderer) {
  const url = item.clip ? clip$1(renderer, item, item) : null;
  emit2("clip-path", url);
}
function bound$5(bounds2, group2) {
  if (!group2.clip && group2.items) {
    const items = group2.items, m = items.length;
    for (let j = 0; j < m; ++j) {
      bounds2.union(items[j].bounds);
    }
  }
  if ((group2.clip || group2.width || group2.height) && !group2.noBound) {
    bounds2.add(0, 0).add(group2.width || 0, group2.height || 0);
  }
  boundStroke(bounds2, group2);
  return bounds2.translate(group2.x || 0, group2.y || 0);
}
function rectanglePath(context3, group2, x2, y2) {
  const off = offset$1(group2);
  context3.beginPath();
  rectangle(context3, group2, (x2 || 0) + off, (y2 || 0) + off);
}
var hitBackground = hitPath(rectanglePath);
var hitForeground = hitPath(rectanglePath, false);
var hitCorner = hitPath(rectanglePath, true);
function draw$4(context3, scene, bounds2, markTypes) {
  visit(scene, (group2) => {
    const gx = group2.x || 0, gy = group2.y || 0, fore = group2.strokeForeground, opacity = group2.opacity == null ? 1 : group2.opacity;
    if ((group2.stroke || group2.fill) && opacity) {
      rectanglePath(context3, group2, gx, gy);
      blend(context3, group2);
      if (group2.fill && fill(context3, group2, opacity)) {
        context3.fill();
      }
      if (group2.stroke && !fore && stroke(context3, group2, opacity)) {
        context3.stroke();
      }
    }
    context3.save();
    context3.translate(gx, gy);
    if (group2.clip)
      clipGroup(context3, group2);
    if (bounds2)
      bounds2.translate(-gx, -gy);
    visit(group2, (item) => {
      if (item.marktype === "group" || markTypes == null || markTypes.includes(item.marktype)) {
        this.draw(context3, item, bounds2, markTypes);
      }
    });
    if (bounds2)
      bounds2.translate(gx, gy);
    context3.restore();
    if (fore && group2.stroke && opacity) {
      rectanglePath(context3, group2, gx, gy);
      blend(context3, group2);
      if (stroke(context3, group2, opacity)) {
        context3.stroke();
      }
    }
  });
}
function pick(context3, scene, x2, y2, gx, gy) {
  if (scene.bounds && !scene.bounds.contains(gx, gy) || !scene.items) {
    return null;
  }
  const cx = x2 * context3.pixelRatio, cy = y2 * context3.pixelRatio;
  return pickVisit(scene, (group2) => {
    let hit2, dx, dy;
    const b2 = group2.bounds;
    if (b2 && !b2.contains(gx, gy))
      return;
    dx = group2.x || 0;
    dy = group2.y || 0;
    const dw = dx + (group2.width || 0), dh = dy + (group2.height || 0), c = group2.clip;
    if (c && (gx < dx || gx > dw || gy < dy || gy > dh))
      return;
    context3.save();
    context3.translate(dx, dy);
    dx = gx - dx;
    dy = gy - dy;
    if (c && hasCornerRadius(group2) && !hitCorner(context3, group2, cx, cy)) {
      context3.restore();
      return null;
    }
    const fore = group2.strokeForeground, ix = scene.interactive !== false;
    if (ix && fore && group2.stroke && hitForeground(context3, group2, cx, cy)) {
      context3.restore();
      return group2;
    }
    hit2 = pickVisit(group2, (mark) => pickMark(mark, dx, dy) ? this.pick(mark, x2, y2, dx, dy) : null);
    if (!hit2 && ix && (group2.fill || !fore && group2.stroke) && hitBackground(context3, group2, cx, cy)) {
      hit2 = group2;
    }
    context3.restore();
    return hit2 || null;
  });
}
function pickMark(mark, x2, y2) {
  return (mark.interactive !== false || mark.marktype === "group") && mark.bounds && mark.bounds.contains(x2, y2);
}
var group = {
  type: "group",
  tag: "g",
  nested: false,
  attr: attr$5,
  bound: bound$5,
  draw: draw$4,
  pick,
  isect: intersectRect,
  content,
  background,
  foreground
};
var metadata = {
  "xmlns": "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  "version": "1.1"
};
function getImage(item, renderer) {
  var image2 = item.image;
  if (!image2 || item.url && item.url !== image2.url) {
    image2 = {
      complete: false,
      width: 0,
      height: 0
    };
    renderer.loadImage(item.url).then((image3) => {
      item.image = image3;
      item.image.url = item.url;
    });
  }
  return image2;
}
function imageWidth(item, image2) {
  return item.width != null ? item.width : !image2 || !image2.width ? 0 : item.aspect !== false && item.height ? item.height * image2.width / image2.height : image2.width;
}
function imageHeight(item, image2) {
  return item.height != null ? item.height : !image2 || !image2.height ? 0 : item.aspect !== false && item.width ? item.width * image2.height / image2.width : image2.height;
}
function imageXOffset(align, w3) {
  return align === "center" ? w3 / 2 : align === "right" ? w3 : 0;
}
function imageYOffset(baseline2, h2) {
  return baseline2 === "middle" ? h2 / 2 : baseline2 === "bottom" ? h2 : 0;
}
function attr$4(emit2, item, renderer) {
  const img = getImage(item, renderer), w3 = imageWidth(item, img), h2 = imageHeight(item, img), x2 = (item.x || 0) - imageXOffset(item.align, w3), y2 = (item.y || 0) - imageYOffset(item.baseline, h2), i = !img.src && img.toDataURL ? img.toDataURL() : img.src || "";
  emit2("href", i, metadata["xmlns:xlink"], "xlink:href");
  emit2("transform", translate(x2, y2));
  emit2("width", w3);
  emit2("height", h2);
  emit2("preserveAspectRatio", item.aspect === false ? "none" : "xMidYMid");
}
function bound$4(bounds2, item) {
  const img = item.image, w3 = imageWidth(item, img), h2 = imageHeight(item, img), x2 = (item.x || 0) - imageXOffset(item.align, w3), y2 = (item.y || 0) - imageYOffset(item.baseline, h2);
  return bounds2.set(x2, y2, x2 + w3, y2 + h2);
}
function draw$3(context3, scene, bounds2) {
  visit(scene, (item) => {
    if (bounds2 && !bounds2.intersects(item.bounds))
      return;
    const img = getImage(item, this);
    let w3 = imageWidth(item, img);
    let h2 = imageHeight(item, img);
    if (w3 === 0 || h2 === 0)
      return;
    let x2 = (item.x || 0) - imageXOffset(item.align, w3), y2 = (item.y || 0) - imageYOffset(item.baseline, h2), opacity, ar0, ar1, t;
    if (item.aspect !== false) {
      ar0 = img.width / img.height;
      ar1 = item.width / item.height;
      if (ar0 === ar0 && ar1 === ar1 && ar0 !== ar1) {
        if (ar1 < ar0) {
          t = w3 / ar0;
          y2 += (h2 - t) / 2;
          h2 = t;
        } else {
          t = h2 * ar0;
          x2 += (w3 - t) / 2;
          w3 = t;
        }
      }
    }
    if (img.complete || img.toDataURL) {
      blend(context3, item);
      context3.globalAlpha = (opacity = item.opacity) != null ? opacity : 1;
      context3.imageSmoothingEnabled = item.smooth !== false;
      context3.drawImage(img, x2, y2, w3, h2);
    }
  });
}
var image = {
  type: "image",
  tag: "image",
  nested: false,
  attr: attr$4,
  bound: bound$4,
  draw: draw$3,
  pick: pick$1(),
  isect: truthy,
  // bounds check is sufficient
  get: getImage,
  xOffset: imageXOffset,
  yOffset: imageYOffset
};
var line = markMultiItemPath("line", line$1, pickLine);
function attr$3(emit2, item) {
  var sx = item.scaleX || 1, sy = item.scaleY || 1;
  if (sx !== 1 || sy !== 1) {
    emit2("vector-effect", "non-scaling-stroke");
  }
  emit2("transform", transformItem(item));
  emit2("d", item.path);
}
function path$1(context3, item) {
  var path3 = item.path;
  if (path3 == null)
    return true;
  var x2 = item.x || 0, y2 = item.y || 0, sx = item.scaleX || 1, sy = item.scaleY || 1, a = (item.angle || 0) * DegToRad, cache2 = item.pathCache;
  if (!cache2 || cache2.path !== path3) {
    (item.pathCache = cache2 = parse4(path3)).path = path3;
  }
  if (a && context3.rotate && context3.translate) {
    context3.translate(x2, y2);
    context3.rotate(a);
    pathRender(context3, cache2, 0, 0, sx, sy);
    context3.rotate(-a);
    context3.translate(-x2, -y2);
  } else {
    pathRender(context3, cache2, x2, y2, sx, sy);
  }
}
function bound$3(bounds2, item) {
  return path$1(boundContext(bounds2, item.angle), item) ? bounds2.set(0, 0, 0, 0) : boundStroke(bounds2, item, true);
}
var path$2 = {
  type: "path",
  tag: "path",
  nested: false,
  attr: attr$3,
  bound: bound$3,
  draw: drawAll(path$1),
  pick: pickPath(path$1),
  isect: intersectPath(path$1)
};
function attr$2(emit2, item) {
  emit2("d", rectangle(null, item));
}
function bound$2(bounds2, item) {
  var x2, y2;
  return boundStroke(bounds2.set(x2 = item.x || 0, y2 = item.y || 0, x2 + item.width || 0, y2 + item.height || 0), item);
}
function draw$2(context3, item) {
  context3.beginPath();
  rectangle(context3, item);
}
var rect = {
  type: "rect",
  tag: "path",
  nested: false,
  attr: attr$2,
  bound: bound$2,
  draw: drawAll(draw$2),
  pick: pickPath(draw$2),
  isect: intersectRect
};
function attr$1(emit2, item) {
  emit2("transform", translateItem(item));
  emit2("x2", item.x2 != null ? item.x2 - (item.x || 0) : 0);
  emit2("y2", item.y2 != null ? item.y2 - (item.y || 0) : 0);
}
function bound$1(bounds2, item) {
  var x12, y12;
  return boundStroke(bounds2.set(x12 = item.x || 0, y12 = item.y || 0, item.x2 != null ? item.x2 : x12, item.y2 != null ? item.y2 : y12), item);
}
function path2(context3, item, opacity) {
  var x12, y12, x2, y2;
  if (item.stroke && stroke(context3, item, opacity)) {
    x12 = item.x || 0;
    y12 = item.y || 0;
    x2 = item.x2 != null ? item.x2 : x12;
    y2 = item.y2 != null ? item.y2 : y12;
    context3.beginPath();
    context3.moveTo(x12, y12);
    context3.lineTo(x2, y2);
    return true;
  }
  return false;
}
function draw$1(context3, scene, bounds2) {
  visit(scene, (item) => {
    if (bounds2 && !bounds2.intersects(item.bounds))
      return;
    var opacity = item.opacity == null ? 1 : item.opacity;
    if (opacity && path2(context3, item, opacity)) {
      blend(context3, item);
      context3.stroke();
    }
  });
}
function hit$1(context3, item, x2, y2) {
  if (!context3.isPointInStroke)
    return false;
  return path2(context3, item, 1) && context3.isPointInStroke(x2, y2);
}
var rule = {
  type: "rule",
  tag: "line",
  nested: false,
  attr: attr$1,
  bound: bound$1,
  draw: draw$1,
  pick: pick$1(hit$1),
  isect: intersectRule
};
var shape = markItemPath("shape", shape$1);
var symbol = markItemPath("symbol", symbol$1, intersectPoint);
var widthCache = lruCache();
var textMetrics = {
  height: fontSize,
  measureWidth,
  estimateWidth,
  width: estimateWidth,
  canvas: useCanvas
};
useCanvas(true);
function useCanvas(use) {
  textMetrics.width = use && context ? measureWidth : estimateWidth;
}
function estimateWidth(item, text2) {
  return _estimateWidth(textValue(item, text2), fontSize(item));
}
function _estimateWidth(text2, currentFontHeight) {
  return ~~(0.8 * text2.length * currentFontHeight);
}
function measureWidth(item, text2) {
  return fontSize(item) <= 0 || !(text2 = textValue(item, text2)) ? 0 : _measureWidth(text2, font(item));
}
function _measureWidth(text2, currentFont) {
  const key2 = `(${currentFont}) ${text2}`;
  let width2 = widthCache.get(key2);
  if (width2 === void 0) {
    context.font = currentFont;
    width2 = context.measureText(text2).width;
    widthCache.set(key2, width2);
  }
  return width2;
}
function fontSize(item) {
  return item.fontSize != null ? +item.fontSize || 0 : 11;
}
function lineHeight(item) {
  return item.lineHeight != null ? item.lineHeight : fontSize(item) + 2;
}
function lineArray(_) {
  return isArray(_) ? _.length > 1 ? _ : _[0] : _;
}
function textLines(item) {
  return lineArray(item.lineBreak && item.text && !isArray(item.text) ? item.text.split(item.lineBreak) : item.text);
}
function multiLineOffset(item) {
  const tl2 = textLines(item);
  return (isArray(tl2) ? tl2.length - 1 : 0) * lineHeight(item);
}
function textValue(item, line3) {
  const text2 = line3 == null ? "" : (line3 + "").trim();
  return item.limit > 0 && text2.length ? truncate2(item, text2) : text2;
}
function widthGetter(item) {
  if (textMetrics.width === measureWidth) {
    const currentFont = font(item);
    return (text2) => _measureWidth(text2, currentFont);
  } else if (textMetrics.width === estimateWidth) {
    const currentFontHeight = fontSize(item);
    return (text2) => _estimateWidth(text2, currentFontHeight);
  } else {
    return (text2) => textMetrics.width(item, text2);
  }
}
function truncate2(item, text2) {
  var limit = +item.limit, width2 = widthGetter(item);
  if (width2(text2) < limit)
    return text2;
  var ellipsis = item.ellipsis || "…", rtl = item.dir === "rtl", lo = 0, hi = text2.length, mid;
  limit -= width2(ellipsis);
  if (rtl) {
    while (lo < hi) {
      mid = lo + hi >>> 1;
      if (width2(text2.slice(mid)) > limit)
        lo = mid + 1;
      else
        hi = mid;
    }
    return ellipsis + text2.slice(lo);
  } else {
    while (lo < hi) {
      mid = 1 + (lo + hi >>> 1);
      if (width2(text2.slice(0, mid)) < limit)
        lo = mid;
      else
        hi = mid - 1;
    }
    return text2.slice(0, lo) + ellipsis;
  }
}
function fontFamily(item, quote) {
  var font2 = item.font;
  return (quote && font2 ? String(font2).replace(/"/g, "'") : font2) || "sans-serif";
}
function font(item, quote) {
  return (item.fontStyle ? item.fontStyle + " " : "") + (item.fontVariant ? item.fontVariant + " " : "") + (item.fontWeight ? item.fontWeight + " " : "") + fontSize(item) + "px " + fontFamily(item, quote);
}
function offset2(item) {
  var baseline2 = item.baseline, h2 = fontSize(item);
  return Math.round(baseline2 === "top" ? 0.79 * h2 : baseline2 === "middle" ? 0.3 * h2 : baseline2 === "bottom" ? -0.21 * h2 : baseline2 === "line-top" ? 0.29 * h2 + 0.5 * lineHeight(item) : baseline2 === "line-bottom" ? 0.29 * h2 - 0.5 * lineHeight(item) : 0);
}
var textAlign = {
  "left": "start",
  "center": "middle",
  "right": "end"
};
var tempBounds = new Bounds();
function anchorPoint(item) {
  var x2 = item.x || 0, y2 = item.y || 0, r = item.radius || 0, t;
  if (r) {
    t = (item.theta || 0) - HalfPi;
    x2 += r * Math.cos(t);
    y2 += r * Math.sin(t);
  }
  tempBounds.x1 = x2;
  tempBounds.y1 = y2;
  return tempBounds;
}
function attr(emit2, item) {
  var dx = item.dx || 0, dy = (item.dy || 0) + offset2(item), p = anchorPoint(item), x2 = p.x1, y2 = p.y1, a = item.angle || 0, t;
  emit2("text-anchor", textAlign[item.align] || "start");
  if (a) {
    t = translate(x2, y2) + " " + rotate(a);
    if (dx || dy)
      t += " " + translate(dx, dy);
  } else {
    t = translate(x2 + dx, y2 + dy);
  }
  emit2("transform", t);
}
function bound(bounds2, item, mode) {
  var h2 = textMetrics.height(item), a = item.align, p = anchorPoint(item), x2 = p.x1, y2 = p.y1, dx = item.dx || 0, dy = (item.dy || 0) + offset2(item) - Math.round(0.8 * h2), tl2 = textLines(item), w3;
  if (isArray(tl2)) {
    h2 += lineHeight(item) * (tl2.length - 1);
    w3 = tl2.reduce((w4, t) => Math.max(w4, textMetrics.width(item, t)), 0);
  } else {
    w3 = textMetrics.width(item, tl2);
  }
  if (a === "center") {
    dx -= w3 / 2;
  } else if (a === "right") {
    dx -= w3;
  } else
    ;
  bounds2.set(dx += x2, dy += y2, dx + w3, dy + h2);
  if (item.angle && !mode) {
    bounds2.rotate(item.angle * DegToRad, x2, y2);
  } else if (mode === 2) {
    return bounds2.rotatedPoints(item.angle * DegToRad, x2, y2);
  }
  return bounds2;
}
function draw(context3, scene, bounds2) {
  visit(scene, (item) => {
    var opacity = item.opacity == null ? 1 : item.opacity, p, x2, y2, i, lh, tl2, str;
    if (bounds2 && !bounds2.intersects(item.bounds) || // bounds check
    opacity === 0 || item.fontSize <= 0 || item.text == null || item.text.length === 0)
      return;
    context3.font = font(item);
    context3.textAlign = item.align || "left";
    p = anchorPoint(item);
    x2 = p.x1, y2 = p.y1;
    if (item.angle) {
      context3.save();
      context3.translate(x2, y2);
      context3.rotate(item.angle * DegToRad);
      x2 = y2 = 0;
    }
    x2 += item.dx || 0;
    y2 += (item.dy || 0) + offset2(item);
    tl2 = textLines(item);
    blend(context3, item);
    if (isArray(tl2)) {
      lh = lineHeight(item);
      for (i = 0; i < tl2.length; ++i) {
        str = textValue(item, tl2[i]);
        if (item.fill && fill(context3, item, opacity)) {
          context3.fillText(str, x2, y2);
        }
        if (item.stroke && stroke(context3, item, opacity)) {
          context3.strokeText(str, x2, y2);
        }
        y2 += lh;
      }
    } else {
      str = textValue(item, tl2);
      if (item.fill && fill(context3, item, opacity)) {
        context3.fillText(str, x2, y2);
      }
      if (item.stroke && stroke(context3, item, opacity)) {
        context3.strokeText(str, x2, y2);
      }
    }
    if (item.angle)
      context3.restore();
  });
}
function hit(context3, item, x2, y2, gx, gy) {
  if (item.fontSize <= 0)
    return false;
  if (!item.angle)
    return true;
  var p = anchorPoint(item), ax = p.x1, ay = p.y1, b2 = bound(tempBounds, item, 1), a = -item.angle * DegToRad, cos2 = Math.cos(a), sin2 = Math.sin(a), px2 = cos2 * gx - sin2 * gy + (ax - cos2 * ax + sin2 * ay), py2 = sin2 * gx + cos2 * gy + (ay - sin2 * ax - cos2 * ay);
  return b2.contains(px2, py2);
}
function intersectText(item, box) {
  const p = bound(tempBounds, item, 2);
  return intersectBoxLine(box, p[0], p[1], p[2], p[3]) || intersectBoxLine(box, p[0], p[1], p[4], p[5]) || intersectBoxLine(box, p[4], p[5], p[6], p[7]) || intersectBoxLine(box, p[2], p[3], p[6], p[7]);
}
var text = {
  type: "text",
  tag: "text",
  nested: false,
  attr,
  bound,
  draw,
  pick: pick$1(hit),
  isect: intersectText
};
var trail = markMultiItemPath("trail", trail$1, pickTrail);
var Marks = {
  arc,
  area,
  group,
  image,
  line,
  path: path$2,
  rect,
  rule,
  shape,
  symbol,
  text,
  trail
};
function boundItem(item, func, opt) {
  var type2 = Marks[item.mark.marktype], bound2 = func || type2.bound;
  if (type2.nested)
    item = item.mark;
  return bound2(item.bounds || (item.bounds = new Bounds()), item, opt);
}
var DUMMY = {
  mark: null
};
function boundMark(mark, bounds2, opt) {
  var type2 = Marks[mark.marktype], bound2 = type2.bound, items = mark.items, hasItems = items && items.length, i, n, item, b2;
  if (type2.nested) {
    if (hasItems) {
      item = items[0];
    } else {
      DUMMY.mark = mark;
      item = DUMMY;
    }
    b2 = boundItem(item, bound2, opt);
    bounds2 = bounds2 && bounds2.union(b2) || b2;
    return bounds2;
  }
  bounds2 = bounds2 || mark.bounds && mark.bounds.clear() || new Bounds();
  if (hasItems) {
    for (i = 0, n = items.length; i < n; ++i) {
      bounds2.union(boundItem(items[i], bound2, opt));
    }
  }
  return mark.bounds = bounds2;
}
var keys = [
  "marktype",
  "name",
  "role",
  "interactive",
  "clip",
  "items",
  "zindex",
  "x",
  "y",
  "width",
  "height",
  "align",
  "baseline",
  // layout
  "fill",
  "fillOpacity",
  "opacity",
  "blend",
  // fill
  "stroke",
  "strokeOpacity",
  "strokeWidth",
  "strokeCap",
  // stroke
  "strokeDash",
  "strokeDashOffset",
  // stroke dash
  "strokeForeground",
  "strokeOffset",
  // group
  "startAngle",
  "endAngle",
  "innerRadius",
  "outerRadius",
  // arc
  "cornerRadius",
  "padAngle",
  // arc, rect
  "cornerRadiusTopLeft",
  "cornerRadiusTopRight",
  // rect, group
  "cornerRadiusBottomLeft",
  "cornerRadiusBottomRight",
  "interpolate",
  "tension",
  "orient",
  "defined",
  // area, line
  "url",
  "aspect",
  "smooth",
  // image
  "path",
  "scaleX",
  "scaleY",
  // path
  "x2",
  "y2",
  // rule
  "size",
  "shape",
  // symbol
  "text",
  "angle",
  "theta",
  "radius",
  "dir",
  "dx",
  "dy",
  // text
  "ellipsis",
  "limit",
  "lineBreak",
  "lineHeight",
  "font",
  "fontSize",
  "fontWeight",
  "fontStyle",
  "fontVariant",
  // font
  "description",
  "aria",
  "ariaRole",
  "ariaRoleDescription"
  // aria
];
function sceneToJSON(scene, indent) {
  return JSON.stringify(scene, keys, indent);
}
function sceneFromJSON(json2) {
  const scene = typeof json2 === "string" ? JSON.parse(json2) : json2;
  return initialize(scene);
}
function initialize(scene) {
  var type2 = scene.marktype, items = scene.items, parent, i, n;
  if (items) {
    for (i = 0, n = items.length; i < n; ++i) {
      parent = type2 ? "mark" : "group";
      items[i][parent] = scene;
      if (items[i].zindex)
        items[i][parent].zdirty = true;
      if ("group" === (type2 || parent))
        initialize(items[i]);
    }
  }
  if (type2)
    boundMark(scene);
  return scene;
}
function Scenegraph(scene) {
  if (arguments.length) {
    this.root = sceneFromJSON(scene);
  } else {
    this.root = createMark({
      marktype: "group",
      name: "root",
      role: "frame"
    });
    this.root.items = [new GroupItem(this.root)];
  }
}
Scenegraph.prototype = {
  toJSON(indent) {
    return sceneToJSON(this.root, indent || 0);
  },
  mark(markdef, group2, index2) {
    group2 = group2 || this.root.items[0];
    const mark = createMark(markdef, group2);
    group2.items[index2] = mark;
    if (mark.zindex)
      mark.group.zdirty = true;
    return mark;
  }
};
function createMark(def2, group2) {
  const mark = {
    bounds: new Bounds(),
    clip: !!def2.clip,
    group: group2,
    interactive: def2.interactive === false ? false : true,
    items: [],
    marktype: def2.marktype,
    name: def2.name || void 0,
    role: def2.role || void 0,
    zindex: def2.zindex || 0
  };
  if (def2.aria != null) {
    mark.aria = def2.aria;
  }
  if (def2.description) {
    mark.description = def2.description;
  }
  return mark;
}
function domCreate(doc, tag, ns) {
  if (!doc && typeof document !== "undefined" && document.createElement) {
    doc = document;
  }
  return doc ? ns ? doc.createElementNS(ns, tag) : doc.createElement(tag) : null;
}
function domFind(el, tag) {
  tag = tag.toLowerCase();
  var nodes = el.childNodes, i = 0, n = nodes.length;
  for (; i < n; ++i)
    if (nodes[i].tagName.toLowerCase() === tag) {
      return nodes[i];
    }
}
function domChild(el, index2, tag, ns) {
  var a = el.childNodes[index2], b2;
  if (!a || a.tagName.toLowerCase() !== tag.toLowerCase()) {
    b2 = a || null;
    a = domCreate(el.ownerDocument, tag, ns);
    el.insertBefore(a, b2);
  }
  return a;
}
function domClear(el, index2) {
  var nodes = el.childNodes, curr = nodes.length;
  while (curr > index2)
    el.removeChild(nodes[--curr]);
  return el;
}
function cssClass(mark) {
  return "mark-" + mark.marktype + (mark.role ? " role-" + mark.role : "") + (mark.name ? " " + mark.name : "");
}
function point2(event2, el) {
  const rect2 = el.getBoundingClientRect();
  return [event2.clientX - rect2.left - (el.clientLeft || 0), event2.clientY - rect2.top - (el.clientTop || 0)];
}
function resolveItem(item, event2, el, origin) {
  var mark = item && item.mark, mdef, p;
  if (mark && (mdef = Marks[mark.marktype]).tip) {
    p = point2(event2, el);
    p[0] -= origin[0];
    p[1] -= origin[1];
    while (item = item.mark.group) {
      p[0] -= item.x || 0;
      p[1] -= item.y || 0;
    }
    item = mdef.tip(mark.items, p);
  }
  return item;
}
function Handler(customLoader, customTooltip) {
  this._active = null;
  this._handlers = {};
  this._loader = customLoader || loader();
  this._tooltip = customTooltip || defaultTooltip;
}
function defaultTooltip(handler, event2, item, value3) {
  handler.element().setAttribute("title", value3 || "");
}
Handler.prototype = {
  /**
   * Initialize a new Handler instance.
   * @param {DOMElement} el - The containing DOM element for the display.
   * @param {Array<number>} origin - The origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {object} [obj] - Optional context object that should serve as
   *   the "this" context for event callbacks.
   * @return {Handler} - This handler instance.
   */
  initialize(el, origin, obj) {
    this._el = el;
    this._obj = obj || null;
    return this.origin(origin);
  },
  /**
   * Returns the parent container element for a visualization.
   * @return {DOMElement} - The containing DOM element.
   */
  element() {
    return this._el;
  },
  /**
   * Returns the scene element (e.g., canvas or SVG) of the visualization
   * Subclasses must override if the first child is not the scene element.
   * @return {DOMElement} - The scene (e.g., canvas or SVG) element.
   */
  canvas() {
    return this._el && this._el.firstChild;
  },
  /**
   * Get / set the origin coordinates of the visualization.
   */
  origin(origin) {
    if (arguments.length) {
      this._origin = origin || [0, 0];
      return this;
    } else {
      return this._origin.slice();
    }
  },
  /**
   * Get / set the scenegraph root.
   */
  scene(scene) {
    if (!arguments.length)
      return this._scene;
    this._scene = scene;
    return this;
  },
  /**
   * Add an event handler. Subclasses should override this method.
   */
  on() {
  },
  /**
   * Remove an event handler. Subclasses should override this method.
   */
  off() {
  },
  /**
   * Utility method for finding the array index of an event handler.
   * @param {Array} h - An array of registered event handlers.
   * @param {string} type - The event type.
   * @param {function} handler - The event handler instance to find.
   * @return {number} - The handler's array index or -1 if not registered.
   */
  _handlerIndex(h2, type2, handler) {
    for (let i = h2 ? h2.length : 0; --i >= 0; ) {
      if (h2[i].type === type2 && (!handler || h2[i].handler === handler)) {
        return i;
      }
    }
    return -1;
  },
  /**
   * Returns an array with registered event handlers.
   * @param {string} [type] - The event type to query. Any annotations
   *   are ignored; for example, for the argument "click.foo", ".foo" will
   *   be ignored and the method returns all "click" handlers. If type is
   *   null or unspecified, this method returns handlers for all types.
   * @return {Array} - A new array containing all registered event handlers.
   */
  handlers(type2) {
    const h2 = this._handlers, a = [];
    if (type2) {
      a.push(...h2[this.eventName(type2)]);
    } else {
      for (const k2 in h2) {
        a.push(...h2[k2]);
      }
    }
    return a;
  },
  /**
   * Parses an event name string to return the specific event type.
   * For example, given "click.foo" returns "click"
   * @param {string} name - The input event type string.
   * @return {string} - A string with the event type only.
   */
  eventName(name) {
    const i = name.indexOf(".");
    return i < 0 ? name : name.slice(0, i);
  },
  /**
   * Handle hyperlink navigation in response to an item.href value.
   * @param {Event} event - The event triggering hyperlink navigation.
   * @param {Item} item - The scenegraph item.
   * @param {string} href - The URL to navigate to.
   */
  handleHref(event2, item, href2) {
    this._loader.sanitize(href2, {
      context: "href"
    }).then((opt) => {
      const e = new MouseEvent(event2.type, event2), a = domCreate(null, "a");
      for (const name in opt)
        a.setAttribute(name, opt[name]);
      a.dispatchEvent(e);
    }).catch(() => {
    });
  },
  /**
   * Handle tooltip display in response to an item.tooltip value.
   * @param {Event} event - The event triggering tooltip display.
   * @param {Item} item - The scenegraph item.
   * @param {boolean} show - A boolean flag indicating whether
   *   to show or hide a tooltip for the given item.
   */
  handleTooltip(event2, item, show) {
    if (item && item.tooltip != null) {
      item = resolveItem(item, event2, this.canvas(), this._origin);
      const value3 = show && item && item.tooltip || null;
      this._tooltip.call(this._obj, this, event2, item, value3);
    }
  },
  /**
   * Returns the size of a scenegraph item and its position relative
   * to the viewport.
   * @param {Item} item - The scenegraph item.
   * @return {object} - A bounding box object (compatible with the
   *   DOMRect type) consisting of x, y, width, heigh, top, left,
   *   right, and bottom properties.
   */
  getItemBoundingClientRect(item) {
    const el = this.canvas();
    if (!el)
      return;
    const rect2 = el.getBoundingClientRect(), origin = this._origin, bounds2 = item.bounds, width2 = bounds2.width(), height2 = bounds2.height();
    let x2 = bounds2.x1 + origin[0] + rect2.left, y2 = bounds2.y1 + origin[1] + rect2.top;
    while (item.mark && (item = item.mark.group)) {
      x2 += item.x || 0;
      y2 += item.y || 0;
    }
    return {
      x: x2,
      y: y2,
      width: width2,
      height: height2,
      left: x2,
      top: y2,
      right: x2 + width2,
      bottom: y2 + height2
    };
  }
};
function Renderer(loader2) {
  this._el = null;
  this._bgcolor = null;
  this._loader = new ResourceLoader(loader2);
}
Renderer.prototype = {
  /**
   * Initialize a new Renderer instance.
   * @param {DOMElement} el - The containing DOM element for the display.
   * @param {number} width - The coordinate width of the display, in pixels.
   * @param {number} height - The coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {Renderer} - This renderer instance.
   */
  initialize(el, width2, height2, origin, scaleFactor) {
    this._el = el;
    return this.resize(width2, height2, origin, scaleFactor);
  },
  /**
   * Returns the parent container element for a visualization.
   * @return {DOMElement} - The containing DOM element.
   */
  element() {
    return this._el;
  },
  /**
   * Returns the scene element (e.g., canvas or SVG) of the visualization
   * Subclasses must override if the first child is not the scene element.
   * @return {DOMElement} - The scene (e.g., canvas or SVG) element.
   */
  canvas() {
    return this._el && this._el.firstChild;
  },
  /**
   * Get / set the background color.
   */
  background(bgcolor) {
    if (arguments.length === 0)
      return this._bgcolor;
    this._bgcolor = bgcolor;
    return this;
  },
  /**
   * Resize the display.
   * @param {number} width - The new coordinate width of the display, in pixels.
   * @param {number} height - The new coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The new origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {Renderer} - This renderer instance;
   */
  resize(width2, height2, origin, scaleFactor) {
    this._width = width2;
    this._height = height2;
    this._origin = origin || [0, 0];
    this._scale = scaleFactor || 1;
    return this;
  },
  /**
   * Report a dirty item whose bounds should be redrawn.
   * This base class method does nothing. Subclasses that perform
   * incremental should implement this method.
   * @param {Item} item - The dirty item whose bounds should be redrawn.
   */
  dirty() {
  },
  /**
   * Render an input scenegraph, potentially with a set of dirty items.
   * This method will perform an immediate rendering with available resources.
   * The renderer may also need to perform image loading to perform a complete
   * render. This process can lead to asynchronous re-rendering of the scene
   * after this method returns. To receive notification when rendering is
   * complete, use the renderAsync method instead.
   * @param {object} scene - The root mark of a scenegraph to render.
   * @param {Array} markTypes - Array of the mark types to render.
   *                            If undefined, render all mark types
   * @return {Renderer} - This renderer instance.
   */
  render(scene, markTypes) {
    const r = this;
    r._call = function() {
      r._render(scene, markTypes);
    };
    r._call();
    r._call = null;
    return r;
  },
  /**
   * Internal rendering method. Renderer subclasses should override this
   * method to actually perform rendering.
   * @param {object} scene - The root mark of a scenegraph to render.
   * @param {Array} markTypes - Array of the mark types to render.
   *                            If undefined, render all mark types
   */
  _render() {
  },
  /**
   * Asynchronous rendering method. Similar to render, but returns a Promise
   * that resolves when all rendering is completed. Sometimes a renderer must
   * perform image loading to get a complete rendering. The returned
   * Promise will not resolve until this process completes.
   * @param {object} scene - The root mark of a scenegraph to render.
   * @param {Array} markTypes - Array of the mark types to render.
   *                            If undefined, render all mark types
   * @return {Promise} - A Promise that resolves when rendering is complete.
   */
  renderAsync(scene, markTypes) {
    const r = this.render(scene, markTypes);
    return this._ready ? this._ready.then(() => r) : Promise.resolve(r);
  },
  /**
   * Internal method for asynchronous resource loading.
   * Proxies method calls to the ImageLoader, and tracks loading
   * progress to invoke a re-render once complete.
   * @param {string} method - The method name to invoke on the ImageLoader.
   * @param {string} uri - The URI for the requested resource.
   * @return {Promise} - A Promise that resolves to the requested resource.
   */
  _load(method2, uri) {
    var r = this, p = r._loader[method2](uri);
    if (!r._ready) {
      const call = r._call;
      r._ready = r._loader.ready().then((redraw) => {
        if (redraw)
          call();
        r._ready = null;
      });
    }
    return p;
  },
  /**
   * Sanitize a URL to include as a hyperlink in the rendered scene.
   * This method proxies a call to ImageLoader.sanitizeURL, but also tracks
   * image loading progress and invokes a re-render once complete.
   * @param {string} uri - The URI string to sanitize.
   * @return {Promise} - A Promise that resolves to the sanitized URL.
   */
  sanitizeURL(uri) {
    return this._load("sanitizeURL", uri);
  },
  /**
   * Requests an image to include in the rendered scene.
   * This method proxies a call to ImageLoader.loadImage, but also tracks
   * image loading progress and invokes a re-render once complete.
   * @param {string} uri - The URI string of the image.
   * @return {Promise} - A Promise that resolves to the loaded Image.
   */
  loadImage(uri) {
    return this._load("loadImage", uri);
  }
};
var KeyDownEvent = "keydown";
var KeyPressEvent = "keypress";
var KeyUpEvent = "keyup";
var DragEnterEvent = "dragenter";
var DragLeaveEvent = "dragleave";
var DragOverEvent = "dragover";
var PointerDownEvent = "pointerdown";
var PointerUpEvent = "pointerup";
var PointerMoveEvent = "pointermove";
var PointerOutEvent = "pointerout";
var PointerOverEvent = "pointerover";
var MouseDownEvent = "mousedown";
var MouseUpEvent = "mouseup";
var MouseMoveEvent = "mousemove";
var MouseOutEvent = "mouseout";
var MouseOverEvent = "mouseover";
var ClickEvent = "click";
var DoubleClickEvent = "dblclick";
var WheelEvent = "wheel";
var MouseWheelEvent = "mousewheel";
var TouchStartEvent = "touchstart";
var TouchMoveEvent = "touchmove";
var TouchEndEvent = "touchend";
var Events = [KeyDownEvent, KeyPressEvent, KeyUpEvent, DragEnterEvent, DragLeaveEvent, DragOverEvent, PointerDownEvent, PointerUpEvent, PointerMoveEvent, PointerOutEvent, PointerOverEvent, MouseDownEvent, MouseUpEvent, MouseMoveEvent, MouseOutEvent, MouseOverEvent, ClickEvent, DoubleClickEvent, WheelEvent, MouseWheelEvent, TouchStartEvent, TouchMoveEvent, TouchEndEvent];
var TooltipShowEvent = PointerMoveEvent;
var TooltipHideEvent = PointerOutEvent;
var HrefEvent = ClickEvent;
function CanvasHandler(loader2, tooltip) {
  Handler.call(this, loader2, tooltip);
  this._down = null;
  this._touch = null;
  this._first = true;
  this._events = {};
}
var eventBundle = (type2) => type2 === TouchStartEvent || type2 === TouchMoveEvent || type2 === TouchEndEvent ? [TouchStartEvent, TouchMoveEvent, TouchEndEvent] : [type2];
function eventListenerCheck(handler, type2) {
  eventBundle(type2).forEach((_) => addEventListener(handler, _));
}
function addEventListener(handler, type2) {
  const canvas = handler.canvas();
  if (canvas && !handler._events[type2]) {
    handler._events[type2] = 1;
    canvas.addEventListener(type2, handler[type2] ? (evt) => handler[type2](evt) : (evt) => handler.fire(type2, evt));
  }
}
function fireAll(handler, types, event2) {
  types.forEach((type2) => handler.fire(type2, event2));
}
function move(moveEvents, overEvents, outEvents) {
  return function(evt) {
    const a = this._active, p = this.pickEvent(evt);
    if (p === a) {
      fireAll(this, moveEvents, evt);
    } else {
      if (!a || !a.exit) {
        fireAll(this, outEvents, evt);
      }
      this._active = p;
      fireAll(this, overEvents, evt);
      fireAll(this, moveEvents, evt);
    }
  };
}
function inactive(types) {
  return function(evt) {
    fireAll(this, types, evt);
    this._active = null;
  };
}
inherits(CanvasHandler, Handler, {
  initialize(el, origin, obj) {
    this._canvas = el && domFind(el, "canvas");
    [ClickEvent, MouseDownEvent, PointerDownEvent, PointerMoveEvent, PointerOutEvent, DragLeaveEvent].forEach((type2) => eventListenerCheck(this, type2));
    return Handler.prototype.initialize.call(this, el, origin, obj);
  },
  // return the backing canvas instance
  canvas() {
    return this._canvas;
  },
  // retrieve the current canvas context
  context() {
    return this._canvas.getContext("2d");
  },
  // supported events
  events: Events,
  // to keep old versions of firefox happy
  DOMMouseScroll(evt) {
    this.fire(MouseWheelEvent, evt);
  },
  pointermove: move([PointerMoveEvent, MouseMoveEvent], [PointerOverEvent, MouseOverEvent], [PointerOutEvent, MouseOutEvent]),
  dragover: move([DragOverEvent], [DragEnterEvent], [DragLeaveEvent]),
  pointerout: inactive([PointerOutEvent, MouseOutEvent]),
  dragleave: inactive([DragLeaveEvent]),
  pointerdown(evt) {
    this._down = this._active;
    this.fire(PointerDownEvent, evt);
  },
  mousedown(evt) {
    this._down = this._active;
    this.fire(MouseDownEvent, evt);
  },
  click(evt) {
    if (this._down === this._active) {
      this.fire(ClickEvent, evt);
      this._down = null;
    }
  },
  touchstart(evt) {
    this._touch = this.pickEvent(evt.changedTouches[0]);
    if (this._first) {
      this._active = this._touch;
      this._first = false;
    }
    this.fire(TouchStartEvent, evt, true);
  },
  touchmove(evt) {
    this.fire(TouchMoveEvent, evt, true);
  },
  touchend(evt) {
    this.fire(TouchEndEvent, evt, true);
    this._touch = null;
  },
  // fire an event
  fire(type2, evt, touch2) {
    const a = touch2 ? this._touch : this._active, h2 = this._handlers[type2];
    evt.vegaType = type2;
    if (type2 === HrefEvent && a && a.href) {
      this.handleHref(evt, a, a.href);
    } else if (type2 === TooltipShowEvent || type2 === TooltipHideEvent) {
      this.handleTooltip(evt, a, type2 !== TooltipHideEvent);
    }
    if (h2) {
      for (let i = 0, len = h2.length; i < len; ++i) {
        h2[i].handler.call(this._obj, evt, a);
      }
    }
  },
  // add an event handler
  on(type2, handler) {
    const name = this.eventName(type2), h2 = this._handlers, i = this._handlerIndex(h2[name], type2, handler);
    if (i < 0) {
      eventListenerCheck(this, type2);
      (h2[name] || (h2[name] = [])).push({
        type: type2,
        handler
      });
    }
    return this;
  },
  // remove an event handler
  off(type2, handler) {
    const name = this.eventName(type2), h2 = this._handlers[name], i = this._handlerIndex(h2, type2, handler);
    if (i >= 0) {
      h2.splice(i, 1);
    }
    return this;
  },
  pickEvent(evt) {
    const p = point2(evt, this._canvas), o = this._origin;
    return this.pick(this._scene, p[0], p[1], p[0] - o[0], p[1] - o[1]);
  },
  // find the scenegraph item at the current pointer position
  // x, y -- the absolute x, y pointer coordinates on the canvas element
  // gx, gy -- the relative coordinates within the current group
  pick(scene, x2, y2, gx, gy) {
    const g = this.context(), mark = Marks[scene.marktype];
    return mark.pick.call(this, g, scene, x2, y2, gx, gy);
  }
});
function devicePixelRatio() {
  return typeof window !== "undefined" ? window.devicePixelRatio || 1 : 1;
}
function resize(canvas, width2, height2, origin, scaleFactor, opt) {
  const inDOM = typeof HTMLElement !== "undefined" && canvas instanceof HTMLElement && canvas.parentNode != null, context3 = canvas.getContext("2d"), ratio = inDOM ? devicePixelRatio() : scaleFactor;
  canvas.width = width2 * ratio;
  canvas.height = height2 * ratio;
  for (const key2 in opt) {
    context3[key2] = opt[key2];
  }
  if (inDOM && ratio !== 1) {
    canvas.style.width = width2 + "px";
    canvas.style.height = height2 + "px";
  }
  context3.pixelRatio = ratio;
  context3.setTransform(ratio, 0, 0, ratio, ratio * origin[0], ratio * origin[1]);
  return canvas;
}
function CanvasRenderer(loader2) {
  Renderer.call(this, loader2);
  this._options = {};
  this._redraw = false;
  this._dirty = new Bounds();
  this._tempb = new Bounds();
}
var base$2 = Renderer.prototype;
var viewBounds = (origin, width2, height2) => new Bounds().set(0, 0, width2, height2).translate(-origin[0], -origin[1]);
function clipToBounds(g, b2, origin) {
  b2.expand(1).round();
  if (g.pixelRatio % 1) {
    b2.scale(g.pixelRatio).round().scale(1 / g.pixelRatio);
  }
  b2.translate(-(origin[0] % 1), -(origin[1] % 1));
  g.beginPath();
  g.rect(b2.x1, b2.y1, b2.width(), b2.height());
  g.clip();
  return b2;
}
inherits(CanvasRenderer, Renderer, {
  initialize(el, width2, height2, origin, scaleFactor, options) {
    this._options = options || {};
    this._canvas = this._options.externalContext ? null : domCanvas(1, 1, this._options.type);
    if (el && this._canvas) {
      domClear(el, 0).appendChild(this._canvas);
      this._canvas.setAttribute("class", "marks");
    }
    return base$2.initialize.call(this, el, width2, height2, origin, scaleFactor);
  },
  resize(width2, height2, origin, scaleFactor) {
    base$2.resize.call(this, width2, height2, origin, scaleFactor);
    if (this._canvas) {
      resize(this._canvas, this._width, this._height, this._origin, this._scale, this._options.context);
    } else {
      const ctx = this._options.externalContext;
      if (!ctx)
        error("CanvasRenderer is missing a valid canvas or context");
      ctx.scale(this._scale, this._scale);
      ctx.translate(this._origin[0], this._origin[1]);
    }
    this._redraw = true;
    return this;
  },
  canvas() {
    return this._canvas;
  },
  context() {
    return this._options.externalContext || (this._canvas ? this._canvas.getContext("2d") : null);
  },
  dirty(item) {
    const b2 = this._tempb.clear().union(item.bounds);
    let g = item.mark.group;
    while (g) {
      b2.translate(g.x || 0, g.y || 0);
      g = g.mark.group;
    }
    this._dirty.union(b2);
  },
  _render(scene, markTypes) {
    const g = this.context(), o = this._origin, w3 = this._width, h2 = this._height, db = this._dirty, vb = viewBounds(o, w3, h2);
    g.save();
    const b2 = this._redraw || db.empty() ? (this._redraw = false, vb.expand(1)) : clipToBounds(g, vb.intersect(db), o);
    this.clear(-o[0], -o[1], w3, h2);
    this.draw(g, scene, b2, markTypes);
    g.restore();
    db.clear();
    return this;
  },
  draw(ctx, scene, bounds2, markTypes) {
    if (scene.marktype !== "group" && markTypes != null && !markTypes.includes(scene.marktype)) {
      return;
    }
    const mark = Marks[scene.marktype];
    if (scene.clip)
      clip(ctx, scene);
    mark.draw.call(this, ctx, scene, bounds2, markTypes);
    if (scene.clip)
      ctx.restore();
  },
  clear(x2, y2, w3, h2) {
    const opt = this._options, g = this.context();
    if (opt.type !== "pdf" && !opt.externalContext) {
      g.clearRect(x2, y2, w3, h2);
    }
    if (this._bgcolor != null) {
      g.fillStyle = this._bgcolor;
      g.fillRect(x2, y2, w3, h2);
    }
  }
});
function SVGHandler(loader2, tooltip) {
  Handler.call(this, loader2, tooltip);
  const h2 = this;
  h2._hrefHandler = listener(h2, (evt, item) => {
    if (item && item.href)
      h2.handleHref(evt, item, item.href);
  });
  h2._tooltipHandler = listener(h2, (evt, item) => {
    h2.handleTooltip(evt, item, evt.type !== TooltipHideEvent);
  });
}
var listener = (context3, handler) => (evt) => {
  let item = evt.target.__data__;
  item = Array.isArray(item) ? item[0] : item;
  evt.vegaType = evt.type;
  handler.call(context3._obj, evt, item);
};
inherits(SVGHandler, Handler, {
  initialize(el, origin, obj) {
    let svg = this._svg;
    if (svg) {
      svg.removeEventListener(HrefEvent, this._hrefHandler);
      svg.removeEventListener(TooltipShowEvent, this._tooltipHandler);
      svg.removeEventListener(TooltipHideEvent, this._tooltipHandler);
    }
    this._svg = svg = el && domFind(el, "svg");
    if (svg) {
      svg.addEventListener(HrefEvent, this._hrefHandler);
      svg.addEventListener(TooltipShowEvent, this._tooltipHandler);
      svg.addEventListener(TooltipHideEvent, this._tooltipHandler);
    }
    return Handler.prototype.initialize.call(this, el, origin, obj);
  },
  canvas() {
    return this._svg;
  },
  // add an event handler
  on(type2, handler) {
    const name = this.eventName(type2), h2 = this._handlers, i = this._handlerIndex(h2[name], type2, handler);
    if (i < 0) {
      const x2 = {
        type: type2,
        handler,
        listener: listener(this, handler)
      };
      (h2[name] || (h2[name] = [])).push(x2);
      if (this._svg) {
        this._svg.addEventListener(name, x2.listener);
      }
    }
    return this;
  },
  // remove an event handler
  off(type2, handler) {
    const name = this.eventName(type2), h2 = this._handlers[name], i = this._handlerIndex(h2, type2, handler);
    if (i >= 0) {
      if (this._svg) {
        this._svg.removeEventListener(name, h2[i].listener);
      }
      h2.splice(i, 1);
    }
    return this;
  }
});
var ARIA_HIDDEN = "aria-hidden";
var ARIA_LABEL = "aria-label";
var ARIA_ROLE = "role";
var ARIA_ROLEDESCRIPTION = "aria-roledescription";
var GRAPHICS_OBJECT = "graphics-object";
var GRAPHICS_SYMBOL = "graphics-symbol";
var bundle = (role, roledesc, label) => ({
  [ARIA_ROLE]: role,
  [ARIA_ROLEDESCRIPTION]: roledesc,
  [ARIA_LABEL]: label || void 0
});
var AriaIgnore = toSet(["axis-domain", "axis-grid", "axis-label", "axis-tick", "axis-title", "legend-band", "legend-entry", "legend-gradient", "legend-label", "legend-title", "legend-symbol", "title"]);
var AriaGuides = {
  "axis": {
    desc: "axis",
    caption: axisCaption
  },
  "legend": {
    desc: "legend",
    caption: legendCaption
  },
  "title-text": {
    desc: "title",
    caption: (item) => `Title text '${titleCaption(item)}'`
  },
  "title-subtitle": {
    desc: "subtitle",
    caption: (item) => `Subtitle text '${titleCaption(item)}'`
  }
};
var AriaEncode = {
  ariaRole: ARIA_ROLE,
  ariaRoleDescription: ARIA_ROLEDESCRIPTION,
  description: ARIA_LABEL
};
function ariaItemAttributes(emit2, item) {
  const hide = item.aria === false;
  emit2(ARIA_HIDDEN, hide || void 0);
  if (hide || item.description == null) {
    for (const prop in AriaEncode) {
      emit2(AriaEncode[prop], void 0);
    }
  } else {
    const type2 = item.mark.marktype;
    emit2(ARIA_LABEL, item.description);
    emit2(ARIA_ROLE, item.ariaRole || (type2 === "group" ? GRAPHICS_OBJECT : GRAPHICS_SYMBOL));
    emit2(ARIA_ROLEDESCRIPTION, item.ariaRoleDescription || `${type2} mark`);
  }
}
function ariaMarkAttributes(mark) {
  return mark.aria === false ? {
    [ARIA_HIDDEN]: true
  } : AriaIgnore[mark.role] ? null : AriaGuides[mark.role] ? ariaGuide(mark, AriaGuides[mark.role]) : ariaMark(mark);
}
function ariaMark(mark) {
  const type2 = mark.marktype;
  const recurse2 = type2 === "group" || type2 === "text" || mark.items.some((_) => _.description != null && _.aria !== false);
  return bundle(recurse2 ? GRAPHICS_OBJECT : GRAPHICS_SYMBOL, `${type2} mark container`, mark.description);
}
function ariaGuide(mark, opt) {
  try {
    const item = mark.items[0], caption = opt.caption || (() => "");
    return bundle(opt.role || GRAPHICS_SYMBOL, opt.desc, item.description || caption(item));
  } catch (err) {
    return null;
  }
}
function titleCaption(item) {
  return array(item.text).join(" ");
}
function axisCaption(item) {
  const datum2 = item.datum, orient = item.orient, title = datum2.title ? extractTitle(item) : null, ctx = item.context, scale6 = ctx.scales[datum2.scale].value, locale2 = ctx.dataflow.locale(), type2 = scale6.type, xy = orient === "left" || orient === "right" ? "Y" : "X";
  return `${xy}-axis` + (title ? ` titled '${title}'` : "") + ` for a ${isDiscrete(type2) ? "discrete" : type2} scale with ${domainCaption(locale2, scale6, item)}`;
}
function legendCaption(item) {
  const datum2 = item.datum, title = datum2.title ? extractTitle(item) : null, type2 = `${datum2.type || ""} legend`.trim(), scales2 = datum2.scales, props = Object.keys(scales2), ctx = item.context, scale6 = ctx.scales[scales2[props[0]]].value, locale2 = ctx.dataflow.locale();
  return capitalize(type2) + (title ? ` titled '${title}'` : "") + ` for ${channelCaption(props)} with ${domainCaption(locale2, scale6, item)}`;
}
function extractTitle(item) {
  try {
    return array(peek(item.items).items[0].text).join(" ");
  } catch (err) {
    return null;
  }
}
function channelCaption(props) {
  props = props.map((p) => p + (p === "fill" || p === "stroke" ? " color" : ""));
  return props.length < 2 ? props[0] : props.slice(0, -1).join(", ") + " and " + peek(props);
}
function capitalize(s) {
  return s.length ? s[0].toUpperCase() + s.slice(1) : s;
}
var innerText = (val) => (val + "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
var attrText = (val) => innerText(val).replace(/"/g, "&quot;").replace(/\t/g, "&#x9;").replace(/\n/g, "&#xA;").replace(/\r/g, "&#xD;");
function markup() {
  let buf = "", outer = "", inner = "";
  const stack = [], clear = () => outer = inner = "", push = (tag) => {
    if (outer) {
      buf += `${outer}>${inner}`;
      clear();
    }
    stack.push(tag);
  }, attr2 = (name, value3) => {
    if (value3 != null)
      outer += ` ${name}="${attrText(value3)}"`;
    return m;
  }, m = {
    open(tag) {
      push(tag);
      outer = "<" + tag;
      for (var _len = arguments.length, attrs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        attrs[_key - 1] = arguments[_key];
      }
      for (const set4 of attrs) {
        for (const key2 in set4)
          attr2(key2, set4[key2]);
      }
      return m;
    },
    close() {
      const tag = stack.pop();
      if (outer) {
        buf += outer + (inner ? `>${inner}</${tag}>` : "/>");
      } else {
        buf += `</${tag}>`;
      }
      clear();
      return m;
    },
    attr: attr2,
    text: (t) => (inner += innerText(t), m),
    toString: () => buf
  };
  return m;
}
var serializeXML = (node) => _serialize(markup(), node) + "";
function _serialize(m, node) {
  m.open(node.tagName);
  if (node.hasAttributes()) {
    const attrs = node.attributes, n = attrs.length;
    for (let i = 0; i < n; ++i) {
      m.attr(attrs[i].name, attrs[i].value);
    }
  }
  if (node.hasChildNodes()) {
    const children3 = node.childNodes;
    for (const child of children3) {
      child.nodeType === 3 ? m.text(child.nodeValue) : _serialize(m, child);
    }
  }
  return m.close();
}
var stylesAttr = {
  fill: "fill",
  fillOpacity: "fill-opacity",
  stroke: "stroke",
  strokeOpacity: "stroke-opacity",
  strokeWidth: "stroke-width",
  strokeCap: "stroke-linecap",
  strokeJoin: "stroke-linejoin",
  strokeDash: "stroke-dasharray",
  strokeDashOffset: "stroke-dashoffset",
  strokeMiterLimit: "stroke-miterlimit",
  opacity: "opacity"
};
var stylesCss = {
  blend: "mix-blend-mode"
};
var rootAttributes = {
  "fill": "none",
  "stroke-miterlimit": 10
};
var RootIndex = 0;
var xmlns = "http://www.w3.org/2000/xmlns/";
var svgns = metadata.xmlns;
function SVGRenderer(loader2) {
  Renderer.call(this, loader2);
  this._dirtyID = 0;
  this._dirty = [];
  this._svg = null;
  this._root = null;
  this._defs = null;
}
var base$1 = Renderer.prototype;
inherits(SVGRenderer, Renderer, {
  /**
   * Initialize a new SVGRenderer instance.
   * @param {DOMElement} el - The containing DOM element for the display.
   * @param {number} width - The coordinate width of the display, in pixels.
   * @param {number} height - The coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {SVGRenderer} - This renderer instance.
   */
  initialize(el, width2, height2, origin, scaleFactor) {
    this._defs = {};
    this._clearDefs();
    if (el) {
      this._svg = domChild(el, 0, "svg", svgns);
      this._svg.setAttributeNS(xmlns, "xmlns", svgns);
      this._svg.setAttributeNS(xmlns, "xmlns:xlink", metadata["xmlns:xlink"]);
      this._svg.setAttribute("version", metadata["version"]);
      this._svg.setAttribute("class", "marks");
      domClear(el, 1);
      this._root = domChild(this._svg, RootIndex, "g", svgns);
      setAttributes(this._root, rootAttributes);
      domClear(this._svg, RootIndex + 1);
    }
    this.background(this._bgcolor);
    return base$1.initialize.call(this, el, width2, height2, origin, scaleFactor);
  },
  /**
   * Get / set the background color.
   */
  background(bgcolor) {
    if (arguments.length && this._svg) {
      this._svg.style.setProperty("background-color", bgcolor);
    }
    return base$1.background.apply(this, arguments);
  },
  /**
   * Resize the display.
   * @param {number} width - The new coordinate width of the display, in pixels.
   * @param {number} height - The new coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The new origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {SVGRenderer} - This renderer instance;
   */
  resize(width2, height2, origin, scaleFactor) {
    base$1.resize.call(this, width2, height2, origin, scaleFactor);
    if (this._svg) {
      setAttributes(this._svg, {
        width: this._width * this._scale,
        height: this._height * this._scale,
        viewBox: `0 0 ${this._width} ${this._height}`
      });
      this._root.setAttribute("transform", `translate(${this._origin})`);
    }
    this._dirty = [];
    return this;
  },
  /**
   * Returns the SVG element of the visualization.
   * @return {DOMElement} - The SVG element.
   */
  canvas() {
    return this._svg;
  },
  /**
   * Returns an SVG text string for the rendered content,
   * or null if this renderer is currently headless.
   */
  svg() {
    const svg = this._svg, bg = this._bgcolor;
    if (!svg)
      return null;
    let node;
    if (bg) {
      svg.removeAttribute("style");
      node = domChild(svg, RootIndex, "rect", svgns);
      setAttributes(node, {
        width: this._width,
        height: this._height,
        fill: bg
      });
    }
    const text2 = serializeXML(svg);
    if (bg) {
      svg.removeChild(node);
      this._svg.style.setProperty("background-color", bg);
    }
    return text2;
  },
  /**
   * Internal rendering method.
   * @param {object} scene - The root mark of a scenegraph to render.
   * @param {Array} markTypes - Array of the mark types to render.
   *                            If undefined, render all mark types
   */
  _render(scene, markTypes) {
    if (this._dirtyCheck()) {
      if (this._dirtyAll)
        this._clearDefs();
      this.mark(this._root, scene, void 0, markTypes);
      domClear(this._root, 1);
    }
    this.defs();
    this._dirty = [];
    ++this._dirtyID;
    return this;
  },
  // -- Manage rendering of items marked as dirty --
  /**
   * Flag a mark item as dirty.
   * @param {Item} item - The mark item.
   */
  dirty(item) {
    if (item.dirty !== this._dirtyID) {
      item.dirty = this._dirtyID;
      this._dirty.push(item);
    }
  },
  /**
   * Check if a mark item is considered dirty.
   * @param {Item} item - The mark item.
   */
  isDirty(item) {
    return this._dirtyAll || !item._svg || !item._svg.ownerSVGElement || item.dirty === this._dirtyID;
  },
  /**
   * Internal method to check dirty status and, if possible,
   * make targetted updates without a full rendering pass.
   */
  _dirtyCheck() {
    this._dirtyAll = true;
    const items = this._dirty;
    if (!items.length || !this._dirtyID)
      return true;
    const id2 = ++this._dirtyID;
    let item, mark, type2, mdef, i, n, o;
    for (i = 0, n = items.length; i < n; ++i) {
      item = items[i];
      mark = item.mark;
      if (mark.marktype !== type2) {
        type2 = mark.marktype;
        mdef = Marks[type2];
      }
      if (mark.zdirty && mark.dirty !== id2) {
        this._dirtyAll = false;
        dirtyParents(item, id2);
        mark.items.forEach((i2) => {
          i2.dirty = id2;
        });
      }
      if (mark.zdirty)
        continue;
      if (item.exit) {
        if (mdef.nested && mark.items.length) {
          o = mark.items[0];
          if (o._svg)
            this._update(mdef, o._svg, o);
        } else if (item._svg) {
          o = item._svg.parentNode;
          if (o)
            o.removeChild(item._svg);
        }
        item._svg = null;
        continue;
      }
      item = mdef.nested ? mark.items[0] : item;
      if (item._update === id2)
        continue;
      if (!item._svg || !item._svg.ownerSVGElement) {
        this._dirtyAll = false;
        dirtyParents(item, id2);
      } else {
        this._update(mdef, item._svg, item);
      }
      item._update = id2;
    }
    return !this._dirtyAll;
  },
  // -- Construct & maintain scenegraph to SVG mapping ---
  /**
   * Render a set of mark items.
   * @param {SVGElement} el - The parent element in the SVG tree.
   * @param {object} scene - The mark parent to render.
   * @param {SVGElement} prev - The previous sibling in the SVG tree.
   * @param {Array} markTypes - Array of the mark types to render.
   *                            If undefined, render all mark types
   */
  mark(el, scene, prev, markTypes) {
    if (!this.isDirty(scene)) {
      return scene._svg;
    }
    const svg = this._svg, markType2 = scene.marktype, mdef = Marks[markType2], events3 = scene.interactive === false ? "none" : null, isGroup = mdef.tag === "g";
    const parent = bind(scene, el, prev, "g", svg);
    if (markType2 !== "group" && markTypes != null && !markTypes.includes(markType2)) {
      domClear(parent, 0);
      return scene._svg;
    }
    parent.setAttribute("class", cssClass(scene));
    const aria = ariaMarkAttributes(scene);
    for (const key2 in aria)
      setAttribute(parent, key2, aria[key2]);
    if (!isGroup) {
      setAttribute(parent, "pointer-events", events3);
    }
    setAttribute(parent, "clip-path", scene.clip ? clip$1(this, scene, scene.group) : null);
    let sibling = null, i = 0;
    const process = (item) => {
      const dirty = this.isDirty(item), node = bind(item, parent, sibling, mdef.tag, svg);
      if (dirty) {
        this._update(mdef, node, item);
        if (isGroup)
          recurse(this, node, item, markTypes);
      }
      sibling = node;
      ++i;
    };
    if (mdef.nested) {
      if (scene.items.length)
        process(scene.items[0]);
    } else {
      visit(scene, process);
    }
    domClear(parent, i);
    return parent;
  },
  /**
   * Update the attributes of an SVG element for a mark item.
   * @param {object} mdef - The mark definition object
   * @param {SVGElement} el - The SVG element.
   * @param {Item} item - The mark item.
   */
  _update(mdef, el, item) {
    element = el;
    values = el.__values__;
    ariaItemAttributes(emit, item);
    mdef.attr(emit, item, this);
    const extra = mark_extras[mdef.type];
    if (extra)
      extra.call(this, mdef, el, item);
    if (element)
      this.style(element, item);
  },
  /**
   * Update the presentation attributes of an SVG element for a mark item.
   * @param {SVGElement} el - The SVG element.
   * @param {Item} item - The mark item.
   */
  style(el, item) {
    if (item == null)
      return;
    for (const prop in stylesAttr) {
      let value3 = prop === "font" ? fontFamily(item) : item[prop];
      if (value3 === values[prop])
        continue;
      const name = stylesAttr[prop];
      if (value3 == null) {
        el.removeAttribute(name);
      } else {
        if (isGradient(value3)) {
          value3 = gradientRef(value3, this._defs.gradient, href());
        }
        el.setAttribute(name, value3 + "");
      }
      values[prop] = value3;
    }
    for (const prop in stylesCss) {
      setStyle(el, stylesCss[prop], item[prop]);
    }
  },
  /**
   * Render SVG defs, as needed.
   * Must be called *after* marks have been processed to ensure the
   * collected state is current and accurate.
   */
  defs() {
    const svg = this._svg, defs = this._defs;
    let el = defs.el, index2 = 0;
    for (const id2 in defs.gradient) {
      if (!el)
        defs.el = el = domChild(svg, RootIndex + 1, "defs", svgns);
      index2 = updateGradient(el, defs.gradient[id2], index2);
    }
    for (const id2 in defs.clipping) {
      if (!el)
        defs.el = el = domChild(svg, RootIndex + 1, "defs", svgns);
      index2 = updateClipping(el, defs.clipping[id2], index2);
    }
    if (el) {
      index2 === 0 ? (svg.removeChild(el), defs.el = null) : domClear(el, index2);
    }
  },
  /**
   * Clear defs caches.
   */
  _clearDefs() {
    const def2 = this._defs;
    def2.gradient = {};
    def2.clipping = {};
  }
});
function dirtyParents(item, id2) {
  for (; item && item.dirty !== id2; item = item.mark.group) {
    item.dirty = id2;
    if (item.mark && item.mark.dirty !== id2) {
      item.mark.dirty = id2;
    } else
      return;
  }
}
function updateGradient(el, grad, index2) {
  let i, n, stop2;
  if (grad.gradient === "radial") {
    let pt = domChild(el, index2++, "pattern", svgns);
    setAttributes(pt, {
      id: patternPrefix + grad.id,
      viewBox: "0,0,1,1",
      width: "100%",
      height: "100%",
      preserveAspectRatio: "xMidYMid slice"
    });
    pt = domChild(pt, 0, "rect", svgns);
    setAttributes(pt, {
      width: 1,
      height: 1,
      fill: `url(${href()}#${grad.id})`
    });
    el = domChild(el, index2++, "radialGradient", svgns);
    setAttributes(el, {
      id: grad.id,
      fx: grad.x1,
      fy: grad.y1,
      fr: grad.r1,
      cx: grad.x2,
      cy: grad.y2,
      r: grad.r2
    });
  } else {
    el = domChild(el, index2++, "linearGradient", svgns);
    setAttributes(el, {
      id: grad.id,
      x1: grad.x1,
      x2: grad.x2,
      y1: grad.y1,
      y2: grad.y2
    });
  }
  for (i = 0, n = grad.stops.length; i < n; ++i) {
    stop2 = domChild(el, i, "stop", svgns);
    stop2.setAttribute("offset", grad.stops[i].offset);
    stop2.setAttribute("stop-color", grad.stops[i].color);
  }
  domClear(el, i);
  return index2;
}
function updateClipping(el, clip3, index2) {
  let mask;
  el = domChild(el, index2, "clipPath", svgns);
  el.setAttribute("id", clip3.id);
  if (clip3.path) {
    mask = domChild(el, 0, "path", svgns);
    mask.setAttribute("d", clip3.path);
  } else {
    mask = domChild(el, 0, "rect", svgns);
    setAttributes(mask, {
      x: 0,
      y: 0,
      width: clip3.width,
      height: clip3.height
    });
  }
  domClear(el, 1);
  return index2 + 1;
}
function recurse(renderer, el, group2, markTypes) {
  el = el.lastChild.previousSibling;
  let prev, idx = 0;
  visit(group2, (item) => {
    prev = renderer.mark(el, item, prev, markTypes);
    ++idx;
  });
  domClear(el, 1 + idx);
}
function bind(item, el, sibling, tag, svg) {
  let node = item._svg, doc;
  if (!node) {
    doc = el.ownerDocument;
    node = domCreate(doc, tag, svgns);
    item._svg = node;
    if (item.mark) {
      node.__data__ = item;
      node.__values__ = {
        fill: "default"
      };
      if (tag === "g") {
        const bg = domCreate(doc, "path", svgns);
        node.appendChild(bg);
        bg.__data__ = item;
        const cg = domCreate(doc, "g", svgns);
        node.appendChild(cg);
        cg.__data__ = item;
        const fg = domCreate(doc, "path", svgns);
        node.appendChild(fg);
        fg.__data__ = item;
        fg.__values__ = {
          fill: "default"
        };
      }
    }
  }
  if (node.ownerSVGElement !== svg || siblingCheck(node, sibling)) {
    el.insertBefore(node, sibling ? sibling.nextSibling : el.firstChild);
  }
  return node;
}
function siblingCheck(node, sibling) {
  return node.parentNode && node.parentNode.childNodes.length > 1 && node.previousSibling != sibling;
}
var element = null;
var values = null;
var mark_extras = {
  group(mdef, el, item) {
    const fg = element = el.childNodes[2];
    values = fg.__values__;
    mdef.foreground(emit, item, this);
    values = el.__values__;
    element = el.childNodes[1];
    mdef.content(emit, item, this);
    const bg = element = el.childNodes[0];
    mdef.background(emit, item, this);
    const value3 = item.mark.interactive === false ? "none" : null;
    if (value3 !== values.events) {
      setAttribute(fg, "pointer-events", value3);
      setAttribute(bg, "pointer-events", value3);
      values.events = value3;
    }
    if (item.strokeForeground && item.stroke) {
      const fill2 = item.fill;
      setAttribute(fg, "display", null);
      this.style(bg, item);
      setAttribute(bg, "stroke", null);
      if (fill2)
        item.fill = null;
      values = fg.__values__;
      this.style(fg, item);
      if (fill2)
        item.fill = fill2;
      element = null;
    } else {
      setAttribute(fg, "display", "none");
    }
  },
  image(mdef, el, item) {
    if (item.smooth === false) {
      setStyle(el, "image-rendering", "optimizeSpeed");
      setStyle(el, "image-rendering", "pixelated");
    } else {
      setStyle(el, "image-rendering", null);
    }
  },
  text(mdef, el, item) {
    const tl2 = textLines(item);
    let key2, value3, doc, lh;
    if (isArray(tl2)) {
      value3 = tl2.map((_) => textValue(item, _));
      key2 = value3.join("\n");
      if (key2 !== values.text) {
        domClear(el, 0);
        doc = el.ownerDocument;
        lh = lineHeight(item);
        value3.forEach((t, i) => {
          const ts2 = domCreate(doc, "tspan", svgns);
          ts2.__data__ = item;
          ts2.textContent = t;
          if (i) {
            ts2.setAttribute("x", 0);
            ts2.setAttribute("dy", lh);
          }
          el.appendChild(ts2);
        });
        values.text = key2;
      }
    } else {
      value3 = textValue(item, tl2);
      if (value3 !== values.text) {
        el.textContent = value3;
        values.text = value3;
      }
    }
    setAttribute(el, "font-family", fontFamily(item));
    setAttribute(el, "font-size", fontSize(item) + "px");
    setAttribute(el, "font-style", item.fontStyle);
    setAttribute(el, "font-variant", item.fontVariant);
    setAttribute(el, "font-weight", item.fontWeight);
  }
};
function emit(name, value3, ns) {
  if (value3 === values[name])
    return;
  if (ns) {
    setAttributeNS(element, name, value3, ns);
  } else {
    setAttribute(element, name, value3);
  }
  values[name] = value3;
}
function setStyle(el, name, value3) {
  if (value3 !== values[name]) {
    if (value3 == null) {
      el.style.removeProperty(name);
    } else {
      el.style.setProperty(name, value3 + "");
    }
    values[name] = value3;
  }
}
function setAttributes(el, attrs) {
  for (const key2 in attrs) {
    setAttribute(el, key2, attrs[key2]);
  }
}
function setAttribute(el, name, value3) {
  if (value3 != null) {
    el.setAttribute(name, value3);
  } else {
    el.removeAttribute(name);
  }
}
function setAttributeNS(el, name, value3, ns) {
  if (value3 != null) {
    el.setAttributeNS(ns, name, value3);
  } else {
    el.removeAttributeNS(ns, name);
  }
}
function href() {
  let loc;
  return typeof window === "undefined" ? "" : (loc = window.location).hash ? loc.href.slice(0, -loc.hash.length) : loc.href;
}
function SVGStringRenderer(loader2) {
  Renderer.call(this, loader2);
  this._text = null;
  this._defs = {
    gradient: {},
    clipping: {}
  };
}
inherits(SVGStringRenderer, Renderer, {
  /**
   * Returns the rendered SVG text string,
   * or null if rendering has not yet occurred.
   */
  svg() {
    return this._text;
  },
  /**
   * Internal rendering method.
   * @param {object} scene - The root mark of a scenegraph to render.
   */
  _render(scene) {
    const m = markup();
    m.open("svg", extend({}, metadata, {
      class: "marks",
      width: this._width * this._scale,
      height: this._height * this._scale,
      viewBox: `0 0 ${this._width} ${this._height}`
    }));
    const bg = this._bgcolor;
    if (bg && bg !== "transparent" && bg !== "none") {
      m.open("rect", {
        width: this._width,
        height: this._height,
        fill: bg
      }).close();
    }
    m.open("g", rootAttributes, {
      transform: "translate(" + this._origin + ")"
    });
    this.mark(m, scene);
    m.close();
    this.defs(m);
    this._text = m.close() + "";
    return this;
  },
  /**
   * Render a set of mark items.
   * @param {object} m - The markup context.
   * @param {object} scene - The mark parent to render.
   */
  mark(m, scene) {
    const mdef = Marks[scene.marktype], tag = mdef.tag, attrList = [ariaItemAttributes, mdef.attr];
    m.open("g", {
      "class": cssClass(scene),
      "clip-path": scene.clip ? clip$1(this, scene, scene.group) : null
    }, ariaMarkAttributes(scene), {
      "pointer-events": tag !== "g" && scene.interactive === false ? "none" : null
    });
    const process = (item) => {
      const href2 = this.href(item);
      if (href2)
        m.open("a", href2);
      m.open(tag, this.attr(scene, item, attrList, tag !== "g" ? tag : null));
      if (tag === "text") {
        const tl2 = textLines(item);
        if (isArray(tl2)) {
          const attrs = {
            x: 0,
            dy: lineHeight(item)
          };
          for (let i = 0; i < tl2.length; ++i) {
            m.open("tspan", i ? attrs : null).text(textValue(item, tl2[i])).close();
          }
        } else {
          m.text(textValue(item, tl2));
        }
      } else if (tag === "g") {
        const fore = item.strokeForeground, fill2 = item.fill, stroke2 = item.stroke;
        if (fore && stroke2) {
          item.stroke = null;
        }
        m.open("path", this.attr(scene, item, mdef.background, "bgrect")).close();
        m.open("g", this.attr(scene, item, mdef.content));
        visit(item, (scene2) => this.mark(m, scene2));
        m.close();
        if (fore && stroke2) {
          if (fill2)
            item.fill = null;
          item.stroke = stroke2;
          m.open("path", this.attr(scene, item, mdef.foreground, "bgrect")).close();
          if (fill2)
            item.fill = fill2;
        } else {
          m.open("path", this.attr(scene, item, mdef.foreground, "bgfore")).close();
        }
      }
      m.close();
      if (href2)
        m.close();
    };
    if (mdef.nested) {
      if (scene.items && scene.items.length)
        process(scene.items[0]);
    } else {
      visit(scene, process);
    }
    return m.close();
  },
  /**
   * Get href attributes for a hyperlinked mark item.
   * @param {Item} item - The mark item.
   */
  href(item) {
    const href2 = item.href;
    let attr2;
    if (href2) {
      if (attr2 = this._hrefs && this._hrefs[href2]) {
        return attr2;
      } else {
        this.sanitizeURL(href2).then((attr3) => {
          attr3["xlink:href"] = attr3.href;
          attr3.href = null;
          (this._hrefs || (this._hrefs = {}))[href2] = attr3;
        });
      }
    }
    return null;
  },
  /**
   * Get an object of SVG attributes for a mark item.
   * @param {object} scene - The mark parent.
   * @param {Item} item - The mark item.
   * @param {array|function} attrs - One or more attribute emitters.
   * @param {string} tag - The tag being rendered.
   */
  attr(scene, item, attrs, tag) {
    const object2 = {}, emit2 = (name, value3, ns, prefixed) => {
      object2[prefixed || name] = value3;
    };
    if (Array.isArray(attrs)) {
      attrs.forEach((fn) => fn(emit2, item, this));
    } else {
      attrs(emit2, item, this);
    }
    if (tag) {
      style(object2, item, scene, tag, this._defs);
    }
    return object2;
  },
  /**
   * Render SVG defs, as needed.
   * Must be called *after* marks have been processed to ensure the
   * collected state is current and accurate.
   * @param {object} m - The markup context.
   */
  defs(m) {
    const gradient3 = this._defs.gradient, clipping = this._defs.clipping, count = Object.keys(gradient3).length + Object.keys(clipping).length;
    if (count === 0)
      return;
    m.open("defs");
    for (const id2 in gradient3) {
      const def2 = gradient3[id2], stops = def2.stops;
      if (def2.gradient === "radial") {
        m.open("pattern", {
          id: patternPrefix + id2,
          viewBox: "0,0,1,1",
          width: "100%",
          height: "100%",
          preserveAspectRatio: "xMidYMid slice"
        });
        m.open("rect", {
          width: "1",
          height: "1",
          fill: "url(#" + id2 + ")"
        }).close();
        m.close();
        m.open("radialGradient", {
          id: id2,
          fx: def2.x1,
          fy: def2.y1,
          fr: def2.r1,
          cx: def2.x2,
          cy: def2.y2,
          r: def2.r2
        });
      } else {
        m.open("linearGradient", {
          id: id2,
          x1: def2.x1,
          x2: def2.x2,
          y1: def2.y1,
          y2: def2.y2
        });
      }
      for (let i = 0; i < stops.length; ++i) {
        m.open("stop", {
          offset: stops[i].offset,
          "stop-color": stops[i].color
        }).close();
      }
      m.close();
    }
    for (const id2 in clipping) {
      const def2 = clipping[id2];
      m.open("clipPath", {
        id: id2
      });
      if (def2.path) {
        m.open("path", {
          d: def2.path
        }).close();
      } else {
        m.open("rect", {
          x: 0,
          y: 0,
          width: def2.width,
          height: def2.height
        }).close();
      }
      m.close();
    }
    m.close();
  }
});
function style(s, item, scene, tag, defs) {
  let styleList;
  if (item == null)
    return s;
  if (tag === "bgrect" && scene.interactive === false) {
    s["pointer-events"] = "none";
  }
  if (tag === "bgfore") {
    if (scene.interactive === false) {
      s["pointer-events"] = "none";
    }
    s.display = "none";
    if (item.fill !== null)
      return s;
  }
  if (tag === "image" && item.smooth === false) {
    styleList = ["image-rendering: optimizeSpeed;", "image-rendering: pixelated;"];
  }
  if (tag === "text") {
    s["font-family"] = fontFamily(item);
    s["font-size"] = fontSize(item) + "px";
    s["font-style"] = item.fontStyle;
    s["font-variant"] = item.fontVariant;
    s["font-weight"] = item.fontWeight;
  }
  for (const prop in stylesAttr) {
    let value3 = item[prop];
    const name = stylesAttr[prop];
    if (value3 === "transparent" && (name === "fill" || name === "stroke"))
      ;
    else if (value3 != null) {
      if (isGradient(value3)) {
        value3 = gradientRef(value3, defs.gradient, "");
      }
      s[name] = value3;
    }
  }
  for (const prop in stylesCss) {
    const value3 = item[prop];
    if (value3 != null) {
      styleList = styleList || [];
      styleList.push(`${stylesCss[prop]}: ${value3};`);
    }
  }
  if (styleList) {
    s.style = styleList.join(" ");
  }
  return s;
}
var OPTS = {
  svgMarkTypes: ["text"],
  svgOnTop: true,
  debug: false
};
function setHybridRendererOptions(options) {
  OPTS["svgMarkTypes"] = options.svgMarkTypes ?? ["text"];
  OPTS["svgOnTop"] = options.svgOnTop ?? true;
  OPTS["debug"] = options.debug ?? false;
}
function HybridRenderer(loader2) {
  Renderer.call(this, loader2);
  this._svgRenderer = new SVGRenderer(loader2);
  this._canvasRenderer = new CanvasRenderer(loader2);
}
var base = Renderer.prototype;
inherits(HybridRenderer, Renderer, {
  /**
   * Initialize a new HybridRenderer instance.
   * @param {DOMElement} el - The containing DOM element for the display.
   * @param {number} width - The coordinate width of the display, in pixels.
   * @param {number} height - The coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {HybridRenderer} - This renderer instance.
   */
  initialize(el, width2, height2, origin, scaleFactor) {
    this._root_el = domChild(el, 0, "div");
    const bottomEl = domChild(this._root_el, 0, "div");
    const topEl = domChild(this._root_el, 1, "div");
    this._root_el.style.position = "relative";
    if (!OPTS.debug) {
      bottomEl.style.height = "100%";
      topEl.style.position = "absolute";
      topEl.style.top = "0";
      topEl.style.left = "0";
      topEl.style.height = "100%";
      topEl.style.width = "100%";
    }
    this._svgEl = OPTS.svgOnTop ? topEl : bottomEl;
    this._canvasEl = OPTS.svgOnTop ? bottomEl : topEl;
    this._svgEl.style.pointerEvents = "none";
    this._canvasRenderer.initialize(this._canvasEl, width2, height2, origin, scaleFactor);
    this._svgRenderer.initialize(this._svgEl, width2, height2, origin, scaleFactor);
    return base.initialize.call(this, el, width2, height2, origin, scaleFactor);
  },
  /**
   * Flag a mark item as dirty.
   * @param {Item} item - The mark item.
   */
  dirty(item) {
    if (OPTS.svgMarkTypes.includes(item.mark.marktype)) {
      this._svgRenderer.dirty(item);
    } else {
      this._canvasRenderer.dirty(item);
    }
    return this;
  },
  /**
   * Internal rendering method.
   * @param {object} scene - The root mark of a scenegraph to render.
   * @param {Array} markTypes - Array of the mark types to render.
   *                            If undefined, render all mark types
   */
  _render(scene, markTypes) {
    const allMarkTypes = markTypes ?? ["arc", "area", "image", "line", "path", "rect", "rule", "shape", "symbol", "text", "trail"];
    const canvasMarkTypes = allMarkTypes.filter((m) => !OPTS.svgMarkTypes.includes(m));
    this._svgRenderer.render(scene, OPTS.svgMarkTypes);
    this._canvasRenderer.render(scene, canvasMarkTypes);
  },
  /**
   * Resize the display.
   * @param {number} width - The new coordinate width of the display, in pixels.
   * @param {number} height - The new coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The new origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {SVGRenderer} - This renderer instance;
   */
  resize(width2, height2, origin, scaleFactor) {
    base.resize.call(this, width2, height2, origin, scaleFactor);
    this._svgRenderer.resize(width2, height2, origin, scaleFactor);
    this._canvasRenderer.resize(width2, height2, origin, scaleFactor);
    return this;
  },
  background(bgcolor) {
    if (OPTS.svgOnTop) {
      this._canvasRenderer.background(bgcolor);
    } else {
      this._svgRenderer.background(bgcolor);
    }
    return this;
  }
});
function HybridHandler(loader2, tooltip) {
  CanvasHandler.call(this, loader2, tooltip);
}
inherits(HybridHandler, CanvasHandler, {
  initialize(el, origin, obj) {
    const canvas = domChild(domChild(el, 0, "div"), OPTS.svgOnTop ? 0 : 1, "div");
    return CanvasHandler.prototype.initialize.call(this, canvas, origin, obj);
  }
});
var Canvas = "canvas";
var Hybrid = "hybrid";
var PNG = "png";
var SVG = "svg";
var None2 = "none";
var RenderType = {
  Canvas,
  PNG,
  SVG,
  Hybrid,
  None: None2
};
var modules = {};
modules[Canvas] = modules[PNG] = {
  renderer: CanvasRenderer,
  headless: CanvasRenderer,
  handler: CanvasHandler
};
modules[SVG] = {
  renderer: SVGRenderer,
  headless: SVGStringRenderer,
  handler: SVGHandler
};
modules[Hybrid] = {
  renderer: HybridRenderer,
  headless: HybridRenderer,
  handler: HybridHandler
};
modules[None2] = {};
function renderModule(name, _) {
  name = String(name || "").toLowerCase();
  if (arguments.length > 1) {
    modules[name] = _;
    return this;
  } else {
    return modules[name];
  }
}
function intersect(scene, bounds2, filter3) {
  const hits = [], box = new Bounds().union(bounds2), type2 = scene.marktype;
  return type2 ? intersectMark(scene, box, filter3, hits) : type2 === "group" ? intersectGroup(scene, box, filter3, hits) : error("Intersect scene must be mark node or group item.");
}
function intersectMark(mark, box, filter3, hits) {
  if (visitMark(mark, box, filter3)) {
    const items = mark.items, type2 = mark.marktype, n = items.length;
    let i = 0;
    if (type2 === "group") {
      for (; i < n; ++i) {
        intersectGroup(items[i], box, filter3, hits);
      }
    } else {
      for (const test2 = Marks[type2].isect; i < n; ++i) {
        const item = items[i];
        if (intersectItem(item, box, test2))
          hits.push(item);
      }
    }
  }
  return hits;
}
function visitMark(mark, box, filter3) {
  return mark.bounds && box.intersects(mark.bounds) && (mark.marktype === "group" || mark.interactive !== false && (!filter3 || filter3(mark)));
}
function intersectGroup(group2, box, filter3, hits) {
  if (filter3 && filter3(group2.mark) && intersectItem(group2, box, Marks.group.isect)) {
    hits.push(group2);
  }
  const marks = group2.items, n = marks && marks.length;
  if (n) {
    const x2 = group2.x || 0, y2 = group2.y || 0;
    box.translate(-x2, -y2);
    for (let i = 0; i < n; ++i) {
      intersectMark(marks[i], box, filter3, hits);
    }
    box.translate(x2, y2);
  }
  return hits;
}
function intersectItem(item, box, test2) {
  const bounds2 = item.bounds;
  return box.encloses(bounds2) || box.intersects(bounds2) && test2(item, box);
}
var clipBounds = new Bounds();
function boundClip(mark) {
  const clip3 = mark.clip;
  if (isFunction(clip3)) {
    clip3(boundContext(clipBounds.clear()));
  } else if (clip3) {
    clipBounds.set(0, 0, mark.group.width, mark.group.height);
  } else
    return;
  mark.bounds.intersect(clipBounds);
}
var TOLERANCE = 1e-9;
function sceneEqual(a, b2, key2) {
  return a === b2 ? true : key2 === "path" ? pathEqual(a, b2) : a instanceof Date && b2 instanceof Date ? +a === +b2 : isNumber(a) && isNumber(b2) ? Math.abs(a - b2) <= TOLERANCE : !a || !b2 || !isObject(a) && !isObject(b2) ? a == b2 : objectEqual(a, b2);
}
function pathEqual(a, b2) {
  return sceneEqual(parse4(a), parse4(b2));
}
function objectEqual(a, b2) {
  var ka = Object.keys(a), kb = Object.keys(b2), key2, i;
  if (ka.length !== kb.length)
    return false;
  ka.sort();
  kb.sort();
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  for (i = ka.length - 1; i >= 0; i--) {
    key2 = ka[i];
    if (!sceneEqual(a[key2], b2[key2], key2))
      return false;
  }
  return typeof a === typeof b2;
}
function resetSVGDefIds() {
  resetSVGClipId();
  resetSVGGradientId();
}

// node_modules/vega-view-transforms/build/vega-view-transforms.module.js
var Top = "top";
var Left = "left";
var Right = "right";
var Bottom = "bottom";
var TopLeft = "top-left";
var TopRight = "top-right";
var BottomLeft = "bottom-left";
var BottomRight = "bottom-right";
var Start = "start";
var Middle = "middle";
var End = "end";
var X = "x";
var Y = "y";
var Group = "group";
var AxisRole = "axis";
var TitleRole = "title";
var FrameRole = "frame";
var ScopeRole = "scope";
var LegendRole = "legend";
var RowHeader = "row-header";
var RowFooter = "row-footer";
var RowTitle = "row-title";
var ColHeader = "column-header";
var ColFooter = "column-footer";
var ColTitle = "column-title";
var Padding = "padding";
var Symbols = "symbol";
var Fit = "fit";
var FitX = "fit-x";
var FitY = "fit-y";
var Pad = "pad";
var None3 = "none";
var All = "all";
var Each = "each";
var Flush = "flush";
var Column = "column";
var Row = "row";
function Bound(params2) {
  Transform.call(this, null, params2);
}
inherits(Bound, Transform, {
  transform(_, pulse2) {
    const view = pulse2.dataflow, mark = _.mark, type2 = mark.marktype, entry2 = Marks[type2], bound2 = entry2.bound;
    let markBounds = mark.bounds, rebound;
    if (entry2.nested) {
      if (mark.items.length)
        view.dirty(mark.items[0]);
      markBounds = boundItem2(mark, bound2);
      mark.items.forEach((item) => {
        item.bounds.clear().union(markBounds);
      });
    } else if (type2 === Group || _.modified()) {
      pulse2.visit(pulse2.MOD, (item) => view.dirty(item));
      markBounds.clear();
      mark.items.forEach((item) => markBounds.union(boundItem2(item, bound2)));
      switch (mark.role) {
        case AxisRole:
        case LegendRole:
        case TitleRole:
          pulse2.reflow();
      }
    } else {
      rebound = pulse2.changed(pulse2.REM);
      pulse2.visit(pulse2.ADD, (item) => {
        markBounds.union(boundItem2(item, bound2));
      });
      pulse2.visit(pulse2.MOD, (item) => {
        rebound = rebound || markBounds.alignsWith(item.bounds);
        view.dirty(item);
        markBounds.union(boundItem2(item, bound2));
      });
      if (rebound) {
        markBounds.clear();
        mark.items.forEach((item) => markBounds.union(item.bounds));
      }
    }
    boundClip(mark);
    return pulse2.modifies("bounds");
  }
});
function boundItem2(item, bound2, opt) {
  return bound2(item.bounds.clear(), item, opt);
}
var COUNTER_NAME = ":vega_identifier:";
function Identifier(params2) {
  Transform.call(this, 0, params2);
}
Identifier.Definition = {
  "type": "Identifier",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "as",
    "type": "string",
    "required": true
  }]
};
inherits(Identifier, Transform, {
  transform(_, pulse2) {
    const counter = getCounter(pulse2.dataflow), as = _.as;
    let id2 = counter.value;
    pulse2.visit(pulse2.ADD, (t) => t[as] = t[as] || ++id2);
    counter.set(this.value = id2);
    return pulse2;
  }
});
function getCounter(view) {
  return view._signals[COUNTER_NAME] || (view._signals[COUNTER_NAME] = view.add(0));
}
function Mark(params2) {
  Transform.call(this, null, params2);
}
inherits(Mark, Transform, {
  transform(_, pulse2) {
    let mark = this.value;
    if (!mark) {
      mark = pulse2.dataflow.scenegraph().mark(_.markdef, lookup$1(_), _.index);
      mark.group.context = _.context;
      if (!_.context.group)
        _.context.group = mark.group;
      mark.source = this.source;
      mark.clip = _.clip;
      mark.interactive = _.interactive;
      this.value = mark;
    }
    const Init = mark.marktype === Group ? GroupItem : Item;
    pulse2.visit(pulse2.ADD, (item) => Init.call(item, mark));
    if (_.modified("clip") || _.modified("interactive")) {
      mark.clip = _.clip;
      mark.interactive = !!_.interactive;
      mark.zdirty = true;
      pulse2.reflow();
    }
    mark.items = pulse2.source;
    return pulse2;
  }
});
function lookup$1(_) {
  const g = _.groups, p = _.parent;
  return g && g.size === 1 ? g.get(Object.keys(g.object)[0]) : g && p ? g.lookup(p) : null;
}
function Overlap(params2) {
  Transform.call(this, null, params2);
}
var methods = {
  parity: (items) => items.filter((item, i) => i % 2 ? item.opacity = 0 : 1),
  greedy: (items, sep) => {
    let a;
    return items.filter((b2, i) => !i || !intersect2(a.bounds, b2.bounds, sep) ? (a = b2, 1) : b2.opacity = 0);
  }
};
var intersect2 = (a, b2, sep) => sep > Math.max(b2.x1 - a.x2, a.x1 - b2.x2, b2.y1 - a.y2, a.y1 - b2.y2);
var hasOverlap = (items, pad2) => {
  for (var i = 1, n = items.length, a = items[0].bounds, b2; i < n; a = b2, ++i) {
    if (intersect2(a, b2 = items[i].bounds, pad2))
      return true;
  }
};
var hasBounds = (item) => {
  const b2 = item.bounds;
  return b2.width() > 1 && b2.height() > 1;
};
var boundTest = (scale6, orient, tolerance) => {
  var range4 = scale6.range(), b2 = new Bounds();
  if (orient === Top || orient === Bottom) {
    b2.set(range4[0], -Infinity, range4[1], Infinity);
  } else {
    b2.set(-Infinity, range4[0], Infinity, range4[1]);
  }
  b2.expand(tolerance || 1);
  return (item) => b2.encloses(item.bounds);
};
var reset = (source3) => {
  source3.forEach((item) => item.opacity = 1);
  return source3;
};
var reflow = (pulse2, _) => pulse2.reflow(_.modified()).modifies("opacity");
inherits(Overlap, Transform, {
  transform(_, pulse2) {
    const reduce = methods[_.method] || methods.parity, sep = _.separation || 0;
    let source3 = pulse2.materialize(pulse2.SOURCE).source, items, test2;
    if (!source3 || !source3.length)
      return;
    if (!_.method) {
      if (_.modified("method")) {
        reset(source3);
        pulse2 = reflow(pulse2, _);
      }
      return pulse2;
    }
    source3 = source3.filter(hasBounds);
    if (!source3.length)
      return;
    if (_.sort) {
      source3 = source3.slice().sort(_.sort);
    }
    items = reset(source3);
    pulse2 = reflow(pulse2, _);
    if (items.length >= 3 && hasOverlap(items, sep)) {
      do {
        items = reduce(items, sep);
      } while (items.length >= 3 && hasOverlap(items, sep));
      if (items.length < 3 && !peek(source3).opacity) {
        if (items.length > 1)
          peek(items).opacity = 0;
        peek(source3).opacity = 1;
      }
    }
    if (_.boundScale && _.boundTolerance >= 0) {
      test2 = boundTest(_.boundScale, _.boundOrient, +_.boundTolerance);
      source3.forEach((item) => {
        if (!test2(item))
          item.opacity = 0;
      });
    }
    const bounds2 = items[0].mark.bounds.clear();
    source3.forEach((item) => {
      if (item.opacity)
        bounds2.union(item.bounds);
    });
    return pulse2;
  }
});
function Render(params2) {
  Transform.call(this, null, params2);
}
inherits(Render, Transform, {
  transform(_, pulse2) {
    const view = pulse2.dataflow;
    pulse2.visit(pulse2.ALL, (item) => view.dirty(item));
    if (pulse2.fields && pulse2.fields["zindex"]) {
      const item = pulse2.source && pulse2.source[0];
      if (item)
        item.mark.zdirty = true;
    }
  }
});
var tempBounds2 = new Bounds();
function set2(item, property2, value3) {
  return item[property2] === value3 ? 0 : (item[property2] = value3, 1);
}
function isYAxis(mark) {
  var orient = mark.items[0].orient;
  return orient === Left || orient === Right;
}
function axisIndices(datum2) {
  let index2 = +datum2.grid;
  return [
    datum2.ticks ? index2++ : -1,
    // ticks index
    datum2.labels ? index2++ : -1,
    // labels index
    index2 + +datum2.domain
    // title index
  ];
}
function axisLayout(view, axis, width2, height2) {
  var item = axis.items[0], datum2 = item.datum, delta = item.translate != null ? item.translate : 0.5, orient = item.orient, indices = axisIndices(datum2), range4 = item.range, offset4 = item.offset, position2 = item.position, minExtent = item.minExtent, maxExtent = item.maxExtent, title = datum2.title && item.items[indices[2]].items[0], titlePadding = item.titlePadding, bounds2 = item.bounds, dl = title && multiLineOffset(title), x2 = 0, y2 = 0, i, s;
  tempBounds2.clear().union(bounds2);
  bounds2.clear();
  if ((i = indices[0]) > -1)
    bounds2.union(item.items[i].bounds);
  if ((i = indices[1]) > -1)
    bounds2.union(item.items[i].bounds);
  switch (orient) {
    case Top:
      x2 = position2 || 0;
      y2 = -offset4;
      s = Math.max(minExtent, Math.min(maxExtent, -bounds2.y1));
      bounds2.add(0, -s).add(range4, 0);
      if (title)
        axisTitleLayout(view, title, s, titlePadding, dl, 0, -1, bounds2);
      break;
    case Left:
      x2 = -offset4;
      y2 = position2 || 0;
      s = Math.max(minExtent, Math.min(maxExtent, -bounds2.x1));
      bounds2.add(-s, 0).add(0, range4);
      if (title)
        axisTitleLayout(view, title, s, titlePadding, dl, 1, -1, bounds2);
      break;
    case Right:
      x2 = width2 + offset4;
      y2 = position2 || 0;
      s = Math.max(minExtent, Math.min(maxExtent, bounds2.x2));
      bounds2.add(0, 0).add(s, range4);
      if (title)
        axisTitleLayout(view, title, s, titlePadding, dl, 1, 1, bounds2);
      break;
    case Bottom:
      x2 = position2 || 0;
      y2 = height2 + offset4;
      s = Math.max(minExtent, Math.min(maxExtent, bounds2.y2));
      bounds2.add(0, 0).add(range4, s);
      if (title)
        axisTitleLayout(view, title, s, titlePadding, 0, 0, 1, bounds2);
      break;
    default:
      x2 = item.x;
      y2 = item.y;
  }
  boundStroke(bounds2.translate(x2, y2), item);
  if (set2(item, "x", x2 + delta) | set2(item, "y", y2 + delta)) {
    item.bounds = tempBounds2;
    view.dirty(item);
    item.bounds = bounds2;
    view.dirty(item);
  }
  return item.mark.bounds.clear().union(bounds2);
}
function axisTitleLayout(view, title, offset4, pad2, dl, isYAxis2, sign2, bounds2) {
  const b2 = title.bounds;
  if (title.auto) {
    const v = sign2 * (offset4 + dl + pad2);
    let dx = 0, dy = 0;
    view.dirty(title);
    isYAxis2 ? dx = (title.x || 0) - (title.x = v) : dy = (title.y || 0) - (title.y = v);
    title.mark.bounds.clear().union(b2.translate(-dx, -dy));
    view.dirty(title);
  }
  bounds2.union(b2);
}
var min2 = (a, b2) => Math.floor(Math.min(a, b2));
var max2 = (a, b2) => Math.ceil(Math.max(a, b2));
function gridLayoutGroups(group2) {
  var groups = group2.items, n = groups.length, i = 0, mark, items;
  const views = {
    marks: [],
    rowheaders: [],
    rowfooters: [],
    colheaders: [],
    colfooters: [],
    rowtitle: null,
    coltitle: null
  };
  for (; i < n; ++i) {
    mark = groups[i];
    items = mark.items;
    if (mark.marktype === Group) {
      switch (mark.role) {
        case AxisRole:
        case LegendRole:
        case TitleRole:
          break;
        case RowHeader:
          views.rowheaders.push(...items);
          break;
        case RowFooter:
          views.rowfooters.push(...items);
          break;
        case ColHeader:
          views.colheaders.push(...items);
          break;
        case ColFooter:
          views.colfooters.push(...items);
          break;
        case RowTitle:
          views.rowtitle = items[0];
          break;
        case ColTitle:
          views.coltitle = items[0];
          break;
        default:
          views.marks.push(...items);
      }
    }
  }
  return views;
}
function bboxFlush(item) {
  return new Bounds().set(0, 0, item.width || 0, item.height || 0);
}
function bboxFull(item) {
  const b2 = item.bounds.clone();
  return b2.empty() ? b2.set(0, 0, 0, 0) : b2.translate(-(item.x || 0), -(item.y || 0));
}
function get4(opt, key2, d) {
  const v = isObject(opt) ? opt[key2] : opt;
  return v != null ? v : d !== void 0 ? d : 0;
}
function offsetValue(v) {
  return v < 0 ? Math.ceil(-v) : 0;
}
function gridLayout(view, groups, opt) {
  var dirty = !opt.nodirty, bbox = opt.bounds === Flush ? bboxFlush : bboxFull, bounds2 = tempBounds2.set(0, 0, 0, 0), alignCol = get4(opt.align, Column), alignRow = get4(opt.align, Row), padCol = get4(opt.padding, Column), padRow = get4(opt.padding, Row), ncols = opt.columns || groups.length, nrows = ncols <= 0 ? 1 : Math.ceil(groups.length / ncols), n = groups.length, xOffset = Array(n), xExtent = Array(ncols), xMax = 0, yOffset = Array(n), yExtent = Array(nrows), yMax = 0, dx = Array(n), dy = Array(n), boxes = Array(n), m, i, c, r, b2, g, px2, py2, x2, y2, offset4;
  for (i = 0; i < ncols; ++i)
    xExtent[i] = 0;
  for (i = 0; i < nrows; ++i)
    yExtent[i] = 0;
  for (i = 0; i < n; ++i) {
    g = groups[i];
    b2 = boxes[i] = bbox(g);
    g.x = g.x || 0;
    dx[i] = 0;
    g.y = g.y || 0;
    dy[i] = 0;
    c = i % ncols;
    r = ~~(i / ncols);
    xMax = Math.max(xMax, px2 = Math.ceil(b2.x2));
    yMax = Math.max(yMax, py2 = Math.ceil(b2.y2));
    xExtent[c] = Math.max(xExtent[c], px2);
    yExtent[r] = Math.max(yExtent[r], py2);
    xOffset[i] = padCol + offsetValue(b2.x1);
    yOffset[i] = padRow + offsetValue(b2.y1);
    if (dirty)
      view.dirty(groups[i]);
  }
  for (i = 0; i < n; ++i) {
    if (i % ncols === 0)
      xOffset[i] = 0;
    if (i < ncols)
      yOffset[i] = 0;
  }
  if (alignCol === Each) {
    for (c = 1; c < ncols; ++c) {
      for (offset4 = 0, i = c; i < n; i += ncols) {
        if (offset4 < xOffset[i])
          offset4 = xOffset[i];
      }
      for (i = c; i < n; i += ncols) {
        xOffset[i] = offset4 + xExtent[c - 1];
      }
    }
  } else if (alignCol === All) {
    for (offset4 = 0, i = 0; i < n; ++i) {
      if (i % ncols && offset4 < xOffset[i])
        offset4 = xOffset[i];
    }
    for (i = 0; i < n; ++i) {
      if (i % ncols)
        xOffset[i] = offset4 + xMax;
    }
  } else {
    for (alignCol = false, c = 1; c < ncols; ++c) {
      for (i = c; i < n; i += ncols) {
        xOffset[i] += xExtent[c - 1];
      }
    }
  }
  if (alignRow === Each) {
    for (r = 1; r < nrows; ++r) {
      for (offset4 = 0, i = r * ncols, m = i + ncols; i < m; ++i) {
        if (offset4 < yOffset[i])
          offset4 = yOffset[i];
      }
      for (i = r * ncols; i < m; ++i) {
        yOffset[i] = offset4 + yExtent[r - 1];
      }
    }
  } else if (alignRow === All) {
    for (offset4 = 0, i = ncols; i < n; ++i) {
      if (offset4 < yOffset[i])
        offset4 = yOffset[i];
    }
    for (i = ncols; i < n; ++i) {
      yOffset[i] = offset4 + yMax;
    }
  } else {
    for (alignRow = false, r = 1; r < nrows; ++r) {
      for (i = r * ncols, m = i + ncols; i < m; ++i) {
        yOffset[i] += yExtent[r - 1];
      }
    }
  }
  for (x2 = 0, i = 0; i < n; ++i) {
    x2 = xOffset[i] + (i % ncols ? x2 : 0);
    dx[i] += x2 - groups[i].x;
  }
  for (c = 0; c < ncols; ++c) {
    for (y2 = 0, i = c; i < n; i += ncols) {
      y2 += yOffset[i];
      dy[i] += y2 - groups[i].y;
    }
  }
  if (alignCol && get4(opt.center, Column) && nrows > 1) {
    for (i = 0; i < n; ++i) {
      b2 = alignCol === All ? xMax : xExtent[i % ncols];
      x2 = b2 - boxes[i].x2 - groups[i].x - dx[i];
      if (x2 > 0)
        dx[i] += x2 / 2;
    }
  }
  if (alignRow && get4(opt.center, Row) && ncols !== 1) {
    for (i = 0; i < n; ++i) {
      b2 = alignRow === All ? yMax : yExtent[~~(i / ncols)];
      y2 = b2 - boxes[i].y2 - groups[i].y - dy[i];
      if (y2 > 0)
        dy[i] += y2 / 2;
    }
  }
  for (i = 0; i < n; ++i) {
    bounds2.union(boxes[i].translate(dx[i], dy[i]));
  }
  x2 = get4(opt.anchor, X);
  y2 = get4(opt.anchor, Y);
  switch (get4(opt.anchor, Column)) {
    case End:
      x2 -= bounds2.width();
      break;
    case Middle:
      x2 -= bounds2.width() / 2;
  }
  switch (get4(opt.anchor, Row)) {
    case End:
      y2 -= bounds2.height();
      break;
    case Middle:
      y2 -= bounds2.height() / 2;
  }
  x2 = Math.round(x2);
  y2 = Math.round(y2);
  bounds2.clear();
  for (i = 0; i < n; ++i) {
    groups[i].mark.bounds.clear();
  }
  for (i = 0; i < n; ++i) {
    g = groups[i];
    g.x += dx[i] += x2;
    g.y += dy[i] += y2;
    bounds2.union(g.mark.bounds.union(g.bounds.translate(dx[i], dy[i])));
    if (dirty)
      view.dirty(g);
  }
  return bounds2;
}
function trellisLayout(view, group2, opt) {
  var views = gridLayoutGroups(group2), groups = views.marks, bbox = opt.bounds === Flush ? boundFlush : boundFull, off = opt.offset, ncols = opt.columns || groups.length, nrows = ncols <= 0 ? 1 : Math.ceil(groups.length / ncols), cells = nrows * ncols, x2, y2, x22, y22, anchor, band2, offset4;
  const bounds2 = gridLayout(view, groups, opt);
  if (bounds2.empty())
    bounds2.set(0, 0, 0, 0);
  if (views.rowheaders) {
    band2 = get4(opt.headerBand, Row, null);
    x2 = layoutHeaders(view, views.rowheaders, groups, ncols, nrows, -get4(off, "rowHeader"), min2, 0, bbox, "x1", 0, ncols, 1, band2);
  }
  if (views.colheaders) {
    band2 = get4(opt.headerBand, Column, null);
    y2 = layoutHeaders(view, views.colheaders, groups, ncols, ncols, -get4(off, "columnHeader"), min2, 1, bbox, "y1", 0, 1, ncols, band2);
  }
  if (views.rowfooters) {
    band2 = get4(opt.footerBand, Row, null);
    x22 = layoutHeaders(view, views.rowfooters, groups, ncols, nrows, get4(off, "rowFooter"), max2, 0, bbox, "x2", ncols - 1, ncols, 1, band2);
  }
  if (views.colfooters) {
    band2 = get4(opt.footerBand, Column, null);
    y22 = layoutHeaders(view, views.colfooters, groups, ncols, ncols, get4(off, "columnFooter"), max2, 1, bbox, "y2", cells - ncols, 1, ncols, band2);
  }
  if (views.rowtitle) {
    anchor = get4(opt.titleAnchor, Row);
    offset4 = get4(off, "rowTitle");
    offset4 = anchor === End ? x22 + offset4 : x2 - offset4;
    band2 = get4(opt.titleBand, Row, 0.5);
    layoutTitle(view, views.rowtitle, offset4, 0, bounds2, band2);
  }
  if (views.coltitle) {
    anchor = get4(opt.titleAnchor, Column);
    offset4 = get4(off, "columnTitle");
    offset4 = anchor === End ? y22 + offset4 : y2 - offset4;
    band2 = get4(opt.titleBand, Column, 0.5);
    layoutTitle(view, views.coltitle, offset4, 1, bounds2, band2);
  }
}
function boundFlush(item, field3) {
  return field3 === "x1" ? item.x || 0 : field3 === "y1" ? item.y || 0 : field3 === "x2" ? (item.x || 0) + (item.width || 0) : field3 === "y2" ? (item.y || 0) + (item.height || 0) : void 0;
}
function boundFull(item, field3) {
  return item.bounds[field3];
}
function layoutHeaders(view, headers, groups, ncols, limit, offset4, agg, isX2, bound2, bf, start, stride, back, band2) {
  var n = groups.length, init2 = 0, edge = 0, i, j, k2, m, b2, h2, g, x2, y2;
  if (!n)
    return init2;
  for (i = start; i < n; i += stride) {
    if (groups[i])
      init2 = agg(init2, bound2(groups[i], bf));
  }
  if (!headers.length)
    return init2;
  if (headers.length > limit) {
    view.warn("Grid headers exceed limit: " + limit);
    headers = headers.slice(0, limit);
  }
  init2 += offset4;
  for (j = 0, m = headers.length; j < m; ++j) {
    view.dirty(headers[j]);
    headers[j].mark.bounds.clear();
  }
  for (i = start, j = 0, m = headers.length; j < m; ++j, i += stride) {
    h2 = headers[j];
    b2 = h2.mark.bounds;
    for (k2 = i; k2 >= 0 && (g = groups[k2]) == null; k2 -= back)
      ;
    if (isX2) {
      x2 = band2 == null ? g.x : Math.round(g.bounds.x1 + band2 * g.bounds.width());
      y2 = init2;
    } else {
      x2 = init2;
      y2 = band2 == null ? g.y : Math.round(g.bounds.y1 + band2 * g.bounds.height());
    }
    b2.union(h2.bounds.translate(x2 - (h2.x || 0), y2 - (h2.y || 0)));
    h2.x = x2;
    h2.y = y2;
    view.dirty(h2);
    edge = agg(edge, b2[bf]);
  }
  return edge;
}
function layoutTitle(view, g, offset4, isX2, bounds2, band2) {
  if (!g)
    return;
  view.dirty(g);
  var x2 = offset4, y2 = offset4;
  isX2 ? x2 = Math.round(bounds2.x1 + band2 * bounds2.width()) : y2 = Math.round(bounds2.y1 + band2 * bounds2.height());
  g.bounds.translate(x2 - (g.x || 0), y2 - (g.y || 0));
  g.mark.bounds.clear().union(g.bounds);
  g.x = x2;
  g.y = y2;
  view.dirty(g);
}
function lookup2(config, orient) {
  const opt = config[orient] || {};
  return (key2, d) => opt[key2] != null ? opt[key2] : config[key2] != null ? config[key2] : d;
}
function offsets(legends, value3) {
  let max4 = -Infinity;
  legends.forEach((item) => {
    if (item.offset != null)
      max4 = Math.max(max4, item.offset);
  });
  return max4 > -Infinity ? max4 : value3;
}
function legendParams(g, orient, config, xb, yb, w3, h2) {
  const _ = lookup2(config, orient), offset4 = offsets(g, _("offset", 0)), anchor = _("anchor", Start), mult2 = anchor === End ? 1 : anchor === Middle ? 0.5 : 0;
  const p = {
    align: Each,
    bounds: _("bounds", Flush),
    columns: _("direction") === "vertical" ? 1 : g.length,
    padding: _("margin", 8),
    center: _("center"),
    nodirty: true
  };
  switch (orient) {
    case Left:
      p.anchor = {
        x: Math.floor(xb.x1) - offset4,
        column: End,
        y: mult2 * (h2 || xb.height() + 2 * xb.y1),
        row: anchor
      };
      break;
    case Right:
      p.anchor = {
        x: Math.ceil(xb.x2) + offset4,
        y: mult2 * (h2 || xb.height() + 2 * xb.y1),
        row: anchor
      };
      break;
    case Top:
      p.anchor = {
        y: Math.floor(yb.y1) - offset4,
        row: End,
        x: mult2 * (w3 || yb.width() + 2 * yb.x1),
        column: anchor
      };
      break;
    case Bottom:
      p.anchor = {
        y: Math.ceil(yb.y2) + offset4,
        x: mult2 * (w3 || yb.width() + 2 * yb.x1),
        column: anchor
      };
      break;
    case TopLeft:
      p.anchor = {
        x: offset4,
        y: offset4
      };
      break;
    case TopRight:
      p.anchor = {
        x: w3 - offset4,
        y: offset4,
        column: End
      };
      break;
    case BottomLeft:
      p.anchor = {
        x: offset4,
        y: h2 - offset4,
        row: End
      };
      break;
    case BottomRight:
      p.anchor = {
        x: w3 - offset4,
        y: h2 - offset4,
        column: End,
        row: End
      };
      break;
  }
  return p;
}
function legendLayout(view, legend) {
  var item = legend.items[0], datum2 = item.datum, orient = item.orient, bounds2 = item.bounds, x2 = item.x, y2 = item.y, w3, h2;
  item._bounds ? item._bounds.clear().union(bounds2) : item._bounds = bounds2.clone();
  bounds2.clear();
  legendGroupLayout(view, item, item.items[0].items[0]);
  bounds2 = legendBounds(item, bounds2);
  w3 = 2 * item.padding;
  h2 = 2 * item.padding;
  if (!bounds2.empty()) {
    w3 = Math.ceil(bounds2.width() + w3);
    h2 = Math.ceil(bounds2.height() + h2);
  }
  if (datum2.type === Symbols) {
    legendEntryLayout(item.items[0].items[0].items[0].items);
  }
  if (orient !== None3) {
    item.x = x2 = 0;
    item.y = y2 = 0;
  }
  item.width = w3;
  item.height = h2;
  boundStroke(bounds2.set(x2, y2, x2 + w3, y2 + h2), item);
  item.mark.bounds.clear().union(bounds2);
  return item;
}
function legendBounds(item, b2) {
  item.items.forEach((_) => b2.union(_.bounds));
  b2.x1 = item.padding;
  b2.y1 = item.padding;
  return b2;
}
function legendGroupLayout(view, item, entry2) {
  var pad2 = item.padding, ex = pad2 - entry2.x, ey = pad2 - entry2.y;
  if (!item.datum.title) {
    if (ex || ey)
      translate2(view, entry2, ex, ey);
  } else {
    var title = item.items[1].items[0], anchor = title.anchor, tpad = item.titlePadding || 0, tx = pad2 - title.x, ty = pad2 - title.y;
    switch (title.orient) {
      case Left:
        ex += Math.ceil(title.bounds.width()) + tpad;
        break;
      case Right:
      case Bottom:
        break;
      default:
        ey += title.bounds.height() + tpad;
    }
    if (ex || ey)
      translate2(view, entry2, ex, ey);
    switch (title.orient) {
      case Left:
        ty += legendTitleOffset(item, entry2, title, anchor, 1, 1);
        break;
      case Right:
        tx += legendTitleOffset(item, entry2, title, End, 0, 0) + tpad;
        ty += legendTitleOffset(item, entry2, title, anchor, 1, 1);
        break;
      case Bottom:
        tx += legendTitleOffset(item, entry2, title, anchor, 0, 0);
        ty += legendTitleOffset(item, entry2, title, End, -1, 0, 1) + tpad;
        break;
      default:
        tx += legendTitleOffset(item, entry2, title, anchor, 0, 0);
    }
    if (tx || ty)
      translate2(view, title, tx, ty);
    if ((tx = Math.round(title.bounds.x1 - pad2)) < 0) {
      translate2(view, entry2, -tx, 0);
      translate2(view, title, -tx, 0);
    }
  }
}
function legendTitleOffset(item, entry2, title, anchor, y2, lr, noBar) {
  const grad = item.datum.type !== "symbol", vgrad = title.datum.vgrad, e = grad && (lr || !vgrad) && !noBar ? entry2.items[0] : entry2, s = e.bounds[y2 ? "y2" : "x2"] - item.padding, u = vgrad && lr ? s : 0, v = vgrad && lr ? 0 : s, o = y2 <= 0 ? 0 : multiLineOffset(title);
  return Math.round(anchor === Start ? u : anchor === End ? v - o : 0.5 * (s - o));
}
function translate2(view, item, dx, dy) {
  item.x += dx;
  item.y += dy;
  item.bounds.translate(dx, dy);
  item.mark.bounds.translate(dx, dy);
  view.dirty(item);
}
function legendEntryLayout(entries) {
  const widths = entries.reduce((w3, g) => {
    w3[g.column] = Math.max(g.bounds.x2 - g.x, w3[g.column] || 0);
    return w3;
  }, {});
  entries.forEach((g) => {
    g.width = widths[g.column];
    g.height = g.bounds.y2 - g.y;
  });
}
function titleLayout(view, mark, width2, height2, viewBounds2) {
  var group2 = mark.items[0], frame = group2.frame, orient = group2.orient, anchor = group2.anchor, offset4 = group2.offset, padding2 = group2.padding, title = group2.items[0].items[0], subtitle = group2.items[1] && group2.items[1].items[0], end = orient === Left || orient === Right ? height2 : width2, start = 0, x2 = 0, y2 = 0, sx = 0, sy = 0, pos;
  if (frame !== Group) {
    orient === Left ? (start = viewBounds2.y2, end = viewBounds2.y1) : orient === Right ? (start = viewBounds2.y1, end = viewBounds2.y2) : (start = viewBounds2.x1, end = viewBounds2.x2);
  } else if (orient === Left) {
    start = height2, end = 0;
  }
  pos = anchor === Start ? start : anchor === End ? end : (start + end) / 2;
  if (subtitle && subtitle.text) {
    switch (orient) {
      case Top:
      case Bottom:
        sy = title.bounds.height() + padding2;
        break;
      case Left:
        sx = title.bounds.width() + padding2;
        break;
      case Right:
        sx = -title.bounds.width() - padding2;
        break;
    }
    tempBounds2.clear().union(subtitle.bounds);
    tempBounds2.translate(sx - (subtitle.x || 0), sy - (subtitle.y || 0));
    if (set2(subtitle, "x", sx) | set2(subtitle, "y", sy)) {
      view.dirty(subtitle);
      subtitle.bounds.clear().union(tempBounds2);
      subtitle.mark.bounds.clear().union(tempBounds2);
      view.dirty(subtitle);
    }
    tempBounds2.clear().union(subtitle.bounds);
  } else {
    tempBounds2.clear();
  }
  tempBounds2.union(title.bounds);
  switch (orient) {
    case Top:
      x2 = pos;
      y2 = viewBounds2.y1 - tempBounds2.height() - offset4;
      break;
    case Left:
      x2 = viewBounds2.x1 - tempBounds2.width() - offset4;
      y2 = pos;
      break;
    case Right:
      x2 = viewBounds2.x2 + tempBounds2.width() + offset4;
      y2 = pos;
      break;
    case Bottom:
      x2 = pos;
      y2 = viewBounds2.y2 + offset4;
      break;
    default:
      x2 = group2.x;
      y2 = group2.y;
  }
  if (set2(group2, "x", x2) | set2(group2, "y", y2)) {
    tempBounds2.translate(x2, y2);
    view.dirty(group2);
    group2.bounds.clear().union(tempBounds2);
    mark.bounds.clear().union(tempBounds2);
    view.dirty(group2);
  }
  return group2.bounds;
}
function ViewLayout(params2) {
  Transform.call(this, null, params2);
}
inherits(ViewLayout, Transform, {
  transform(_, pulse2) {
    const view = pulse2.dataflow;
    _.mark.items.forEach((group2) => {
      if (_.layout)
        trellisLayout(view, group2, _.layout);
      layoutGroup(view, group2, _);
    });
    return shouldReflow(_.mark.group) ? pulse2.reflow() : pulse2;
  }
});
function shouldReflow(group2) {
  return group2 && group2.mark.role !== "legend-entry";
}
function layoutGroup(view, group2, _) {
  var items = group2.items, width2 = Math.max(0, group2.width || 0), height2 = Math.max(0, group2.height || 0), viewBounds2 = new Bounds().set(0, 0, width2, height2), xBounds = viewBounds2.clone(), yBounds = viewBounds2.clone(), legends = [], title, mark, orient, b2, i, n;
  for (i = 0, n = items.length; i < n; ++i) {
    mark = items[i];
    switch (mark.role) {
      case AxisRole:
        b2 = isYAxis(mark) ? xBounds : yBounds;
        b2.union(axisLayout(view, mark, width2, height2));
        break;
      case TitleRole:
        title = mark;
        break;
      case LegendRole:
        legends.push(legendLayout(view, mark));
        break;
      case FrameRole:
      case ScopeRole:
      case RowHeader:
      case RowFooter:
      case RowTitle:
      case ColHeader:
      case ColFooter:
      case ColTitle:
        xBounds.union(mark.bounds);
        yBounds.union(mark.bounds);
        break;
      default:
        viewBounds2.union(mark.bounds);
    }
  }
  if (legends.length) {
    const l = {};
    legends.forEach((item) => {
      orient = item.orient || Right;
      if (orient !== None3)
        (l[orient] || (l[orient] = [])).push(item);
    });
    for (const orient2 in l) {
      const g = l[orient2];
      gridLayout(view, g, legendParams(g, orient2, _.legends, xBounds, yBounds, width2, height2));
    }
    legends.forEach((item) => {
      const b3 = item.bounds;
      if (!b3.equals(item._bounds)) {
        item.bounds = item._bounds;
        view.dirty(item);
        item.bounds = b3;
        view.dirty(item);
      }
      if (_.autosize && (_.autosize.type === Fit || _.autosize.type === FitX || _.autosize.type === FitY)) {
        switch (item.orient) {
          case Left:
          case Right:
            viewBounds2.add(b3.x1, 0).add(b3.x2, 0);
            break;
          case Top:
          case Bottom:
            viewBounds2.add(0, b3.y1).add(0, b3.y2);
        }
      } else {
        viewBounds2.union(b3);
      }
    });
  }
  viewBounds2.union(xBounds).union(yBounds);
  if (title) {
    viewBounds2.union(titleLayout(view, title, width2, height2, viewBounds2));
  }
  if (group2.clip) {
    viewBounds2.set(0, 0, group2.width || 0, group2.height || 0);
  }
  viewSizeLayout(view, group2, viewBounds2, _);
}
function viewSizeLayout(view, group2, viewBounds2, _) {
  const auto = _.autosize || {}, type2 = auto.type;
  if (view._autosize < 1 || !type2)
    return;
  let viewWidth2 = view._width, viewHeight2 = view._height, width2 = Math.max(0, group2.width || 0), left = Math.max(0, Math.ceil(-viewBounds2.x1)), height2 = Math.max(0, group2.height || 0), top = Math.max(0, Math.ceil(-viewBounds2.y1));
  const right = Math.max(0, Math.ceil(viewBounds2.x2 - width2)), bottom = Math.max(0, Math.ceil(viewBounds2.y2 - height2));
  if (auto.contains === Padding) {
    const padding2 = view.padding();
    viewWidth2 -= padding2.left + padding2.right;
    viewHeight2 -= padding2.top + padding2.bottom;
  }
  if (type2 === None3) {
    left = 0;
    top = 0;
    width2 = viewWidth2;
    height2 = viewHeight2;
  } else if (type2 === Fit) {
    width2 = Math.max(0, viewWidth2 - left - right);
    height2 = Math.max(0, viewHeight2 - top - bottom);
  } else if (type2 === FitX) {
    width2 = Math.max(0, viewWidth2 - left - right);
    viewHeight2 = height2 + top + bottom;
  } else if (type2 === FitY) {
    viewWidth2 = width2 + left + right;
    height2 = Math.max(0, viewHeight2 - top - bottom);
  } else if (type2 === Pad) {
    viewWidth2 = width2 + left + right;
    viewHeight2 = height2 + top + bottom;
  }
  view._resizeView(viewWidth2, viewHeight2, width2, height2, [left, top], auto.resize);
}

// node_modules/vega-encode/build/vega-encode.module.js
var vega_encode_module_exports = {};
__export(vega_encode_module_exports, {
  axisticks: () => AxisTicks,
  datajoin: () => DataJoin,
  encode: () => Encode,
  legendentries: () => LegendEntries,
  linkpath: () => LinkPath,
  pie: () => Pie,
  scale: () => Scale,
  sortitems: () => SortItems,
  stack: () => Stack
});
function AxisTicks(params2) {
  Transform.call(this, null, params2);
}
inherits(AxisTicks, Transform, {
  transform(_, pulse2) {
    if (this.value && !_.modified()) {
      return pulse2.StopPropagation;
    }
    var locale2 = pulse2.dataflow.locale(), out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS), ticks = this.value, scale6 = _.scale, tally = _.count == null ? _.values ? _.values.length : 10 : _.count, count = tickCount(scale6, tally, _.minstep), format5 = _.format || tickFormat2(locale2, scale6, count, _.formatSpecifier, _.formatType, !!_.values), values2 = _.values ? validTicks(scale6, _.values, count) : tickValues(scale6, count);
    if (ticks)
      out.rem = ticks;
    ticks = values2.map((value3, i) => ingest$1({
      index: i / (values2.length - 1 || 1),
      value: value3,
      label: format5(value3)
    }));
    if (_.extra && ticks.length) {
      ticks.push(ingest$1({
        index: -1,
        extra: {
          value: ticks[0].value
        },
        label: ""
      }));
    }
    out.source = ticks;
    out.add = ticks;
    this.value = ticks;
    return out;
  }
});
function DataJoin(params2) {
  Transform.call(this, null, params2);
}
function defaultItemCreate() {
  return ingest$1({});
}
function newMap(key2) {
  const map2 = fastmap().test((t) => t.exit);
  map2.lookup = (t) => map2.get(key2(t));
  return map2;
}
inherits(DataJoin, Transform, {
  transform(_, pulse2) {
    var df = pulse2.dataflow, out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS), item = _.item || defaultItemCreate, key2 = _.key || tupleid, map2 = this.value;
    if (isArray(out.encode)) {
      out.encode = null;
    }
    if (map2 && (_.modified("key") || pulse2.modified(key2))) {
      error("DataJoin does not support modified key function or fields.");
    }
    if (!map2) {
      pulse2 = pulse2.addAll();
      this.value = map2 = newMap(key2);
    }
    pulse2.visit(pulse2.ADD, (t) => {
      const k2 = key2(t);
      let x2 = map2.get(k2);
      if (x2) {
        if (x2.exit) {
          map2.empty--;
          out.add.push(x2);
        } else {
          out.mod.push(x2);
        }
      } else {
        x2 = item(t);
        map2.set(k2, x2);
        out.add.push(x2);
      }
      x2.datum = t;
      x2.exit = false;
    });
    pulse2.visit(pulse2.MOD, (t) => {
      const k2 = key2(t), x2 = map2.get(k2);
      if (x2) {
        x2.datum = t;
        out.mod.push(x2);
      }
    });
    pulse2.visit(pulse2.REM, (t) => {
      const k2 = key2(t), x2 = map2.get(k2);
      if (t === x2.datum && !x2.exit) {
        out.rem.push(x2);
        x2.exit = true;
        ++map2.empty;
      }
    });
    if (pulse2.changed(pulse2.ADD_MOD))
      out.modifies("datum");
    if (pulse2.clean() || _.clean && map2.empty > df.cleanThreshold) {
      df.runAfter(map2.clean);
    }
    return out;
  }
});
function Encode(params2) {
  Transform.call(this, null, params2);
}
inherits(Encode, Transform, {
  transform(_, pulse2) {
    var out = pulse2.fork(pulse2.ADD_REM), fmod = _.mod || false, encoders = _.encoders, encode2 = pulse2.encode;
    if (isArray(encode2)) {
      if (out.changed() || encode2.every((e) => encoders[e])) {
        encode2 = encode2[0];
        out.encode = null;
      } else {
        return pulse2.StopPropagation;
      }
    }
    var reenter = encode2 === "enter", update3 = encoders.update || falsy, enter = encoders.enter || falsy, exit = encoders.exit || falsy, set4 = (encode2 && !reenter ? encoders[encode2] : update3) || falsy;
    if (pulse2.changed(pulse2.ADD)) {
      pulse2.visit(pulse2.ADD, (t) => {
        enter(t, _);
        update3(t, _);
      });
      out.modifies(enter.output);
      out.modifies(update3.output);
      if (set4 !== falsy && set4 !== update3) {
        pulse2.visit(pulse2.ADD, (t) => {
          set4(t, _);
        });
        out.modifies(set4.output);
      }
    }
    if (pulse2.changed(pulse2.REM) && exit !== falsy) {
      pulse2.visit(pulse2.REM, (t) => {
        exit(t, _);
      });
      out.modifies(exit.output);
    }
    if (reenter || set4 !== falsy) {
      const flag2 = pulse2.MOD | (_.modified() ? pulse2.REFLOW : 0);
      if (reenter) {
        pulse2.visit(flag2, (t) => {
          const mod = enter(t, _) || fmod;
          if (set4(t, _) || mod)
            out.mod.push(t);
        });
        if (out.mod.length)
          out.modifies(enter.output);
      } else {
        pulse2.visit(flag2, (t) => {
          if (set4(t, _) || fmod)
            out.mod.push(t);
        });
      }
      if (out.mod.length)
        out.modifies(set4.output);
    }
    return out.changed() ? out : pulse2.StopPropagation;
  }
});
function LegendEntries(params2) {
  Transform.call(this, [], params2);
}
inherits(LegendEntries, Transform, {
  transform(_, pulse2) {
    if (this.value != null && !_.modified()) {
      return pulse2.StopPropagation;
    }
    var locale2 = pulse2.dataflow.locale(), out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS), items = this.value, type2 = _.type || SymbolLegend, scale6 = _.scale, limit = +_.limit, count = tickCount(scale6, _.count == null ? 5 : _.count, _.minstep), lskip = !!_.values || type2 === SymbolLegend, format5 = _.format || labelFormat(locale2, scale6, count, type2, _.formatSpecifier, _.formatType, lskip), values2 = _.values || labelValues(scale6, count), domain2, fraction, size, offset4, ellipsis;
    if (items)
      out.rem = items;
    if (type2 === SymbolLegend) {
      if (limit && values2.length > limit) {
        pulse2.dataflow.warn("Symbol legend count exceeds limit, filtering items.");
        items = values2.slice(0, limit - 1);
        ellipsis = true;
      } else {
        items = values2;
      }
      if (isFunction(size = _.size)) {
        if (!_.values && scale6(items[0]) === 0) {
          items = items.slice(1);
        }
        offset4 = items.reduce((max4, value3) => Math.max(max4, size(value3, _)), 0);
      } else {
        size = constant(offset4 = size || 8);
      }
      items = items.map((value3, index2) => ingest$1({
        index: index2,
        label: format5(value3, index2, items),
        value: value3,
        offset: offset4,
        size: size(value3, _)
      }));
      if (ellipsis) {
        ellipsis = values2[items.length];
        items.push(ingest$1({
          index: items.length,
          label: `…${values2.length - items.length} entries`,
          value: ellipsis,
          offset: offset4,
          size: size(ellipsis, _)
        }));
      }
    } else if (type2 === GradientLegend) {
      domain2 = scale6.domain(), fraction = scaleFraction(scale6, domain2[0], peek(domain2));
      if (values2.length < 3 && !_.values && domain2[0] !== peek(domain2)) {
        values2 = [domain2[0], peek(domain2)];
      }
      items = values2.map((value3, index2) => ingest$1({
        index: index2,
        label: format5(value3, index2, values2),
        value: value3,
        perc: fraction(value3)
      }));
    } else {
      size = values2.length - 1;
      fraction = labelFraction(scale6);
      items = values2.map((value3, index2) => ingest$1({
        index: index2,
        label: format5(value3, index2, values2),
        value: value3,
        perc: index2 ? fraction(value3) : 0,
        perc2: index2 === size ? 1 : fraction(values2[index2 + 1])
      }));
    }
    out.source = items;
    out.add = items;
    this.value = items;
    return out;
  }
});
var sourceX = (t) => t.source.x;
var sourceY = (t) => t.source.y;
var targetX = (t) => t.target.x;
var targetY = (t) => t.target.y;
function LinkPath(params2) {
  Transform.call(this, {}, params2);
}
LinkPath.Definition = {
  "type": "LinkPath",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "sourceX",
    "type": "field",
    "default": "source.x"
  }, {
    "name": "sourceY",
    "type": "field",
    "default": "source.y"
  }, {
    "name": "targetX",
    "type": "field",
    "default": "target.x"
  }, {
    "name": "targetY",
    "type": "field",
    "default": "target.y"
  }, {
    "name": "orient",
    "type": "enum",
    "default": "vertical",
    "values": ["horizontal", "vertical", "radial"]
  }, {
    "name": "shape",
    "type": "enum",
    "default": "line",
    "values": ["line", "arc", "curve", "diagonal", "orthogonal"]
  }, {
    "name": "require",
    "type": "signal"
  }, {
    "name": "as",
    "type": "string",
    "default": "path"
  }]
};
inherits(LinkPath, Transform, {
  transform(_, pulse2) {
    var sx = _.sourceX || sourceX, sy = _.sourceY || sourceY, tx = _.targetX || targetX, ty = _.targetY || targetY, as = _.as || "path", orient = _.orient || "vertical", shape2 = _.shape || "line", path3 = Paths.get(shape2 + "-" + orient) || Paths.get(shape2);
    if (!path3) {
      error("LinkPath unsupported type: " + _.shape + (_.orient ? "-" + _.orient : ""));
    }
    pulse2.visit(pulse2.SOURCE, (t) => {
      t[as] = path3(sx(t), sy(t), tx(t), ty(t));
    });
    return pulse2.reflow(_.modified()).modifies(as);
  }
});
var line2 = (sx, sy, tx, ty) => "M" + sx + "," + sy + "L" + tx + "," + ty;
var lineR = (sa2, sr, ta, tr2) => line2(sr * Math.cos(sa2), sr * Math.sin(sa2), tr2 * Math.cos(ta), tr2 * Math.sin(ta));
var arc2 = (sx, sy, tx, ty) => {
  var dx = tx - sx, dy = ty - sy, rr = Math.hypot(dx, dy) / 2, ra = 180 * Math.atan2(dy, dx) / Math.PI;
  return "M" + sx + "," + sy + "A" + rr + "," + rr + " " + ra + " 0 1 " + tx + "," + ty;
};
var arcR = (sa2, sr, ta, tr2) => arc2(sr * Math.cos(sa2), sr * Math.sin(sa2), tr2 * Math.cos(ta), tr2 * Math.sin(ta));
var curve = (sx, sy, tx, ty) => {
  const dx = tx - sx, dy = ty - sy, ix = 0.2 * (dx + dy), iy = 0.2 * (dy - dx);
  return "M" + sx + "," + sy + "C" + (sx + ix) + "," + (sy + iy) + " " + (tx + iy) + "," + (ty - ix) + " " + tx + "," + ty;
};
var curveR = (sa2, sr, ta, tr2) => curve(sr * Math.cos(sa2), sr * Math.sin(sa2), tr2 * Math.cos(ta), tr2 * Math.sin(ta));
var orthoX = (sx, sy, tx, ty) => "M" + sx + "," + sy + "V" + ty + "H" + tx;
var orthoY = (sx, sy, tx, ty) => "M" + sx + "," + sy + "H" + tx + "V" + ty;
var orthoR = (sa2, sr, ta, tr2) => {
  const sc = Math.cos(sa2), ss = Math.sin(sa2), tc = Math.cos(ta), ts2 = Math.sin(ta), sf = Math.abs(ta - sa2) > Math.PI ? ta <= sa2 : ta > sa2;
  return "M" + sr * sc + "," + sr * ss + "A" + sr + "," + sr + " 0 0," + (sf ? 1 : 0) + " " + sr * tc + "," + sr * ts2 + "L" + tr2 * tc + "," + tr2 * ts2;
};
var diagonalX = (sx, sy, tx, ty) => {
  const m = (sx + tx) / 2;
  return "M" + sx + "," + sy + "C" + m + "," + sy + " " + m + "," + ty + " " + tx + "," + ty;
};
var diagonalY = (sx, sy, tx, ty) => {
  const m = (sy + ty) / 2;
  return "M" + sx + "," + sy + "C" + sx + "," + m + " " + tx + "," + m + " " + tx + "," + ty;
};
var diagonalR = (sa2, sr, ta, tr2) => {
  const sc = Math.cos(sa2), ss = Math.sin(sa2), tc = Math.cos(ta), ts2 = Math.sin(ta), mr = (sr + tr2) / 2;
  return "M" + sr * sc + "," + sr * ss + "C" + mr * sc + "," + mr * ss + " " + mr * tc + "," + mr * ts2 + " " + tr2 * tc + "," + tr2 * ts2;
};
var Paths = fastmap({
  "line": line2,
  "line-radial": lineR,
  "arc": arc2,
  "arc-radial": arcR,
  "curve": curve,
  "curve-radial": curveR,
  "orthogonal-horizontal": orthoX,
  "orthogonal-vertical": orthoY,
  "orthogonal-radial": orthoR,
  "diagonal-horizontal": diagonalX,
  "diagonal-vertical": diagonalY,
  "diagonal-radial": diagonalR
});
function Pie(params2) {
  Transform.call(this, null, params2);
}
Pie.Definition = {
  "type": "Pie",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "field",
    "type": "field"
  }, {
    "name": "startAngle",
    "type": "number",
    "default": 0
  }, {
    "name": "endAngle",
    "type": "number",
    "default": 6.283185307179586
  }, {
    "name": "sort",
    "type": "boolean",
    "default": false
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "length": 2,
    "default": ["startAngle", "endAngle"]
  }]
};
inherits(Pie, Transform, {
  transform(_, pulse2) {
    var as = _.as || ["startAngle", "endAngle"], startAngle = as[0], endAngle = as[1], field3 = _.field || one, start = _.startAngle || 0, stop2 = _.endAngle != null ? _.endAngle : 2 * Math.PI, data3 = pulse2.source, values2 = data3.map(field3), n = values2.length, a = start, k2 = (stop2 - start) / sum(values2), index2 = range(n), i, t, v;
    if (_.sort) {
      index2.sort((a2, b2) => values2[a2] - values2[b2]);
    }
    for (i = 0; i < n; ++i) {
      v = values2[index2[i]];
      t = data3[index2[i]];
      t[startAngle] = a;
      t[endAngle] = a += v * k2;
    }
    this.value = values2;
    return pulse2.reflow(_.modified()).modifies(as);
  }
});
var DEFAULT_COUNT = 5;
function includeZero(scale6) {
  const type2 = scale6.type;
  return !scale6.bins && (type2 === Linear || type2 === Pow || type2 === Sqrt);
}
function includePad(type2) {
  return isContinuous(type2) && type2 !== Sequential;
}
var SKIP2 = toSet(["set", "modified", "clear", "type", "scheme", "schemeExtent", "schemeCount", "domain", "domainMin", "domainMid", "domainMax", "domainRaw", "domainImplicit", "nice", "zero", "bins", "range", "rangeStep", "round", "reverse", "interpolate", "interpolateGamma"]);
function Scale(params2) {
  Transform.call(this, null, params2);
  this.modified(true);
}
inherits(Scale, Transform, {
  transform(_, pulse2) {
    var df = pulse2.dataflow, scale$12 = this.value, key2 = scaleKey(_);
    if (!scale$12 || key2 !== scale$12.type) {
      this.value = scale$12 = scale(key2)();
    }
    for (key2 in _)
      if (!SKIP2[key2]) {
        if (key2 === "padding" && includePad(scale$12.type))
          continue;
        isFunction(scale$12[key2]) ? scale$12[key2](_[key2]) : df.warn("Unsupported scale property: " + key2);
      }
    configureRange(scale$12, _, configureBins(scale$12, _, configureDomain(scale$12, _, df)));
    return pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS);
  }
});
function scaleKey(_) {
  var t = _.type, d = "", n;
  if (t === Sequential)
    return Sequential + "-" + Linear;
  if (isContinuousColor(_)) {
    n = _.rawDomain ? _.rawDomain.length : _.domain ? _.domain.length + +(_.domainMid != null) : 0;
    d = n === 2 ? Sequential + "-" : n === 3 ? Diverging + "-" : "";
  }
  return (d + t || Linear).toLowerCase();
}
function isContinuousColor(_) {
  const t = _.type;
  return isContinuous(t) && t !== Time && t !== UTC && (_.scheme || _.range && _.range.length && _.range.every(isString));
}
function configureDomain(scale6, _, df) {
  const raw = rawDomain(scale6, _.domainRaw, df);
  if (raw > -1)
    return raw;
  var domain2 = _.domain, type2 = scale6.type, zero3 = _.zero || _.zero === void 0 && includeZero(scale6), n, mid;
  if (!domain2)
    return 0;
  if (includePad(type2) && _.padding && domain2[0] !== peek(domain2)) {
    domain2 = padDomain(type2, domain2, _.range, _.padding, _.exponent, _.constant);
  }
  if (zero3 || _.domainMin != null || _.domainMax != null || _.domainMid != null) {
    n = (domain2 = domain2.slice()).length - 1 || 1;
    if (zero3) {
      if (domain2[0] > 0)
        domain2[0] = 0;
      if (domain2[n] < 0)
        domain2[n] = 0;
    }
    if (_.domainMin != null)
      domain2[0] = _.domainMin;
    if (_.domainMax != null)
      domain2[n] = _.domainMax;
    if (_.domainMid != null) {
      mid = _.domainMid;
      const i = mid > domain2[n] ? n + 1 : mid < domain2[0] ? 0 : n;
      if (i !== n)
        df.warn("Scale domainMid exceeds domain min or max.", mid);
      domain2.splice(i, 0, mid);
    }
  }
  scale6.domain(domainCheck(type2, domain2, df));
  if (type2 === Ordinal) {
    scale6.unknown(_.domainImplicit ? implicit : void 0);
  }
  if (_.nice && scale6.nice) {
    scale6.nice(_.nice !== true && tickCount(scale6, _.nice) || null);
  }
  return domain2.length;
}
function rawDomain(scale6, raw, df) {
  if (raw) {
    scale6.domain(domainCheck(scale6.type, raw, df));
    return raw.length;
  } else {
    return -1;
  }
}
function padDomain(type2, domain2, range4, pad2, exponent, constant3) {
  var span2 = Math.abs(peek(range4) - range4[0]), frac = span2 / (span2 - 2 * pad2), d = type2 === Log ? zoomLog(domain2, null, frac) : type2 === Sqrt ? zoomPow(domain2, null, frac, 0.5) : type2 === Pow ? zoomPow(domain2, null, frac, exponent || 1) : type2 === Symlog ? zoomSymlog(domain2, null, frac, constant3 || 1) : zoomLinear(domain2, null, frac);
  domain2 = domain2.slice();
  domain2[0] = d[0];
  domain2[domain2.length - 1] = d[1];
  return domain2;
}
function domainCheck(type2, domain2, df) {
  if (isLogarithmic(type2)) {
    var s = Math.abs(domain2.reduce((s2, v) => s2 + (v < 0 ? -1 : v > 0 ? 1 : 0), 0));
    if (s !== domain2.length) {
      df.warn("Log scale domain includes zero: " + $(domain2));
    }
  }
  return domain2;
}
function configureBins(scale6, _, count) {
  let bins = _.bins;
  if (bins && !isArray(bins)) {
    const domain2 = scale6.domain(), lo = domain2[0], hi = peek(domain2), step = bins.step;
    let start = bins.start == null ? lo : bins.start, stop2 = bins.stop == null ? hi : bins.stop;
    if (!step)
      error("Scale bins parameter missing step property.");
    if (start < lo)
      start = step * Math.ceil(lo / step);
    if (stop2 > hi)
      stop2 = step * Math.floor(hi / step);
    bins = range(start, stop2 + step / 2, step);
  }
  if (bins) {
    scale6.bins = bins;
  } else if (scale6.bins) {
    delete scale6.bins;
  }
  if (scale6.type === BinOrdinal) {
    if (!bins) {
      scale6.bins = scale6.domain();
    } else if (!_.domain && !_.domainRaw) {
      scale6.domain(bins);
      count = bins.length;
    }
  }
  return count;
}
function configureRange(scale6, _, count) {
  var type2 = scale6.type, round2 = _.round || false, range4 = _.range;
  if (_.rangeStep != null) {
    range4 = configureRangeStep(type2, _, count);
  } else if (_.scheme) {
    range4 = configureScheme(type2, _, count);
    if (isFunction(range4)) {
      if (scale6.interpolator) {
        return scale6.interpolator(range4);
      } else {
        error(`Scale type ${type2} does not support interpolating color schemes.`);
      }
    }
  }
  if (range4 && isInterpolating(type2)) {
    return scale6.interpolator(interpolateColors(flip(range4, _.reverse), _.interpolate, _.interpolateGamma));
  }
  if (range4 && _.interpolate && scale6.interpolate) {
    scale6.interpolate(interpolate(_.interpolate, _.interpolateGamma));
  } else if (isFunction(scale6.round)) {
    scale6.round(round2);
  } else if (isFunction(scale6.rangeRound)) {
    scale6.interpolate(round2 ? round_default : value_default);
  }
  if (range4)
    scale6.range(flip(range4, _.reverse));
}
function configureRangeStep(type2, _, count) {
  if (type2 !== Band && type2 !== Point) {
    error("Only band and point scales support rangeStep.");
  }
  var outer = (_.paddingOuter != null ? _.paddingOuter : _.padding) || 0, inner = type2 === Point ? 1 : (_.paddingInner != null ? _.paddingInner : _.padding) || 0;
  return [0, _.rangeStep * bandSpace(count, inner, outer)];
}
function configureScheme(type2, _, count) {
  var extent2 = _.schemeExtent, name, scheme$1;
  if (isArray(_.scheme)) {
    scheme$1 = interpolateColors(_.scheme, _.interpolate, _.interpolateGamma);
  } else {
    name = _.scheme.toLowerCase();
    scheme$1 = scheme(name);
    if (!scheme$1)
      error(`Unrecognized scheme name: ${_.scheme}`);
  }
  count = type2 === Threshold ? count + 1 : type2 === BinOrdinal ? count - 1 : type2 === Quantile2 || type2 === Quantize ? +_.schemeCount || DEFAULT_COUNT : count;
  return isInterpolating(type2) ? adjustScheme(scheme$1, extent2, _.reverse) : isFunction(scheme$1) ? quantizeInterpolator(adjustScheme(scheme$1, extent2), count) : type2 === Ordinal ? scheme$1 : scheme$1.slice(0, count);
}
function adjustScheme(scheme2, extent2, reverse2) {
  return isFunction(scheme2) && (extent2 || reverse2) ? interpolateRange(scheme2, flip(extent2 || [0, 1], reverse2)) : scheme2;
}
function flip(array4, reverse2) {
  return reverse2 ? array4.slice().reverse() : array4;
}
function SortItems(params2) {
  Transform.call(this, null, params2);
}
inherits(SortItems, Transform, {
  transform(_, pulse2) {
    const mod = _.modified("sort") || pulse2.changed(pulse2.ADD) || pulse2.modified(_.sort.fields) || pulse2.modified("datum");
    if (mod)
      pulse2.source.sort(stableCompare(_.sort));
    this.modified(mod);
    return pulse2;
  }
});
var Zero = "zero";
var Center = "center";
var Normalize = "normalize";
var DefOutput = ["y0", "y1"];
function Stack(params2) {
  Transform.call(this, null, params2);
}
Stack.Definition = {
  "type": "Stack",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "field",
    "type": "field"
  }, {
    "name": "groupby",
    "type": "field",
    "array": true
  }, {
    "name": "sort",
    "type": "compare"
  }, {
    "name": "offset",
    "type": "enum",
    "default": Zero,
    "values": [Zero, Center, Normalize]
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "length": 2,
    "default": DefOutput
  }]
};
inherits(Stack, Transform, {
  transform(_, pulse2) {
    var as = _.as || DefOutput, y02 = as[0], y12 = as[1], sort2 = stableCompare(_.sort), field3 = _.field || one, stack = _.offset === Center ? stackCenter : _.offset === Normalize ? stackNormalize : stackZero, groups, i, n, max4;
    groups = partition2(pulse2.source, _.groupby, sort2, field3);
    for (i = 0, n = groups.length, max4 = groups.max; i < n; ++i) {
      stack(groups[i], max4, field3, y02, y12);
    }
    return pulse2.reflow(_.modified()).modifies(as);
  }
});
function stackCenter(group2, max4, field3, y02, y12) {
  var last = (max4 - group2.sum) / 2, m = group2.length, j = 0, t;
  for (; j < m; ++j) {
    t = group2[j];
    t[y02] = last;
    t[y12] = last += Math.abs(field3(t));
  }
}
function stackNormalize(group2, max4, field3, y02, y12) {
  var scale6 = 1 / group2.sum, last = 0, m = group2.length, j = 0, v = 0, t;
  for (; j < m; ++j) {
    t = group2[j];
    t[y02] = last;
    t[y12] = last = scale6 * (v += Math.abs(field3(t)));
  }
}
function stackZero(group2, max4, field3, y02, y12) {
  var lastPos = 0, lastNeg = 0, m = group2.length, j = 0, v, t;
  for (; j < m; ++j) {
    t = group2[j];
    v = +field3(t);
    if (v < 0) {
      t[y02] = lastNeg;
      t[y12] = lastNeg += v;
    } else {
      t[y02] = lastPos;
      t[y12] = lastPos += v;
    }
  }
}
function partition2(data3, groupby, sort2, field3) {
  var groups = [], get5 = (f) => f(t), map2, i, n, m, t, k2, g, s, max4;
  if (groupby == null) {
    groups.push(data3.slice());
  } else {
    for (map2 = {}, i = 0, n = data3.length; i < n; ++i) {
      t = data3[i];
      k2 = groupby.map(get5);
      g = map2[k2];
      if (!g) {
        map2[k2] = g = [];
        groups.push(g);
      }
      g.push(t);
    }
  }
  for (k2 = 0, max4 = 0, m = groups.length; k2 < m; ++k2) {
    g = groups[k2];
    for (i = 0, s = 0, n = g.length; i < n; ++i) {
      s += Math.abs(field3(g[i]));
    }
    g.sum = s;
    if (s > max4)
      max4 = s;
    if (sort2)
      g.sort(sort2);
  }
  groups.max = max4;
  return groups;
}

// node_modules/vega-geo/build/vega-geo.module.js
var vega_geo_module_exports = {};
__export(vega_geo_module_exports, {
  contour: () => Contour,
  geojson: () => GeoJSON,
  geopath: () => GeoPath,
  geopoint: () => GeoPoint,
  geoshape: () => GeoShape,
  graticule: () => Graticule,
  heatmap: () => Heatmap,
  isocontour: () => Isocontour,
  kde2d: () => KDE2D,
  projection: () => Projection
});

// node_modules/d3-geo-projection/src/math.js
var abs = Math.abs;
var atan = Math.atan;
var atan2 = Math.atan2;
var cos = Math.cos;
var exp3 = Math.exp;
var floor2 = Math.floor;
var log4 = Math.log;
var max3 = Math.max;
var min3 = Math.min;
var pow4 = Math.pow;
var sign = Math.sign || function(x2) {
  return x2 > 0 ? 1 : x2 < 0 ? -1 : 0;
};
var sin = Math.sin;
var tan = Math.tan;
var epsilon2 = 1e-6;
var epsilon22 = 1e-12;
var pi = Math.PI;
var halfPi = pi / 2;
var quarterPi = pi / 4;
var sqrt1_2 = Math.SQRT1_2;
var sqrt2 = sqrt3(2);
var sqrtPi = sqrt3(pi);
var tau = pi * 2;
var degrees = 180 / pi;
var radians = pi / 180;
function sinci(x2) {
  return x2 ? x2 / Math.sin(x2) : 1;
}
function asin(x2) {
  return x2 > 1 ? halfPi : x2 < -1 ? -halfPi : Math.asin(x2);
}
function acos(x2) {
  return x2 > 1 ? 0 : x2 < -1 ? pi : Math.acos(x2);
}
function sqrt3(x2) {
  return x2 > 0 ? Math.sqrt(x2) : 0;
}
function tanh(x2) {
  x2 = exp3(2 * x2);
  return (x2 - 1) / (x2 + 1);
}
function sinh(x2) {
  return (exp3(x2) - exp3(-x2)) / 2;
}
function cosh(x2) {
  return (exp3(x2) + exp3(-x2)) / 2;
}
function arsinh(x2) {
  return log4(x2 + sqrt3(x2 * x2 + 1));
}
function arcosh(x2) {
  return log4(x2 + sqrt3(x2 * x2 - 1));
}

// node_modules/d3-geo-projection/src/aitoff.js
function aitoffRaw(x2, y2) {
  var cosy = cos(y2), sincia = sinci(acos(cosy * cos(x2 /= 2)));
  return [2 * cosy * sin(x2) * sincia, sin(y2) * sincia];
}
aitoffRaw.invert = function(x2, y2) {
  if (x2 * x2 + 4 * y2 * y2 > pi * pi + epsilon2)
    return;
  var x12 = x2, y12 = y2, i = 25;
  do {
    var sinx = sin(x12), sinx_2 = sin(x12 / 2), cosx_2 = cos(x12 / 2), siny = sin(y12), cosy = cos(y12), sin_2y = sin(2 * y12), sin2y = siny * siny, cos2y = cosy * cosy, sin2x_2 = sinx_2 * sinx_2, c = 1 - cos2y * cosx_2 * cosx_2, e = c ? acos(cosy * cosx_2) * sqrt3(f = 1 / c) : f = 0, f, fx = 2 * e * cosy * sinx_2 - x2, fy = e * siny - y2, dxdx = f * (cos2y * sin2x_2 + e * cosy * cosx_2 * sin2y), dxdy = f * (0.5 * sinx * sin_2y - e * 2 * siny * sinx_2), dydx = f * 0.25 * (sin_2y * sinx_2 - e * siny * cos2y * sinx), dydy = f * (sin2y * cosx_2 + e * sin2x_2 * cosy), z = dxdy * dydx - dydy * dxdx;
    if (!z)
      break;
    var dx = (fy * dxdy - fx * dydy) / z, dy = (fx * dydx - fy * dxdx) / z;
    x12 -= dx, y12 -= dy;
  } while ((abs(dx) > epsilon2 || abs(dy) > epsilon2) && --i > 0);
  return [x12, y12];
};

// node_modules/d3-geo-projection/src/august.js
function augustRaw(lambda, phi) {
  var tanPhi = tan(phi / 2), k2 = sqrt3(1 - tanPhi * tanPhi), c = 1 + k2 * cos(lambda /= 2), x2 = sin(lambda) * k2 / c, y2 = tanPhi / c, x22 = x2 * x2, y22 = y2 * y2;
  return [
    4 / 3 * x2 * (3 + x22 - 3 * y22),
    4 / 3 * y2 * (3 + 3 * x22 - y22)
  ];
}
augustRaw.invert = function(x2, y2) {
  x2 *= 3 / 8, y2 *= 3 / 8;
  if (!x2 && abs(y2) > 1)
    return null;
  var x22 = x2 * x2, y22 = y2 * y2, s = 1 + x22 + y22, sin3Eta = sqrt3((s - sqrt3(s * s - 4 * y2 * y2)) / 2), eta = asin(sin3Eta) / 3, xi = sin3Eta ? arcosh(abs(y2 / sin3Eta)) / 3 : arsinh(abs(x2)) / 3, cosEta = cos(eta), coshXi = cosh(xi), d = coshXi * coshXi - cosEta * cosEta;
  return [
    sign(x2) * 2 * atan2(sinh(xi) * cosEta, 0.25 - d),
    sign(y2) * 2 * atan2(coshXi * sin(eta), 0.25 + d)
  ];
};

// node_modules/d3-geo-projection/src/baker.js
var sqrt8 = sqrt3(8);
var phi0 = log4(1 + sqrt2);
function bakerRaw(lambda, phi) {
  var phi02 = abs(phi);
  return phi02 < quarterPi ? [lambda, log4(tan(quarterPi + phi / 2))] : [lambda * cos(phi02) * (2 * sqrt2 - 1 / sin(phi02)), sign(phi) * (2 * sqrt2 * (phi02 - quarterPi) - log4(tan(phi02 / 2)))];
}
bakerRaw.invert = function(x2, y2) {
  if ((y02 = abs(y2)) < phi0)
    return [x2, 2 * atan(exp3(y2)) - halfPi];
  var phi = quarterPi, i = 25, delta, y02;
  do {
    var cosPhi_2 = cos(phi / 2), tanPhi_2 = tan(phi / 2);
    phi -= delta = (sqrt8 * (phi - quarterPi) - log4(tanPhi_2) - y02) / (sqrt8 - cosPhi_2 * cosPhi_2 / (2 * tanPhi_2));
  } while (abs(delta) > epsilon22 && --i > 0);
  return [x2 / (cos(phi) * (sqrt8 - 1 / sin(phi))), sign(y2) * phi];
};

// node_modules/d3-geo-projection/src/hammer.js
function hammerQuarticAuthalicRaw(lambda, phi) {
  return [
    lambda * cos(phi) / cos(phi /= 2),
    2 * sin(phi)
  ];
}
hammerQuarticAuthalicRaw.invert = function(x2, y2) {
  var phi = 2 * asin(y2 / 2);
  return [
    x2 * cos(phi / 2) / cos(phi),
    phi
  ];
};

// node_modules/d3-geo-projection/src/newton.js
function solve(f, y2, x2) {
  var steps = 100, delta, f0, f1;
  x2 = x2 === void 0 ? 0 : +x2;
  y2 = +y2;
  do {
    f0 = f(x2);
    f1 = f(x2 + epsilon2);
    if (f0 === f1)
      f1 = f0 + epsilon2;
    x2 -= delta = -1 * epsilon2 * (f0 - y2) / (f0 - f1);
  } while (steps-- > 0 && abs(delta) > epsilon2);
  return steps < 0 ? NaN : x2;
}

// node_modules/d3-geo-projection/src/mollweide.js
function mollweideBromleyTheta(cp, phi) {
  var cpsinPhi = cp * sin(phi), i = 30, delta;
  do
    phi -= delta = (phi + sin(phi) - cpsinPhi) / (1 + cos(phi));
  while (abs(delta) > epsilon2 && --i > 0);
  return phi / 2;
}
function mollweideBromleyRaw(cx, cy, cp) {
  function forward(lambda, phi) {
    return [cx * lambda * cos(phi = mollweideBromleyTheta(cp, phi)), cy * sin(phi)];
  }
  forward.invert = function(x2, y2) {
    return y2 = asin(y2 / cy), [x2 / (cx * cos(y2)), asin((2 * y2 + sin(2 * y2)) / cp)];
  };
  return forward;
}
var mollweideRaw = mollweideBromleyRaw(sqrt2 / halfPi, sqrt2, pi);
function mollweide_default() {
  return projection(mollweideRaw).scale(169.529);
}

// node_modules/d3-geo-projection/src/boggs.js
var k = 2.00276;
var w2 = 1.11072;
function boggsRaw(lambda, phi) {
  var theta = mollweideBromleyTheta(pi, phi);
  return [k * lambda / (1 / cos(phi) + w2 / cos(theta)), (phi + sqrt2 * sin(theta)) / k];
}
boggsRaw.invert = function(x2, y2) {
  var ky = k * y2, theta = y2 < 0 ? -quarterPi : quarterPi, i = 25, delta, phi;
  do {
    phi = ky - sqrt2 * sin(theta);
    theta -= delta = (sin(2 * theta) + 2 * theta - pi * sin(phi)) / (2 * cos(2 * theta) + 2 + pi * cos(phi) * sqrt2 * cos(theta));
  } while (abs(delta) > epsilon2 && --i > 0);
  phi = ky - sqrt2 * sin(theta);
  return [x2 * (1 / cos(phi) + w2 / cos(theta)) / k, phi];
};

// node_modules/d3-geo-projection/src/sinusoidal.js
function sinusoidalRaw(lambda, phi) {
  return [lambda * cos(phi), phi];
}
sinusoidalRaw.invert = function(x2, y2) {
  return [x2 / cos(y2), y2];
};

// node_modules/d3-geo-projection/src/bromley.js
var bromleyRaw = mollweideBromleyRaw(1, 4 / pi, pi);

// node_modules/d3-geo-projection/src/collignon.js
function collignonRaw(lambda, phi) {
  var alpha = sqrt3(1 - sin(phi));
  return [2 / sqrtPi * lambda * alpha, sqrtPi * (1 - alpha)];
}
collignonRaw.invert = function(x2, y2) {
  var lambda = (lambda = y2 / sqrtPi - 1) * lambda;
  return [lambda > 0 ? x2 * sqrt3(pi / lambda) / 2 : 0, asin(1 - lambda)];
};

// node_modules/d3-geo-projection/src/craster.js
var sqrt32 = sqrt3(3);
function crasterRaw(lambda, phi) {
  return [sqrt32 * lambda * (2 * cos(2 * phi / 3) - 1) / sqrtPi, sqrt32 * sqrtPi * sin(phi / 3)];
}
crasterRaw.invert = function(x2, y2) {
  var phi = 3 * asin(y2 / (sqrt32 * sqrtPi));
  return [sqrtPi * x2 / (sqrt32 * (2 * cos(2 * phi / 3) - 1)), phi];
};

// node_modules/d3-geo-projection/src/cylindricalEqualArea.js
function cylindricalEqualAreaRaw(phi02) {
  var cosPhi0 = cos(phi02);
  function forward(lambda, phi) {
    return [lambda * cosPhi0, sin(phi) / cosPhi0];
  }
  forward.invert = function(x2, y2) {
    return [x2 / cosPhi0, asin(y2 * cosPhi0)];
  };
  return forward;
}

// node_modules/d3-geo-projection/src/eckert1.js
function eckert1Raw(lambda, phi) {
  var alpha = sqrt3(8 / (3 * pi));
  return [
    alpha * lambda * (1 - abs(phi) / pi),
    alpha * phi
  ];
}
eckert1Raw.invert = function(x2, y2) {
  var alpha = sqrt3(8 / (3 * pi)), phi = y2 / alpha;
  return [
    x2 / (alpha * (1 - abs(phi) / pi)),
    phi
  ];
};

// node_modules/d3-geo-projection/src/eckert2.js
function eckert2Raw(lambda, phi) {
  var alpha = sqrt3(4 - 3 * sin(abs(phi)));
  return [
    2 / sqrt3(6 * pi) * lambda * alpha,
    sign(phi) * sqrt3(2 * pi / 3) * (2 - alpha)
  ];
}
eckert2Raw.invert = function(x2, y2) {
  var alpha = 2 - abs(y2) / sqrt3(2 * pi / 3);
  return [
    x2 * sqrt3(6 * pi) / (2 * alpha),
    sign(y2) * asin((4 - alpha * alpha) / 3)
  ];
};

// node_modules/d3-geo-projection/src/eckert3.js
function eckert3Raw(lambda, phi) {
  var k2 = sqrt3(pi * (4 + pi));
  return [
    2 / k2 * lambda * (1 + sqrt3(1 - 4 * phi * phi / (pi * pi))),
    4 / k2 * phi
  ];
}
eckert3Raw.invert = function(x2, y2) {
  var k2 = sqrt3(pi * (4 + pi)) / 2;
  return [
    x2 * k2 / (1 + sqrt3(1 - y2 * y2 * (4 + pi) / (4 * pi))),
    y2 * k2 / 2
  ];
};

// node_modules/d3-geo-projection/src/eckert4.js
function eckert4Raw(lambda, phi) {
  var k2 = (2 + halfPi) * sin(phi);
  phi /= 2;
  for (var i = 0, delta = Infinity; i < 10 && abs(delta) > epsilon2; i++) {
    var cosPhi = cos(phi);
    phi -= delta = (phi + sin(phi) * (cosPhi + 2) - k2) / (2 * cosPhi * (1 + cosPhi));
  }
  return [
    2 / sqrt3(pi * (4 + pi)) * lambda * (1 + cos(phi)),
    2 * sqrt3(pi / (4 + pi)) * sin(phi)
  ];
}
eckert4Raw.invert = function(x2, y2) {
  var A2 = y2 * sqrt3((4 + pi) / pi) / 2, k2 = asin(A2), c = cos(k2);
  return [
    x2 / (2 / sqrt3(pi * (4 + pi)) * (1 + c)),
    asin((k2 + A2 * (c + 2)) / (2 + halfPi))
  ];
};

// node_modules/d3-geo-projection/src/eckert5.js
function eckert5Raw(lambda, phi) {
  return [
    lambda * (1 + cos(phi)) / sqrt3(2 + pi),
    2 * phi / sqrt3(2 + pi)
  ];
}
eckert5Raw.invert = function(x2, y2) {
  var k2 = sqrt3(2 + pi), phi = y2 * k2 / 2;
  return [
    k2 * x2 / (1 + cos(phi)),
    phi
  ];
};

// node_modules/d3-geo-projection/src/eckert6.js
function eckert6Raw(lambda, phi) {
  var k2 = (1 + halfPi) * sin(phi);
  for (var i = 0, delta = Infinity; i < 10 && abs(delta) > epsilon2; i++) {
    phi -= delta = (phi + sin(phi) - k2) / (1 + cos(phi));
  }
  k2 = sqrt3(2 + pi);
  return [
    lambda * (1 + cos(phi)) / k2,
    2 * phi / k2
  ];
}
eckert6Raw.invert = function(x2, y2) {
  var j = 1 + halfPi, k2 = sqrt3(j / 2);
  return [
    x2 * 2 * k2 / (1 + cos(y2 *= k2)),
    asin((y2 + sin(y2)) / j)
  ];
};

// node_modules/d3-geo-projection/src/eisenlohr.js
var eisenlohrK = 3 + 2 * sqrt2;
function eisenlohrRaw(lambda, phi) {
  var s0 = sin(lambda /= 2), c0 = cos(lambda), k2 = sqrt3(cos(phi)), c1 = cos(phi /= 2), t = sin(phi) / (c1 + sqrt2 * c0 * k2), c = sqrt3(2 / (1 + t * t)), v = sqrt3((sqrt2 * c1 + (c0 + s0) * k2) / (sqrt2 * c1 + (c0 - s0) * k2));
  return [
    eisenlohrK * (c * (v - 1 / v) - 2 * log4(v)),
    eisenlohrK * (c * t * (v + 1 / v) - 2 * atan(t))
  ];
}
eisenlohrRaw.invert = function(x2, y2) {
  if (!(p = augustRaw.invert(x2 / 1.2, y2 * 1.065)))
    return null;
  var lambda = p[0], phi = p[1], i = 20, p;
  x2 /= eisenlohrK, y2 /= eisenlohrK;
  do {
    var _0 = lambda / 2, _1 = phi / 2, s0 = sin(_0), c0 = cos(_0), s1 = sin(_1), c1 = cos(_1), cos1 = cos(phi), k2 = sqrt3(cos1), t = s1 / (c1 + sqrt2 * c0 * k2), t2 = t * t, c = sqrt3(2 / (1 + t2)), v0 = sqrt2 * c1 + (c0 + s0) * k2, v1 = sqrt2 * c1 + (c0 - s0) * k2, v2 = v0 / v1, v = sqrt3(v2), vm1v = v - 1 / v, vp1v = v + 1 / v, fx = c * vm1v - 2 * log4(v) - x2, fy = c * t * vp1v - 2 * atan(t) - y2, deltatDeltaLambda = s1 && sqrt1_2 * k2 * s0 * t2 / s1, deltatDeltaPhi = (sqrt2 * c0 * c1 + k2) / (2 * (c1 + sqrt2 * c0 * k2) * (c1 + sqrt2 * c0 * k2) * k2), deltacDeltat = -0.5 * t * c * c * c, deltacDeltaLambda = deltacDeltat * deltatDeltaLambda, deltacDeltaPhi = deltacDeltat * deltatDeltaPhi, A2 = (A2 = 2 * c1 + sqrt2 * k2 * (c0 - s0)) * A2 * v, deltavDeltaLambda = (sqrt2 * c0 * c1 * k2 + cos1) / A2, deltavDeltaPhi = -(sqrt2 * s0 * s1) / (k2 * A2), deltaxDeltaLambda = vm1v * deltacDeltaLambda - 2 * deltavDeltaLambda / v + c * (deltavDeltaLambda + deltavDeltaLambda / v2), deltaxDeltaPhi = vm1v * deltacDeltaPhi - 2 * deltavDeltaPhi / v + c * (deltavDeltaPhi + deltavDeltaPhi / v2), deltayDeltaLambda = t * vp1v * deltacDeltaLambda - 2 * deltatDeltaLambda / (1 + t2) + c * vp1v * deltatDeltaLambda + c * t * (deltavDeltaLambda - deltavDeltaLambda / v2), deltayDeltaPhi = t * vp1v * deltacDeltaPhi - 2 * deltatDeltaPhi / (1 + t2) + c * vp1v * deltatDeltaPhi + c * t * (deltavDeltaPhi - deltavDeltaPhi / v2), denominator = deltaxDeltaPhi * deltayDeltaLambda - deltayDeltaPhi * deltaxDeltaLambda;
    if (!denominator)
      break;
    var deltaLambda = (fy * deltaxDeltaPhi - fx * deltayDeltaPhi) / denominator, deltaPhi = (fx * deltayDeltaLambda - fy * deltaxDeltaLambda) / denominator;
    lambda -= deltaLambda;
    phi = max3(-halfPi, min3(halfPi, phi - deltaPhi));
  } while ((abs(deltaLambda) > epsilon2 || abs(deltaPhi) > epsilon2) && --i > 0);
  return abs(abs(phi) - halfPi) < epsilon2 ? [0, phi] : i && [lambda, phi];
};

// node_modules/d3-geo-projection/src/fahey.js
var faheyK = cos(35 * radians);
function faheyRaw(lambda, phi) {
  var t = tan(phi / 2);
  return [lambda * faheyK * sqrt3(1 - t * t), (1 + faheyK) * t];
}
faheyRaw.invert = function(x2, y2) {
  var t = y2 / (1 + faheyK);
  return [x2 && x2 / (faheyK * sqrt3(1 - t * t)), 2 * atan(t)];
};

// node_modules/d3-geo-projection/src/foucaut.js
function foucautRaw(lambda, phi) {
  var k2 = phi / 2, cosk = cos(k2);
  return [2 * lambda / sqrtPi * cos(phi) * cosk * cosk, sqrtPi * tan(k2)];
}
foucautRaw.invert = function(x2, y2) {
  var k2 = atan(y2 / sqrtPi), cosk = cos(k2), phi = 2 * k2;
  return [x2 * sqrtPi / 2 / (cos(phi) * cosk * cosk), phi];
};

// node_modules/d3-geo-projection/src/ginzburgPolyconic.js
function ginzburgPolyconic_default(a, b2, c, d, e, f, g, h2) {
  if (arguments.length < 8)
    h2 = 0;
  function forward(lambda, phi) {
    if (!phi)
      return [a * lambda / pi, 0];
    var phi2 = phi * phi, xB = a + phi2 * (b2 + phi2 * (c + phi2 * d)), yB = phi * (e - 1 + phi2 * (f - h2 + phi2 * g)), m = (xB * xB + yB * yB) / (2 * yB), alpha = lambda * asin(xB / m) / pi;
    return [m * sin(alpha), phi * (1 + phi2 * h2) + m * (1 - cos(alpha))];
  }
  forward.invert = function(x2, y2) {
    var lambda = pi * x2 / a, phi = y2, deltaLambda, deltaPhi, i = 50;
    do {
      var phi2 = phi * phi, xB = a + phi2 * (b2 + phi2 * (c + phi2 * d)), yB = phi * (e - 1 + phi2 * (f - h2 + phi2 * g)), p = xB * xB + yB * yB, q = 2 * yB, m = p / q, m2 = m * m, dAlphadLambda = asin(xB / m) / pi, alpha = lambda * dAlphadLambda, xB2 = xB * xB, dxBdPhi = (2 * b2 + phi2 * (4 * c + phi2 * 6 * d)) * phi, dyBdPhi = e + phi2 * (3 * f + phi2 * 5 * g), dpdPhi = 2 * (xB * dxBdPhi + yB * (dyBdPhi - 1)), dqdPhi = 2 * (dyBdPhi - 1), dmdPhi = (dpdPhi * q - p * dqdPhi) / (q * q), cosAlpha = cos(alpha), sinAlpha = sin(alpha), mcosAlpha = m * cosAlpha, msinAlpha = m * sinAlpha, dAlphadPhi = lambda / pi * (1 / sqrt3(1 - xB2 / m2)) * (dxBdPhi * m - xB * dmdPhi) / m2, fx = msinAlpha - x2, fy = phi * (1 + phi2 * h2) + m - mcosAlpha - y2, deltaxDeltaPhi = dmdPhi * sinAlpha + mcosAlpha * dAlphadPhi, deltaxDeltaLambda = mcosAlpha * dAlphadLambda, deltayDeltaPhi = 1 + dmdPhi - (dmdPhi * cosAlpha - msinAlpha * dAlphadPhi), deltayDeltaLambda = msinAlpha * dAlphadLambda, denominator = deltaxDeltaPhi * deltayDeltaLambda - deltayDeltaPhi * deltaxDeltaLambda;
      if (!denominator)
        break;
      lambda -= deltaLambda = (fy * deltaxDeltaPhi - fx * deltayDeltaPhi) / denominator;
      phi -= deltaPhi = (fx * deltayDeltaLambda - fy * deltaxDeltaLambda) / denominator;
    } while ((abs(deltaLambda) > epsilon2 || abs(deltaPhi) > epsilon2) && --i > 0);
    return [lambda, phi];
  };
  return forward;
}

// node_modules/d3-geo-projection/src/ginzburg4.js
var ginzburg4Raw = ginzburgPolyconic_default(2.8284, -1.6988, 0.75432, -0.18071, 1.76003, -0.38914, 0.042555);

// node_modules/d3-geo-projection/src/ginzburg5.js
var ginzburg5Raw = ginzburgPolyconic_default(2.583819, -0.835827, 0.170354, -0.038094, 1.543313, -0.411435, 0.082742);

// node_modules/d3-geo-projection/src/ginzburg6.js
var ginzburg6Raw = ginzburgPolyconic_default(5 / 6 * pi, -0.62636, -0.0344, 0, 1.3493, -0.05524, 0, 0.045);

// node_modules/d3-geo-projection/src/ginzburg8.js
function ginzburg8Raw(lambda, phi) {
  var lambda2 = lambda * lambda, phi2 = phi * phi;
  return [
    lambda * (1 - 0.162388 * phi2) * (0.87 - 952426e-9 * lambda2 * lambda2),
    phi * (1 + phi2 / 12)
  ];
}
ginzburg8Raw.invert = function(x2, y2) {
  var lambda = x2, phi = y2, i = 50, delta;
  do {
    var phi2 = phi * phi;
    phi -= delta = (phi * (1 + phi2 / 12) - y2) / (1 + phi2 / 4);
  } while (abs(delta) > epsilon2 && --i > 0);
  i = 50;
  x2 /= 1 - 0.162388 * phi2;
  do {
    var lambda4 = (lambda4 = lambda * lambda) * lambda4;
    lambda -= delta = (lambda * (0.87 - 952426e-9 * lambda4) - x2) / (0.87 - 476213e-8 * lambda4);
  } while (abs(delta) > epsilon2 && --i > 0);
  return [lambda, phi];
};

// node_modules/d3-geo-projection/src/ginzburg9.js
var ginzburg9Raw = ginzburgPolyconic_default(2.6516, -0.76534, 0.19123, -0.047094, 1.36289, -0.13965, 0.031762);

// node_modules/d3-geo-projection/src/gringorten.js
function gringortenRaw(lambda, phi) {
  var sLambda = sign(lambda), sPhi = sign(phi), cosPhi = cos(phi), x2 = cos(lambda) * cosPhi, y2 = sin(lambda) * cosPhi, z = sin(sPhi * phi);
  lambda = abs(atan2(y2, z));
  phi = asin(x2);
  if (abs(lambda - halfPi) > epsilon2)
    lambda %= halfPi;
  var point3 = gringortenHexadecant(lambda > pi / 4 ? halfPi - lambda : lambda, phi);
  if (lambda > pi / 4)
    z = point3[0], point3[0] = -point3[1], point3[1] = -z;
  return point3[0] *= sLambda, point3[1] *= -sPhi, point3;
}
gringortenRaw.invert = function(x2, y2) {
  if (abs(x2) > 1)
    x2 = sign(x2) * 2 - x2;
  if (abs(y2) > 1)
    y2 = sign(y2) * 2 - y2;
  var sx = sign(x2), sy = sign(y2), x02 = -sx * x2, y02 = -sy * y2, t = y02 / x02 < 1, p = gringortenHexadecantInvert(t ? y02 : x02, t ? x02 : y02), lambda = p[0], phi = p[1], cosPhi = cos(phi);
  if (t)
    lambda = -halfPi - lambda;
  return [sx * (atan2(sin(lambda) * cosPhi, -sin(phi)) + pi), sy * asin(cos(lambda) * cosPhi)];
};
function gringortenHexadecant(lambda, phi) {
  if (phi === halfPi)
    return [0, 0];
  var sinPhi = sin(phi), r = sinPhi * sinPhi, r2 = r * r, j = 1 + r2, k2 = 1 + 3 * r2, q = 1 - r2, z = asin(1 / sqrt3(j)), v = q + r * j * z, p2 = (1 - sinPhi) / v, p = sqrt3(p2), a2 = p2 * j, a = sqrt3(a2), h2 = p * q, x2, i;
  if (lambda === 0)
    return [0, -(h2 + r * a)];
  var cosPhi = cos(phi), secPhi = 1 / cosPhi, drdPhi = 2 * sinPhi * cosPhi, dvdPhi = (-3 * r + z * k2) * drdPhi, dp2dPhi = (-v * cosPhi - (1 - sinPhi) * dvdPhi) / (v * v), dpdPhi = 0.5 * dp2dPhi / p, dhdPhi = q * dpdPhi - 2 * r * p * drdPhi, dra2dPhi = r * j * dp2dPhi + p2 * k2 * drdPhi, mu = -secPhi * drdPhi, nu = -secPhi * dra2dPhi, zeta = -2 * secPhi * dhdPhi, lambda1 = 4 * lambda / pi, delta;
  if (lambda > 0.222 * pi || phi < pi / 4 && lambda > 0.175 * pi) {
    x2 = (h2 + r * sqrt3(a2 * (1 + r2) - h2 * h2)) / (1 + r2);
    if (lambda > pi / 4)
      return [x2, x2];
    var x12 = x2, x02 = 0.5 * x2;
    x2 = 0.5 * (x02 + x12), i = 50;
    do {
      var g = sqrt3(a2 - x2 * x2), f = x2 * (zeta + mu * g) + nu * asin(x2 / a) - lambda1;
      if (!f)
        break;
      if (f < 0)
        x02 = x2;
      else
        x12 = x2;
      x2 = 0.5 * (x02 + x12);
    } while (abs(x12 - x02) > epsilon2 && --i > 0);
  } else {
    x2 = epsilon2, i = 25;
    do {
      var x22 = x2 * x2, g2 = sqrt3(a2 - x22), zetaMug = zeta + mu * g2, f2 = x2 * zetaMug + nu * asin(x2 / a) - lambda1, df = zetaMug + (nu - mu * x22) / g2;
      x2 -= delta = g2 ? f2 / df : 0;
    } while (abs(delta) > epsilon2 && --i > 0);
  }
  return [x2, -h2 - r * sqrt3(a2 - x2 * x2)];
}
function gringortenHexadecantInvert(x2, y2) {
  var x02 = 0, x12 = 1, r = 0.5, i = 50;
  while (true) {
    var r2 = r * r, sinPhi = sqrt3(r), z = asin(1 / sqrt3(1 + r2)), v = 1 - r2 + r * (1 + r2) * z, p2 = (1 - sinPhi) / v, p = sqrt3(p2), a2 = p2 * (1 + r2), h2 = p * (1 - r2), g2 = a2 - x2 * x2, g = sqrt3(g2), y02 = y2 + h2 + r * g;
    if (abs(x12 - x02) < epsilon22 || --i === 0 || y02 === 0)
      break;
    if (y02 > 0)
      x02 = r;
    else
      x12 = r;
    r = 0.5 * (x02 + x12);
  }
  if (!i)
    return null;
  var phi = asin(sinPhi), cosPhi = cos(phi), secPhi = 1 / cosPhi, drdPhi = 2 * sinPhi * cosPhi, dvdPhi = (-3 * r + z * (1 + 3 * r2)) * drdPhi, dp2dPhi = (-v * cosPhi - (1 - sinPhi) * dvdPhi) / (v * v), dpdPhi = 0.5 * dp2dPhi / p, dhdPhi = (1 - r2) * dpdPhi - 2 * r * p * drdPhi, zeta = -2 * secPhi * dhdPhi, mu = -secPhi * drdPhi, nu = -secPhi * (r * (1 + r2) * dp2dPhi + p2 * (1 + 3 * r2) * drdPhi);
  return [pi / 4 * (x2 * (zeta + mu * g) + nu * asin(x2 / sqrt3(a2))), phi];
}

// node_modules/d3-geo-projection/src/elliptic.js
function ellipticJi(u, v, m) {
  var a, b2, c;
  if (!u) {
    b2 = ellipticJ(v, 1 - m);
    return [
      [0, b2[0] / b2[1]],
      [1 / b2[1], 0],
      [b2[2] / b2[1], 0]
    ];
  }
  a = ellipticJ(u, m);
  if (!v)
    return [[a[0], 0], [a[1], 0], [a[2], 0]];
  b2 = ellipticJ(v, 1 - m);
  c = b2[1] * b2[1] + m * a[0] * a[0] * b2[0] * b2[0];
  return [
    [a[0] * b2[2] / c, a[1] * a[2] * b2[0] * b2[1] / c],
    [a[1] * b2[1] / c, -a[0] * a[2] * b2[0] * b2[2] / c],
    [a[2] * b2[1] * b2[2] / c, -m * a[0] * a[1] * b2[0] / c]
  ];
}
function ellipticJ(u, m) {
  var ai, b2, phi, t, twon;
  if (m < epsilon2) {
    t = sin(u);
    b2 = cos(u);
    ai = m * (u - t * b2) / 4;
    return [
      t - ai * b2,
      b2 + ai * t,
      1 - m * t * t / 2,
      u - ai
    ];
  }
  if (m >= 1 - epsilon2) {
    ai = (1 - m) / 4;
    b2 = cosh(u);
    t = tanh(u);
    phi = 1 / b2;
    twon = b2 * sinh(u);
    return [
      t + ai * (twon - u) / (b2 * b2),
      phi - ai * t * phi * (twon - u),
      phi + ai * t * phi * (twon + u),
      2 * atan(exp3(u)) - halfPi + ai * (twon - u) / b2
    ];
  }
  var a = [1, 0, 0, 0, 0, 0, 0, 0, 0], c = [sqrt3(m), 0, 0, 0, 0, 0, 0, 0, 0], i = 0;
  b2 = sqrt3(1 - m);
  twon = 1;
  while (abs(c[i] / a[i]) > epsilon2 && i < 8) {
    ai = a[i++];
    c[i] = (ai - b2) / 2;
    a[i] = (ai + b2) / 2;
    b2 = sqrt3(ai * b2);
    twon *= 2;
  }
  phi = twon * a[i] * u;
  do {
    t = c[i] * sin(b2 = phi) / a[i];
    phi = (asin(t) + phi) / 2;
  } while (--i);
  return [sin(phi), t = cos(phi), t / cos(phi - b2), phi];
}
function ellipticFi(phi, psi, m) {
  var r = abs(phi), i = abs(psi), sinhPsi = sinh(i);
  if (r) {
    var cscPhi = 1 / sin(r), cotPhi2 = 1 / (tan(r) * tan(r)), b2 = -(cotPhi2 + m * (sinhPsi * sinhPsi * cscPhi * cscPhi) - 1 + m), c = (m - 1) * cotPhi2, cotLambda2 = (-b2 + sqrt3(b2 * b2 - 4 * c)) / 2;
    return [
      ellipticF(atan(1 / sqrt3(cotLambda2)), m) * sign(phi),
      ellipticF(atan(sqrt3((cotLambda2 / cotPhi2 - 1) / m)), 1 - m) * sign(psi)
    ];
  }
  return [
    0,
    ellipticF(atan(sinhPsi), 1 - m) * sign(psi)
  ];
}
function ellipticF(phi, m) {
  if (!m)
    return phi;
  if (m === 1)
    return log4(tan(phi / 2 + quarterPi));
  var a = 1, b2 = sqrt3(1 - m), c = sqrt3(m);
  for (var i = 0; abs(c) > epsilon2; i++) {
    if (phi % pi) {
      var dPhi = atan(b2 * tan(phi) / a);
      if (dPhi < 0)
        dPhi += pi;
      phi += dPhi + ~~(phi / pi) * pi;
    } else
      phi += phi;
    c = (a + b2) / 2;
    b2 = sqrt3(a * b2);
    c = ((a = c) - b2) / 2;
  }
  return phi / (pow4(2, i) * a);
}

// node_modules/d3-geo-projection/src/guyou.js
function guyouRaw(lambda, phi) {
  var k_ = (sqrt2 - 1) / (sqrt2 + 1), k2 = sqrt3(1 - k_ * k_), K3 = ellipticF(halfPi, k2 * k2), f = -1, psi = log4(tan(pi / 4 + abs(phi) / 2)), r = exp3(f * psi) / sqrt3(k_), at = guyouComplexAtan(r * cos(f * lambda), r * sin(f * lambda)), t = ellipticFi(at[0], at[1], k2 * k2);
  return [-t[1], (phi >= 0 ? 1 : -1) * (0.5 * K3 - t[0])];
}
function guyouComplexAtan(x2, y2) {
  var x22 = x2 * x2, y_1 = y2 + 1, t = 1 - x22 - y2 * y2;
  return [
    0.5 * ((x2 >= 0 ? halfPi : -halfPi) - atan2(t, 2 * x2)),
    -0.25 * log4(t * t + 4 * x22) + 0.5 * log4(y_1 * y_1 + x22)
  ];
}
function guyouComplexDivide(a, b2) {
  var denominator = b2[0] * b2[0] + b2[1] * b2[1];
  return [
    (a[0] * b2[0] + a[1] * b2[1]) / denominator,
    (a[1] * b2[0] - a[0] * b2[1]) / denominator
  ];
}
guyouRaw.invert = function(x2, y2) {
  var k_ = (sqrt2 - 1) / (sqrt2 + 1), k2 = sqrt3(1 - k_ * k_), K3 = ellipticF(halfPi, k2 * k2), f = -1, j = ellipticJi(0.5 * K3 - y2, -x2, k2 * k2), tn = guyouComplexDivide(j[0], j[1]), lambda = atan2(tn[1], tn[0]) / f;
  return [
    lambda,
    2 * atan(exp3(0.5 / f * log4(k_ * tn[0] * tn[0] + k_ * tn[1] * tn[1]))) - halfPi
  ];
};

// node_modules/d3-geo-projection/src/healpix.js
var K = 3;
var healpixParallel = asin(1 - 1 / K) * degrees;
var healpixLambert = cylindricalEqualAreaRaw(0);

// node_modules/d3-geo-projection/src/sinuMollweide.js
var sinuMollweidePhi = 0.7109889596207567;
var sinuMollweideY = 0.0528035274542;
function sinuMollweideRaw(lambda, phi) {
  return phi > -sinuMollweidePhi ? (lambda = mollweideRaw(lambda, phi), lambda[1] += sinuMollweideY, lambda) : sinusoidalRaw(lambda, phi);
}
sinuMollweideRaw.invert = function(x2, y2) {
  return y2 > -sinuMollweidePhi ? mollweideRaw.invert(x2, y2 - sinuMollweideY) : sinusoidalRaw.invert(x2, y2);
};

// node_modules/d3-geo-projection/src/homolosine.js
function homolosineRaw(lambda, phi) {
  return abs(phi) > sinuMollweidePhi ? (lambda = mollweideRaw(lambda, phi), lambda[1] -= phi > 0 ? sinuMollweideY : -sinuMollweideY, lambda) : sinusoidalRaw(lambda, phi);
}
homolosineRaw.invert = function(x2, y2) {
  return abs(y2) > sinuMollweidePhi ? mollweideRaw.invert(x2, y2 + (y2 > 0 ? sinuMollweideY : -sinuMollweideY)) : sinusoidalRaw.invert(x2, y2);
};

// node_modules/d3-geo-projection/src/kavrayskiy7.js
function kavrayskiy7Raw(lambda, phi) {
  return [3 / tau * lambda * sqrt3(pi * pi / 3 - phi * phi), phi];
}
kavrayskiy7Raw.invert = function(x2, y2) {
  return [tau / 3 * x2 / sqrt3(pi * pi / 3 - y2 * y2), y2];
};

// node_modules/d3-geo-projection/src/larrivee.js
var pi_sqrt2 = pi / sqrt2;
function larriveeRaw(lambda, phi) {
  return [
    lambda * (1 + sqrt3(cos(phi))) / 2,
    phi / (cos(phi / 2) * cos(lambda / 6))
  ];
}
larriveeRaw.invert = function(x2, y2) {
  var x02 = abs(x2), y02 = abs(y2), lambda = epsilon2, phi = halfPi;
  if (y02 < pi_sqrt2)
    phi *= y02 / pi_sqrt2;
  else
    lambda += 6 * acos(pi_sqrt2 / y02);
  for (var i = 0; i < 25; i++) {
    var sinPhi = sin(phi), sqrtcosPhi = sqrt3(cos(phi)), sinPhi_2 = sin(phi / 2), cosPhi_2 = cos(phi / 2), sinLambda_6 = sin(lambda / 6), cosLambda_6 = cos(lambda / 6), f0 = 0.5 * lambda * (1 + sqrtcosPhi) - x02, f1 = phi / (cosPhi_2 * cosLambda_6) - y02, df0dPhi = sqrtcosPhi ? -0.25 * lambda * sinPhi / sqrtcosPhi : 0, df0dLambda = 0.5 * (1 + sqrtcosPhi), df1dPhi = (1 + 0.5 * phi * sinPhi_2 / cosPhi_2) / (cosPhi_2 * cosLambda_6), df1dLambda = phi / cosPhi_2 * (sinLambda_6 / 6) / (cosLambda_6 * cosLambda_6), denom = df0dPhi * df1dLambda - df1dPhi * df0dLambda, dPhi = (f0 * df1dLambda - f1 * df0dLambda) / denom, dLambda = (f1 * df0dPhi - f0 * df1dPhi) / denom;
    phi -= dPhi;
    lambda -= dLambda;
    if (abs(dPhi) < epsilon2 && abs(dLambda) < epsilon2)
      break;
  }
  return [x2 < 0 ? -lambda : lambda, y2 < 0 ? -phi : phi];
};

// node_modules/d3-geo-projection/src/laskowski.js
function laskowskiRaw(lambda, phi) {
  var lambda2 = lambda * lambda, phi2 = phi * phi;
  return [
    lambda * (0.975534 + phi2 * (-0.119161 + lambda2 * -0.0143059 + phi2 * -0.0547009)),
    phi * (1.00384 + lambda2 * (0.0802894 + phi2 * -0.02855 + lambda2 * 199025e-9) + phi2 * (0.0998909 + phi2 * -0.0491032))
  ];
}
laskowskiRaw.invert = function(x2, y2) {
  var lambda = sign(x2) * pi, phi = y2 / 2, i = 50;
  do {
    var lambda2 = lambda * lambda, phi2 = phi * phi, lambdaPhi = lambda * phi, fx = lambda * (0.975534 + phi2 * (-0.119161 + lambda2 * -0.0143059 + phi2 * -0.0547009)) - x2, fy = phi * (1.00384 + lambda2 * (0.0802894 + phi2 * -0.02855 + lambda2 * 199025e-9) + phi2 * (0.0998909 + phi2 * -0.0491032)) - y2, deltaxDeltaLambda = 0.975534 - phi2 * (0.119161 + 3 * lambda2 * 0.0143059 + phi2 * 0.0547009), deltaxDeltaPhi = -lambdaPhi * (2 * 0.119161 + 4 * 0.0547009 * phi2 + 2 * 0.0143059 * lambda2), deltayDeltaLambda = lambdaPhi * (2 * 0.0802894 + 4 * 199025e-9 * lambda2 + 2 * -0.02855 * phi2), deltayDeltaPhi = 1.00384 + lambda2 * (0.0802894 + 199025e-9 * lambda2) + phi2 * (3 * (0.0998909 - 0.02855 * lambda2) - 5 * 0.0491032 * phi2), denominator = deltaxDeltaPhi * deltayDeltaLambda - deltayDeltaPhi * deltaxDeltaLambda, deltaLambda = (fy * deltaxDeltaPhi - fx * deltayDeltaPhi) / denominator, deltaPhi = (fx * deltayDeltaLambda - fy * deltaxDeltaLambda) / denominator;
    lambda -= deltaLambda, phi -= deltaPhi;
  } while ((abs(deltaLambda) > epsilon2 || abs(deltaPhi) > epsilon2) && --i > 0);
  return i && [lambda, phi];
};

// node_modules/d3-geo-projection/src/littrow.js
function littrowRaw(lambda, phi) {
  return [
    sin(lambda) / cos(phi),
    tan(phi) * cos(lambda)
  ];
}
littrowRaw.invert = function(x2, y2) {
  var x22 = x2 * x2, y22 = y2 * y2, y2_1 = y22 + 1, x2_y2_1 = x22 + y2_1, cosPhi = x2 ? sqrt1_2 * sqrt3((x2_y2_1 - sqrt3(x2_y2_1 * x2_y2_1 - 4 * x22)) / x22) : 1 / sqrt3(y2_1);
  return [
    asin(x2 * cosPhi),
    sign(y2) * acos(cosPhi)
  ];
};

// node_modules/d3-geo-projection/src/miller.js
function millerRaw(lambda, phi) {
  return [lambda, 1.25 * log4(tan(quarterPi + 0.4 * phi))];
}
millerRaw.invert = function(x2, y2) {
  return [x2, 2.5 * atan(exp3(0.8 * y2)) - 0.625 * pi];
};

// node_modules/d3-geo-projection/src/mtFlatPolarParabolic.js
var sqrt6 = sqrt3(6);
var sqrt7 = sqrt3(7);
function mtFlatPolarParabolicRaw(lambda, phi) {
  var theta = asin(7 * sin(phi) / (3 * sqrt6));
  return [
    sqrt6 * lambda * (2 * cos(2 * theta / 3) - 1) / sqrt7,
    9 * sin(theta / 3) / sqrt7
  ];
}
mtFlatPolarParabolicRaw.invert = function(x2, y2) {
  var theta = 3 * asin(y2 * sqrt7 / 9);
  return [
    x2 * sqrt7 / (sqrt6 * (2 * cos(2 * theta / 3) - 1)),
    asin(sin(theta) * 3 * sqrt6 / 7)
  ];
};

// node_modules/d3-geo-projection/src/mtFlatPolarQuartic.js
function mtFlatPolarQuarticRaw(lambda, phi) {
  var k2 = (1 + sqrt1_2) * sin(phi), theta = phi;
  for (var i = 0, delta; i < 25; i++) {
    theta -= delta = (sin(theta / 2) + sin(theta) - k2) / (0.5 * cos(theta / 2) + cos(theta));
    if (abs(delta) < epsilon2)
      break;
  }
  return [
    lambda * (1 + 2 * cos(theta) / cos(theta / 2)) / (3 * sqrt2),
    2 * sqrt3(3) * sin(theta / 2) / sqrt3(2 + sqrt2)
  ];
}
mtFlatPolarQuarticRaw.invert = function(x2, y2) {
  var sinTheta_2 = y2 * sqrt3(2 + sqrt2) / (2 * sqrt3(3)), theta = 2 * asin(sinTheta_2);
  return [
    3 * sqrt2 * x2 / (1 + 2 * cos(theta) / cos(theta / 2)),
    asin((sinTheta_2 + sin(theta)) / (1 + sqrt1_2))
  ];
};

// node_modules/d3-geo-projection/src/mtFlatPolarSinusoidal.js
function mtFlatPolarSinusoidalRaw(lambda, phi) {
  var A2 = sqrt3(6 / (4 + pi)), k2 = (1 + pi / 4) * sin(phi), theta = phi / 2;
  for (var i = 0, delta; i < 25; i++) {
    theta -= delta = (theta / 2 + sin(theta) - k2) / (0.5 + cos(theta));
    if (abs(delta) < epsilon2)
      break;
  }
  return [
    A2 * (0.5 + cos(theta)) * lambda / 1.5,
    A2 * theta
  ];
}
mtFlatPolarSinusoidalRaw.invert = function(x2, y2) {
  var A2 = sqrt3(6 / (4 + pi)), theta = y2 / A2;
  if (abs(abs(theta) - halfPi) < epsilon2)
    theta = theta < 0 ? -halfPi : halfPi;
  return [
    1.5 * x2 / (A2 * (0.5 + cos(theta))),
    asin((theta / 2 + sin(theta)) / (1 + pi / 4))
  ];
};

// node_modules/d3-geo-projection/src/naturalEarth2.js
function naturalEarth2Raw(lambda, phi) {
  var phi2 = phi * phi, phi4 = phi2 * phi2, phi6 = phi2 * phi4;
  return [
    lambda * (0.84719 - 0.13063 * phi2 + phi6 * phi6 * (-0.04515 + 0.05494 * phi2 - 0.02326 * phi4 + 331e-5 * phi6)),
    phi * (1.01183 + phi4 * phi4 * (-0.02625 + 0.01926 * phi2 - 396e-5 * phi4))
  ];
}
naturalEarth2Raw.invert = function(x2, y2) {
  var phi = y2, i = 25, delta, phi2, phi4, phi6;
  do {
    phi2 = phi * phi;
    phi4 = phi2 * phi2;
    phi -= delta = (phi * (1.01183 + phi4 * phi4 * (-0.02625 + 0.01926 * phi2 - 396e-5 * phi4)) - y2) / (1.01183 + phi4 * phi4 * (9 * -0.02625 + 11 * 0.01926 * phi2 + 13 * -396e-5 * phi4));
  } while (abs(delta) > epsilon22 && --i > 0);
  phi2 = phi * phi;
  phi4 = phi2 * phi2;
  phi6 = phi2 * phi4;
  return [
    x2 / (0.84719 - 0.13063 * phi2 + phi6 * phi6 * (-0.04515 + 0.05494 * phi2 - 0.02326 * phi4 + 331e-5 * phi6)),
    phi
  ];
};

// node_modules/d3-geo-projection/src/nellHammer.js
function nellHammerRaw(lambda, phi) {
  return [
    lambda * (1 + cos(phi)) / 2,
    2 * (phi - tan(phi / 2))
  ];
}
nellHammerRaw.invert = function(x2, y2) {
  var p = y2 / 2;
  for (var i = 0, delta = Infinity; i < 10 && abs(delta) > epsilon2; ++i) {
    var c = cos(y2 / 2);
    y2 -= delta = (y2 - tan(y2 / 2) - p) / (1 - 0.5 / (c * c));
  }
  return [
    2 * x2 / (1 + cos(y2)),
    y2
  ];
};

// node_modules/d3-geo-projection/src/nicolosi.js
function nicolosiRaw(lambda, phi) {
  var sinPhi = sin(phi), q = cos(phi), s = sign(lambda);
  if (lambda === 0 || abs(phi) === halfPi)
    return [0, phi];
  else if (phi === 0)
    return [lambda, 0];
  else if (abs(lambda) === halfPi)
    return [lambda * q, halfPi * sinPhi];
  var b2 = pi / (2 * lambda) - 2 * lambda / pi, c = 2 * phi / pi, d = (1 - c * c) / (sinPhi - c);
  var b22 = b2 * b2, d2 = d * d, b2d2 = 1 + b22 / d2, d2b2 = 1 + d2 / b22;
  var M = (b2 * sinPhi / d - b2 / 2) / b2d2, N = (d2 * sinPhi / b22 + d / 2) / d2b2, m = M * M + q * q / b2d2, n = N * N - (d2 * sinPhi * sinPhi / b22 + d * sinPhi - 1) / d2b2;
  return [
    halfPi * (M + sqrt3(m) * s),
    halfPi * (N + sqrt3(n < 0 ? 0 : n) * sign(-phi * b2) * s)
  ];
}
nicolosiRaw.invert = function(x2, y2) {
  x2 /= halfPi;
  y2 /= halfPi;
  var x22 = x2 * x2, y22 = y2 * y2, x2y2 = x22 + y22, pi2 = pi * pi;
  return [
    x2 ? (x2y2 - 1 + sqrt3((1 - x2y2) * (1 - x2y2) + 4 * x22)) / (2 * x2) * halfPi : 0,
    solve(function(phi) {
      return x2y2 * (pi * sin(phi) - 2 * phi) * pi + 4 * phi * phi * (y2 - sin(phi)) + 2 * pi * phi - pi2 * y2;
    }, 0)
  ];
};

// node_modules/d3-geo-projection/src/patterson.js
var pattersonK1 = 1.0148;
var pattersonK2 = 0.23185;
var pattersonK3 = -0.14499;
var pattersonK4 = 0.02406;
var pattersonC1 = pattersonK1;
var pattersonC2 = 5 * pattersonK2;
var pattersonC3 = 7 * pattersonK3;
var pattersonC4 = 9 * pattersonK4;
var pattersonYmax = 1.790857183;
function pattersonRaw(lambda, phi) {
  var phi2 = phi * phi;
  return [
    lambda,
    phi * (pattersonK1 + phi2 * phi2 * (pattersonK2 + phi2 * (pattersonK3 + pattersonK4 * phi2)))
  ];
}
pattersonRaw.invert = function(x2, y2) {
  if (y2 > pattersonYmax)
    y2 = pattersonYmax;
  else if (y2 < -pattersonYmax)
    y2 = -pattersonYmax;
  var yc = y2, delta;
  do {
    var y22 = yc * yc;
    yc -= delta = (yc * (pattersonK1 + y22 * y22 * (pattersonK2 + y22 * (pattersonK3 + pattersonK4 * y22))) - y2) / (pattersonC1 + y22 * y22 * (pattersonC2 + y22 * (pattersonC3 + pattersonC4 * y22)));
  } while (abs(delta) > epsilon2);
  return [x2, yc];
};

// node_modules/d3-geo-projection/src/polyconic.js
function polyconicRaw(lambda, phi) {
  if (abs(phi) < epsilon2)
    return [lambda, 0];
  var tanPhi = tan(phi), k2 = lambda * sin(phi);
  return [
    sin(k2) / tanPhi,
    phi + (1 - cos(k2)) / tanPhi
  ];
}
polyconicRaw.invert = function(x2, y2) {
  if (abs(y2) < epsilon2)
    return [x2, 0];
  var k2 = x2 * x2 + y2 * y2, phi = y2 * 0.5, i = 10, delta;
  do {
    var tanPhi = tan(phi), secPhi = 1 / cos(phi), j = k2 - 2 * y2 * phi + phi * phi;
    phi -= delta = (tanPhi * j + 2 * (phi - y2)) / (2 + j * secPhi * secPhi + 2 * (phi - y2) * tanPhi);
  } while (abs(delta) > epsilon2 && --i > 0);
  tanPhi = tan(phi);
  return [
    (abs(y2) < abs(phi + 1 / tanPhi) ? asin(x2 * tanPhi) : sign(y2) * sign(x2) * (acos(abs(x2 * tanPhi)) + halfPi)) / sin(phi),
    phi
  ];
};

// node_modules/d3-geo-projection/src/polyhedral/octahedron.js
var octahedron = [
  [0, 90],
  [-90, 0],
  [0, 0],
  [90, 0],
  [180, 0],
  [0, -90]
];
var octahedron_default = [
  [0, 2, 1],
  [0, 3, 2],
  [5, 1, 2],
  [5, 2, 3],
  [0, 1, 4],
  [0, 4, 3],
  [5, 4, 1],
  [5, 3, 4]
].map(function(face) {
  return face.map(function(i) {
    return octahedron[i];
  });
});

// node_modules/d3-geo-projection/src/polyhedral/collignon.js
var kx = 2 / sqrt3(3);
function collignonK(a, b2) {
  var p = collignonRaw(a, b2);
  return [p[0] * kx, p[1]];
}
collignonK.invert = function(x2, y2) {
  return collignonRaw.invert(x2 / kx, y2);
};

// node_modules/d3-geo-projection/src/robinson.js
var K2 = [
  [0.9986, -0.062],
  [1, 0],
  [0.9986, 0.062],
  [0.9954, 0.124],
  [0.99, 0.186],
  [0.9822, 0.248],
  [0.973, 0.31],
  [0.96, 0.372],
  [0.9427, 0.434],
  [0.9216, 0.4958],
  [0.8962, 0.5571],
  [0.8679, 0.6176],
  [0.835, 0.6769],
  [0.7986, 0.7346],
  [0.7597, 0.7903],
  [0.7186, 0.8435],
  [0.6732, 0.8936],
  [0.6213, 0.9394],
  [0.5722, 0.9761],
  [0.5322, 1]
];
K2.forEach(function(d) {
  d[1] *= 1.593415793900743;
});
function robinsonRaw(lambda, phi) {
  var i = min3(18, abs(phi) * 36 / pi), i0 = floor2(i), di = i - i0, ax = (k2 = K2[i0])[0], ay = k2[1], bx = (k2 = K2[++i0])[0], by = k2[1], cx = (k2 = K2[min3(19, ++i0)])[0], cy = k2[1], k2;
  return [
    lambda * (bx + di * (cx - ax) / 2 + di * di * (cx - 2 * bx + ax) / 2),
    sign(phi) * (by + di * (cy - ay) / 2 + di * di * (cy - 2 * by + ay) / 2)
  ];
}
robinsonRaw.invert = function(x2, y2) {
  var phi = y2 * 90, i = min3(18, abs(phi / 5)), i0 = max3(0, floor2(i));
  do {
    var ay = K2[i0][1], by = K2[i0 + 1][1], cy = K2[min3(19, i0 + 2)][1], u = cy - ay, v = cy - 2 * by + ay, t = 2 * (abs(y2) - by) / u, c = v / u, di = t * (1 - c * t * (1 - 2 * c * t));
    if (di >= 0 || i0 === 1) {
      phi = (y2 >= 0 ? 5 : -5) * (di + i);
      var j = 50, delta;
      do {
        i = min3(18, abs(phi) / 5);
        i0 = floor2(i);
        di = i - i0;
        ay = K2[i0][1];
        by = K2[i0 + 1][1];
        cy = K2[min3(19, i0 + 2)][1];
        phi -= (delta = sign(y2) * (by + di * (cy - ay) / 2 + di * di * (cy - 2 * by + ay) / 2) - y2) * degrees;
      } while (abs(delta) > epsilon22 && --j > 0);
      break;
    }
  } while (--i0 >= 0);
  var ax = K2[i0][0], bx = K2[i0 + 1][0], cx = K2[min3(19, i0 + 2)][0];
  return [
    x2 / (bx + di * (cx - ax) / 2 + di * di * (cx - 2 * bx + ax) / 2),
    phi * radians
  ];
};

// node_modules/d3-geo-projection/src/stitch.js
var epsilon3 = 1e-4;
var x0 = -180;
var x0e = x0 + epsilon3;
var x1 = 180;
var x1e = x1 - epsilon3;
var y0 = -90;
var y0e = y0 + epsilon3;
var y1 = 90;
var y1e = y1 - epsilon3;

// node_modules/d3-geo-projection/src/times.js
function timesRaw(lambda, phi) {
  var t = tan(phi / 2), s = sin(quarterPi * t);
  return [
    lambda * (0.74482 - 0.34588 * s * s),
    1.70711 * t
  ];
}
timesRaw.invert = function(x2, y2) {
  var t = y2 / 1.70711, s = sin(quarterPi * t);
  return [
    x2 / (0.74482 - 0.34588 * s * s),
    2 * atan(t)
  ];
};

// node_modules/d3-geo-projection/src/vanDerGrinten.js
function vanDerGrintenRaw(lambda, phi) {
  if (abs(phi) < epsilon2)
    return [lambda, 0];
  var sinTheta = abs(phi / halfPi), theta = asin(sinTheta);
  if (abs(lambda) < epsilon2 || abs(abs(phi) - halfPi) < epsilon2)
    return [0, sign(phi) * pi * tan(theta / 2)];
  var cosTheta = cos(theta), A2 = abs(pi / lambda - lambda / pi) / 2, A22 = A2 * A2, G = cosTheta / (sinTheta + cosTheta - 1), P = G * (2 / sinTheta - 1), P2 = P * P, P2_A2 = P2 + A22, G_P2 = G - P2, Q = A22 + G;
  return [
    sign(lambda) * pi * (A2 * G_P2 + sqrt3(A22 * G_P2 * G_P2 - P2_A2 * (G * G - P2))) / P2_A2,
    sign(phi) * pi * (P * Q - A2 * sqrt3((A22 + 1) * P2_A2 - Q * Q)) / P2_A2
  ];
}
vanDerGrintenRaw.invert = function(x2, y2) {
  if (abs(y2) < epsilon2)
    return [x2, 0];
  if (abs(x2) < epsilon2)
    return [0, halfPi * sin(2 * atan(y2 / pi))];
  var x22 = (x2 /= pi) * x2, y22 = (y2 /= pi) * y2, x2_y2 = x22 + y22, z = x2_y2 * x2_y2, c1 = -abs(y2) * (1 + x2_y2), c2 = c1 - 2 * y22 + x22, c3 = -2 * c1 + 1 + 2 * y22 + z, d = y22 / c3 + (2 * c2 * c2 * c2 / (c3 * c3 * c3) - 9 * c1 * c2 / (c3 * c3)) / 27, a1 = (c1 - c2 * c2 / (3 * c3)) / c3, m1 = 2 * sqrt3(-a1 / 3), theta1 = acos(3 * d / (a1 * m1)) / 3;
  return [
    pi * (x2_y2 - 1 + sqrt3(1 + 2 * (x22 - y22) + z)) / (2 * x2),
    sign(y2) * pi * (-m1 * cos(theta1 + pi / 3) - c2 / (3 * c3))
  ];
};

// node_modules/d3-geo-projection/src/vanDerGrinten2.js
function vanDerGrinten2Raw(lambda, phi) {
  if (abs(phi) < epsilon2)
    return [lambda, 0];
  var sinTheta = abs(phi / halfPi), theta = asin(sinTheta);
  if (abs(lambda) < epsilon2 || abs(abs(phi) - halfPi) < epsilon2)
    return [0, sign(phi) * pi * tan(theta / 2)];
  var cosTheta = cos(theta), A2 = abs(pi / lambda - lambda / pi) / 2, A22 = A2 * A2, x12 = cosTheta * (sqrt3(1 + A22) - A2 * cosTheta) / (1 + A22 * sinTheta * sinTheta);
  return [
    sign(lambda) * pi * x12,
    sign(phi) * pi * sqrt3(1 - x12 * (2 * A2 + x12))
  ];
}
vanDerGrinten2Raw.invert = function(x2, y2) {
  if (!x2)
    return [0, halfPi * sin(2 * atan(y2 / pi))];
  var x12 = abs(x2 / pi), A2 = (1 - x12 * x12 - (y2 /= pi) * y2) / (2 * x12), A22 = A2 * A2, B2 = sqrt3(A22 + 1);
  return [
    sign(x2) * pi * (B2 - A2),
    sign(y2) * halfPi * sin(2 * atan2(sqrt3((1 - 2 * A2 * x12) * (A2 + B2) - x12), sqrt3(B2 + A2 + x12)))
  ];
};

// node_modules/d3-geo-projection/src/vanDerGrinten3.js
function vanDerGrinten3Raw(lambda, phi) {
  if (abs(phi) < epsilon2)
    return [lambda, 0];
  var sinTheta = phi / halfPi, theta = asin(sinTheta);
  if (abs(lambda) < epsilon2 || abs(abs(phi) - halfPi) < epsilon2)
    return [0, pi * tan(theta / 2)];
  var A2 = (pi / lambda - lambda / pi) / 2, y12 = sinTheta / (1 + cos(theta));
  return [
    pi * (sign(lambda) * sqrt3(A2 * A2 + 1 - y12 * y12) - A2),
    pi * y12
  ];
}
vanDerGrinten3Raw.invert = function(x2, y2) {
  if (!y2)
    return [x2, 0];
  var y12 = y2 / pi, A2 = (pi * pi * (1 - y12 * y12) - x2 * x2) / (2 * pi * x2);
  return [
    x2 ? pi * (sign(x2) * sqrt3(A2 * A2 + 1) - A2) : 0,
    halfPi * sin(2 * atan(y12))
  ];
};

// node_modules/d3-geo-projection/src/vanDerGrinten4.js
function vanDerGrinten4Raw(lambda, phi) {
  if (!phi)
    return [lambda, 0];
  var phi02 = abs(phi);
  if (!lambda || phi02 === halfPi)
    return [0, phi];
  var B2 = phi02 / halfPi, B22 = B2 * B2, C2 = (8 * B2 - B22 * (B22 + 2) - 5) / (2 * B22 * (B2 - 1)), C22 = C2 * C2, BC = B2 * C2, B_C2 = B22 + C22 + 2 * BC, B_3C = B2 + 3 * C2, lambda0 = lambda / halfPi, lambda1 = lambda0 + 1 / lambda0, D = sign(abs(lambda) - halfPi) * sqrt3(lambda1 * lambda1 - 4), D2 = D * D, F = B_C2 * (B22 + C22 * D2 - 1) + (1 - B22) * (B22 * (B_3C * B_3C + 4 * C22) + 12 * BC * C22 + 4 * C22 * C22), x12 = (D * (B_C2 + C22 - 1) + 2 * sqrt3(F)) / (4 * B_C2 + D2);
  return [
    sign(lambda) * halfPi * x12,
    sign(phi) * halfPi * sqrt3(1 + D * abs(x12) - x12 * x12)
  ];
}
vanDerGrinten4Raw.invert = function(x2, y2) {
  var delta;
  if (!x2 || !y2)
    return [x2, y2];
  var sy = sign(y2);
  y2 = abs(y2) / pi;
  var x12 = sign(x2) * x2 / halfPi, D = (x12 * x12 - 1 + 4 * y2 * y2) / abs(x12), D2 = D * D, B2 = y2 * (2 - (y2 > 0.5 ? min3(y2, abs(x2)) : 0)), r = x2 * x2 + y2 * y2, i = 50;
  do {
    var B22 = B2 * B2, C2 = (8 * B2 - B22 * (B22 + 2) - 5) / (2 * B22 * (B2 - 1)), C_ = (3 * B2 - B22 * B2 - 10) / (2 * B22 * B2), C22 = C2 * C2, BC = B2 * C2, B_C = B2 + C2, B_C2 = B_C * B_C, B_3C = B2 + 3 * C2, F = B_C2 * (B22 + C22 * D2 - 1) + (1 - B22) * (B22 * (B_3C * B_3C + 4 * C22) + C22 * (12 * BC + 4 * C22)), F_ = -2 * B_C * (4 * BC * C22 + (1 - 4 * B22 + 3 * B22 * B22) * (1 + C_) + C22 * (-6 + 14 * B22 - D2 + (-8 + 8 * B22 - 2 * D2) * C_) + BC * (-8 + 12 * B22 + (-10 + 10 * B22 - D2) * C_)), sqrtF = sqrt3(F), f = D * (B_C2 + C22 - 1) + 2 * sqrtF - x12 * (4 * B_C2 + D2), f_ = D * (2 * C2 * C_ + 2 * B_C * (1 + C_)) + F_ / sqrtF - 8 * B_C * (D * (-1 + C22 + B_C2) + 2 * sqrtF) * (1 + C_) / (D2 + 4 * B_C2);
    B2 -= delta = f / f_;
  } while (delta * r * r > epsilon2 && --i > 0);
  return [
    sign(x2) * (sqrt3(D * D + 4) + D) * pi / 4,
    sy * halfPi * B2
  ];
};

// node_modules/d3-geo-projection/src/wagner4.js
var A = 4 * pi + 3 * sqrt3(3);
var B = 2 * sqrt3(2 * pi * sqrt3(3) / A);
var wagner4Raw = mollweideBromleyRaw(B * sqrt3(3) / pi, B, A / 6);

// node_modules/d3-geo-projection/src/wagner6.js
function wagner6Raw(lambda, phi) {
  return [lambda * sqrt3(1 - 3 * phi * phi / (pi * pi)), phi];
}
wagner6Raw.invert = function(x2, y2) {
  return [x2 / sqrt3(1 - 3 * y2 * y2 / (pi * pi)), y2];
};

// node_modules/d3-geo-projection/src/wiechel.js
function wiechelRaw(lambda, phi) {
  var cosPhi = cos(phi), sinPhi = cos(lambda) * cosPhi, sin1_Phi = 1 - sinPhi, cosLambda = cos(lambda = atan2(sin(lambda) * cosPhi, -sin(phi))), sinLambda = sin(lambda);
  cosPhi = sqrt3(1 - sinPhi * sinPhi);
  return [
    sinLambda * cosPhi - cosLambda * sin1_Phi,
    -cosLambda * cosPhi - sinLambda * sin1_Phi
  ];
}
wiechelRaw.invert = function(x2, y2) {
  var w3 = (x2 * x2 + y2 * y2) / -2, k2 = sqrt3(-w3 * (2 + w3)), b2 = y2 * w3 + x2 * k2, a = x2 * w3 - y2 * k2, D = sqrt3(a * a + b2 * b2);
  return [
    atan2(k2 * b2, D * (1 + w3)),
    D ? -asin(k2 * a / D) : 0
  ];
};

// node_modules/d3-geo-projection/src/winkel3.js
function winkel3Raw(lambda, phi) {
  var coordinates = aitoffRaw(lambda, phi);
  return [
    (coordinates[0] + lambda / halfPi) / 2,
    (coordinates[1] + phi) / 2
  ];
}
winkel3Raw.invert = function(x2, y2) {
  var lambda = x2, phi = y2, i = 25;
  do {
    var cosphi = cos(phi), sinphi = sin(phi), sin_2phi = sin(2 * phi), sin2phi = sinphi * sinphi, cos2phi = cosphi * cosphi, sinlambda = sin(lambda), coslambda_2 = cos(lambda / 2), sinlambda_2 = sin(lambda / 2), sin2lambda_2 = sinlambda_2 * sinlambda_2, C2 = 1 - cos2phi * coslambda_2 * coslambda_2, E = C2 ? acos(cosphi * coslambda_2) * sqrt3(F = 1 / C2) : F = 0, F, fx = 0.5 * (2 * E * cosphi * sinlambda_2 + lambda / halfPi) - x2, fy = 0.5 * (E * sinphi + phi) - y2, dxdlambda = 0.5 * F * (cos2phi * sin2lambda_2 + E * cosphi * coslambda_2 * sin2phi) + 0.5 / halfPi, dxdphi = F * (sinlambda * sin_2phi / 4 - E * sinphi * sinlambda_2), dydlambda = 0.125 * F * (sin_2phi * sinlambda_2 - E * sinphi * cos2phi * sinlambda), dydphi = 0.5 * F * (sin2phi * coslambda_2 + E * sin2lambda_2 * cosphi) + 0.5, denominator = dxdphi * dydlambda - dydphi * dxdlambda, dlambda = (fy * dxdphi - fx * dydphi) / denominator, dphi = (fx * dydlambda - fy * dxdlambda) / denominator;
    lambda -= dlambda, phi -= dphi;
  } while ((abs(dlambda) > epsilon2 || abs(dphi) > epsilon2) && --i > 0);
  return [lambda, phi];
};

// node_modules/vega-projection/build/vega-projection.module.js
var defaultPath = path_default();
var projectionProperties = [
  // standard properties in d3-geo
  "clipAngle",
  "clipExtent",
  "scale",
  "translate",
  "center",
  "rotate",
  "parallels",
  "precision",
  "reflectX",
  "reflectY",
  // extended properties in d3-geo-projections
  "coefficient",
  "distance",
  "fraction",
  "lobes",
  "parallel",
  "radius",
  "ratio",
  "spacing",
  "tilt"
];
function create2(type2, constructor) {
  return function projection3() {
    const p = constructor();
    p.type = type2;
    p.path = path_default().projection(p);
    p.copy = p.copy || function() {
      const c = projection3();
      projectionProperties.forEach((prop) => {
        if (p[prop])
          c[prop](p[prop]());
      });
      c.path.pointRadius(p.path.pointRadius());
      return c;
    };
    return registerScale(p);
  };
}
function projection2(type2, proj) {
  if (!type2 || typeof type2 !== "string") {
    throw new Error("Projection type must be a name string.");
  }
  type2 = type2.toLowerCase();
  if (arguments.length > 1) {
    projections[type2] = create2(type2, proj);
    return this;
  } else {
    return projections[type2] || null;
  }
}
function getProjectionPath(proj) {
  return proj && proj.path || defaultPath;
}
var projections = {
  // base d3-geo projection types
  albers: albers_default,
  albersusa: albersUsa_default,
  azimuthalequalarea: azimuthalEqualArea_default,
  azimuthalequidistant: azimuthalEquidistant_default,
  conicconformal: conicConformal_default,
  conicequalarea: conicEqualArea_default,
  conicequidistant: conicEquidistant_default,
  equalEarth: equalEarth_default,
  equirectangular: equirectangular_default,
  gnomonic: gnomonic_default,
  identity: identity_default,
  mercator: mercator_default,
  mollweide: mollweide_default,
  naturalEarth1: naturalEarth1_default,
  orthographic: orthographic_default,
  stereographic: stereographic_default,
  transversemercator: transverseMercator_default
};
for (const key2 in projections) {
  projection2(key2, projections[key2]);
}

// node_modules/vega-geo/build/vega-geo.module.js
function noop2() {
}
var cases = [[], [[[1, 1.5], [0.5, 1]]], [[[1.5, 1], [1, 1.5]]], [[[1.5, 1], [0.5, 1]]], [[[1, 0.5], [1.5, 1]]], [[[1, 1.5], [0.5, 1]], [[1, 0.5], [1.5, 1]]], [[[1, 0.5], [1, 1.5]]], [[[1, 0.5], [0.5, 1]]], [[[0.5, 1], [1, 0.5]]], [[[1, 1.5], [1, 0.5]]], [[[0.5, 1], [1, 0.5]], [[1.5, 1], [1, 1.5]]], [[[1.5, 1], [1, 0.5]]], [[[0.5, 1], [1.5, 1]]], [[[1, 1.5], [1.5, 1]]], [[[0.5, 1], [1, 1.5]]], []];
function contours() {
  var dx = 1, dy = 1, smooth = smoothLinear;
  function contours2(values2, tz) {
    return tz.map((value3) => contour(values2, value3));
  }
  function contour(values2, value3) {
    var polygons = [], holes = [];
    isorings(values2, value3, (ring) => {
      smooth(ring, values2, value3);
      if (area2(ring) > 0)
        polygons.push([ring]);
      else
        holes.push(ring);
    });
    holes.forEach((hole) => {
      for (var i = 0, n = polygons.length, polygon; i < n; ++i) {
        if (contains((polygon = polygons[i])[0], hole) !== -1) {
          polygon.push(hole);
          return;
        }
      }
    });
    return {
      type: "MultiPolygon",
      value: value3,
      coordinates: polygons
    };
  }
  function isorings(values2, value3, callback) {
    var fragmentByStart = new Array(), fragmentByEnd = new Array(), x2, y2, t02, t1, t2, t3;
    x2 = y2 = -1;
    t1 = values2[0] >= value3;
    cases[t1 << 1].forEach(stitch);
    while (++x2 < dx - 1) {
      t02 = t1, t1 = values2[x2 + 1] >= value3;
      cases[t02 | t1 << 1].forEach(stitch);
    }
    cases[t1 << 0].forEach(stitch);
    while (++y2 < dy - 1) {
      x2 = -1;
      t1 = values2[y2 * dx + dx] >= value3;
      t2 = values2[y2 * dx] >= value3;
      cases[t1 << 1 | t2 << 2].forEach(stitch);
      while (++x2 < dx - 1) {
        t02 = t1, t1 = values2[y2 * dx + dx + x2 + 1] >= value3;
        t3 = t2, t2 = values2[y2 * dx + x2 + 1] >= value3;
        cases[t02 | t1 << 1 | t2 << 2 | t3 << 3].forEach(stitch);
      }
      cases[t1 | t2 << 3].forEach(stitch);
    }
    x2 = -1;
    t2 = values2[y2 * dx] >= value3;
    cases[t2 << 2].forEach(stitch);
    while (++x2 < dx - 1) {
      t3 = t2, t2 = values2[y2 * dx + x2 + 1] >= value3;
      cases[t2 << 2 | t3 << 3].forEach(stitch);
    }
    cases[t2 << 3].forEach(stitch);
    function stitch(line3) {
      var start = [line3[0][0] + x2, line3[0][1] + y2], end = [line3[1][0] + x2, line3[1][1] + y2], startIndex = index2(start), endIndex = index2(end), f, g;
      if (f = fragmentByEnd[startIndex]) {
        if (g = fragmentByStart[endIndex]) {
          delete fragmentByEnd[f.end];
          delete fragmentByStart[g.start];
          if (f === g) {
            f.ring.push(end);
            callback(f.ring);
          } else {
            fragmentByStart[f.start] = fragmentByEnd[g.end] = {
              start: f.start,
              end: g.end,
              ring: f.ring.concat(g.ring)
            };
          }
        } else {
          delete fragmentByEnd[f.end];
          f.ring.push(end);
          fragmentByEnd[f.end = endIndex] = f;
        }
      } else if (f = fragmentByStart[endIndex]) {
        if (g = fragmentByEnd[startIndex]) {
          delete fragmentByStart[f.start];
          delete fragmentByEnd[g.end];
          if (f === g) {
            f.ring.push(end);
            callback(f.ring);
          } else {
            fragmentByStart[g.start] = fragmentByEnd[f.end] = {
              start: g.start,
              end: f.end,
              ring: g.ring.concat(f.ring)
            };
          }
        } else {
          delete fragmentByStart[f.start];
          f.ring.unshift(start);
          fragmentByStart[f.start = startIndex] = f;
        }
      } else {
        fragmentByStart[startIndex] = fragmentByEnd[endIndex] = {
          start: startIndex,
          end: endIndex,
          ring: [start, end]
        };
      }
    }
  }
  function index2(point3) {
    return point3[0] * 2 + point3[1] * (dx + 1) * 4;
  }
  function smoothLinear(ring, values2, value3) {
    ring.forEach((point3) => {
      var x2 = point3[0], y2 = point3[1], xt = x2 | 0, yt = y2 | 0, v0, v1 = values2[yt * dx + xt];
      if (x2 > 0 && x2 < dx && xt === x2) {
        v0 = values2[yt * dx + xt - 1];
        point3[0] = x2 + (value3 - v0) / (v1 - v0) - 0.5;
      }
      if (y2 > 0 && y2 < dy && yt === y2) {
        v0 = values2[(yt - 1) * dx + xt];
        point3[1] = y2 + (value3 - v0) / (v1 - v0) - 0.5;
      }
    });
  }
  contours2.contour = contour;
  contours2.size = function(_) {
    if (!arguments.length)
      return [dx, dy];
    var _0 = Math.floor(_[0]), _1 = Math.floor(_[1]);
    if (!(_0 >= 0 && _1 >= 0))
      error("invalid size");
    return dx = _0, dy = _1, contours2;
  };
  contours2.smooth = function(_) {
    return arguments.length ? (smooth = _ ? smoothLinear : noop2, contours2) : smooth === smoothLinear;
  };
  return contours2;
}
function area2(ring) {
  var i = 0, n = ring.length, area3 = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];
  while (++i < n)
    area3 += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];
  return area3;
}
function contains(ring, hole) {
  var i = -1, n = hole.length, c;
  while (++i < n)
    if (c = ringContains(ring, hole[i]))
      return c;
  return 0;
}
function ringContains(ring, point3) {
  var x2 = point3[0], y2 = point3[1], contains2 = -1;
  for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {
    var pi2 = ring[i], xi = pi2[0], yi = pi2[1], pj = ring[j], xj = pj[0], yj = pj[1];
    if (segmentContains(pi2, pj, point3))
      return 0;
    if (yi > y2 !== yj > y2 && x2 < (xj - xi) * (y2 - yi) / (yj - yi) + xi)
      contains2 = -contains2;
  }
  return contains2;
}
function segmentContains(a, b2, c) {
  var i;
  return collinear(a, b2, c) && within(a[i = +(a[0] === b2[0])], c[i], b2[i]);
}
function collinear(a, b2, c) {
  return (b2[0] - a[0]) * (c[1] - a[1]) === (c[0] - a[0]) * (b2[1] - a[1]);
}
function within(p, q, r) {
  return p <= q && q <= r || r <= q && q <= p;
}
function quantize2(k2, nice, zero3) {
  return function(values2) {
    var ex = extent(values2), start = zero3 ? Math.min(ex[0], 0) : ex[0], stop2 = ex[1], span2 = stop2 - start, step = nice ? tickStep(start, stop2, k2) : span2 / (k2 + 1);
    return range(start + step, stop2, step);
  };
}
function Isocontour(params2) {
  Transform.call(this, null, params2);
}
Isocontour.Definition = {
  "type": "Isocontour",
  "metadata": {
    "generates": true
  },
  "params": [{
    "name": "field",
    "type": "field"
  }, {
    "name": "thresholds",
    "type": "number",
    "array": true
  }, {
    "name": "levels",
    "type": "number"
  }, {
    "name": "nice",
    "type": "boolean",
    "default": false
  }, {
    "name": "resolve",
    "type": "enum",
    "values": ["shared", "independent"],
    "default": "independent"
  }, {
    "name": "zero",
    "type": "boolean",
    "default": true
  }, {
    "name": "smooth",
    "type": "boolean",
    "default": true
  }, {
    "name": "scale",
    "type": "number",
    "expr": true
  }, {
    "name": "translate",
    "type": "number",
    "array": true,
    "expr": true
  }, {
    "name": "as",
    "type": "string",
    "null": true,
    "default": "contour"
  }]
};
inherits(Isocontour, Transform, {
  transform(_, pulse2) {
    if (this.value && !pulse2.changed() && !_.modified()) {
      return pulse2.StopPropagation;
    }
    var out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS), source3 = pulse2.materialize(pulse2.SOURCE).source, field3 = _.field || identity2, contour = contours().smooth(_.smooth !== false), tz = _.thresholds || levels(source3, field3, _), as = _.as === null ? null : _.as || "contour", values2 = [];
    source3.forEach((t) => {
      const grid = field3(t);
      const paths = contour.size([grid.width, grid.height])(grid.values, isArray(tz) ? tz : tz(grid.values));
      transformPaths(paths, grid, t, _);
      paths.forEach((p) => {
        values2.push(rederive(t, ingest$1(as != null ? {
          [as]: p
        } : p)));
      });
    });
    if (this.value)
      out.rem = this.value;
    this.value = out.source = out.add = values2;
    return out;
  }
});
function levels(values2, f, _) {
  const q = quantize2(_.levels || 10, _.nice, _.zero !== false);
  return _.resolve !== "shared" ? q : q(values2.map((t) => max(f(t).values)));
}
function transformPaths(paths, grid, datum2, _) {
  let s = _.scale || grid.scale, t = _.translate || grid.translate;
  if (isFunction(s))
    s = s(datum2, _);
  if (isFunction(t))
    t = t(datum2, _);
  if ((s === 1 || s == null) && !t)
    return;
  const sx = (isNumber(s) ? s : s[0]) || 1, sy = (isNumber(s) ? s : s[1]) || 1, tx = t && t[0] || 0, ty = t && t[1] || 0;
  paths.forEach(transform2(grid, sx, sy, tx, ty));
}
function transform2(grid, sx, sy, tx, ty) {
  const x12 = grid.x1 || 0, y12 = grid.y1 || 0, flip2 = sx * sy < 0;
  function transformPolygon(coordinates) {
    coordinates.forEach(transformRing);
  }
  function transformRing(coordinates) {
    if (flip2)
      coordinates.reverse();
    coordinates.forEach(transformPoint);
  }
  function transformPoint(coordinates) {
    coordinates[0] = (coordinates[0] - x12) * sx + tx;
    coordinates[1] = (coordinates[1] - y12) * sy + ty;
  }
  return function(geometry) {
    geometry.coordinates.forEach(transformPolygon);
    return geometry;
  };
}
function radius(bw, data3, f) {
  const v = bw >= 0 ? bw : estimateBandwidth(data3, f);
  return Math.round((Math.sqrt(4 * v * v + 1) - 1) / 2);
}
function number2(_) {
  return isFunction(_) ? _ : constant(+_);
}
function density2D() {
  var x2 = (d) => d[0], y2 = (d) => d[1], weight = one, bandwidth2 = [-1, -1], dx = 960, dy = 500, k2 = 2;
  function density(data3, counts) {
    const rx = radius(bandwidth2[0], data3, x2) >> k2, ry = radius(bandwidth2[1], data3, y2) >> k2, ox = rx ? rx + 2 : 0, oy = ry ? ry + 2 : 0, n = 2 * ox + (dx >> k2), m = 2 * oy + (dy >> k2), values0 = new Float32Array(n * m), values1 = new Float32Array(n * m);
    let values2 = values0;
    data3.forEach((d) => {
      const xi = ox + (+x2(d) >> k2), yi = oy + (+y2(d) >> k2);
      if (xi >= 0 && xi < n && yi >= 0 && yi < m) {
        values0[xi + yi * n] += +weight(d);
      }
    });
    if (rx > 0 && ry > 0) {
      blurX(n, m, values0, values1, rx);
      blurY(n, m, values1, values0, ry);
      blurX(n, m, values0, values1, rx);
      blurY(n, m, values1, values0, ry);
      blurX(n, m, values0, values1, rx);
      blurY(n, m, values1, values0, ry);
    } else if (rx > 0) {
      blurX(n, m, values0, values1, rx);
      blurX(n, m, values1, values0, rx);
      blurX(n, m, values0, values1, rx);
      values2 = values1;
    } else if (ry > 0) {
      blurY(n, m, values0, values1, ry);
      blurY(n, m, values1, values0, ry);
      blurY(n, m, values0, values1, ry);
      values2 = values1;
    }
    const s = counts ? Math.pow(2, -2 * k2) : 1 / sum(values2);
    for (let i = 0, sz2 = n * m; i < sz2; ++i)
      values2[i] *= s;
    return {
      values: values2,
      scale: 1 << k2,
      width: n,
      height: m,
      x1: ox,
      y1: oy,
      x2: ox + (dx >> k2),
      y2: oy + (dy >> k2)
    };
  }
  density.x = function(_) {
    return arguments.length ? (x2 = number2(_), density) : x2;
  };
  density.y = function(_) {
    return arguments.length ? (y2 = number2(_), density) : y2;
  };
  density.weight = function(_) {
    return arguments.length ? (weight = number2(_), density) : weight;
  };
  density.size = function(_) {
    if (!arguments.length)
      return [dx, dy];
    var _0 = +_[0], _1 = +_[1];
    if (!(_0 >= 0 && _1 >= 0))
      error("invalid size");
    return dx = _0, dy = _1, density;
  };
  density.cellSize = function(_) {
    if (!arguments.length)
      return 1 << k2;
    if (!((_ = +_) >= 1))
      error("invalid cell size");
    k2 = Math.floor(Math.log(_) / Math.LN2);
    return density;
  };
  density.bandwidth = function(_) {
    if (!arguments.length)
      return bandwidth2;
    _ = array(_);
    if (_.length === 1)
      _ = [+_[0], +_[0]];
    if (_.length !== 2)
      error("invalid bandwidth");
    return bandwidth2 = _, density;
  };
  return density;
}
function blurX(n, m, source3, target2, r) {
  const w3 = (r << 1) + 1;
  for (let j = 0; j < m; ++j) {
    for (let i = 0, sr = 0; i < n + r; ++i) {
      if (i < n) {
        sr += source3[i + j * n];
      }
      if (i >= r) {
        if (i >= w3) {
          sr -= source3[i - w3 + j * n];
        }
        target2[i - r + j * n] = sr / Math.min(i + 1, n - 1 + w3 - i, w3);
      }
    }
  }
}
function blurY(n, m, source3, target2, r) {
  const w3 = (r << 1) + 1;
  for (let i = 0; i < n; ++i) {
    for (let j = 0, sr = 0; j < m + r; ++j) {
      if (j < m) {
        sr += source3[i + j * n];
      }
      if (j >= r) {
        if (j >= w3) {
          sr -= source3[i + (j - w3) * n];
        }
        target2[i + (j - r) * n] = sr / Math.min(j + 1, m - 1 + w3 - j, w3);
      }
    }
  }
}
function KDE2D(params2) {
  Transform.call(this, null, params2);
}
KDE2D.Definition = {
  "type": "KDE2D",
  "metadata": {
    "generates": true
  },
  "params": [{
    "name": "size",
    "type": "number",
    "array": true,
    "length": 2,
    "required": true
  }, {
    "name": "x",
    "type": "field",
    "required": true
  }, {
    "name": "y",
    "type": "field",
    "required": true
  }, {
    "name": "weight",
    "type": "field"
  }, {
    "name": "groupby",
    "type": "field",
    "array": true
  }, {
    "name": "cellSize",
    "type": "number"
  }, {
    "name": "bandwidth",
    "type": "number",
    "array": true,
    "length": 2
  }, {
    "name": "counts",
    "type": "boolean",
    "default": false
  }, {
    "name": "as",
    "type": "string",
    "default": "grid"
  }]
};
var PARAMS = ["x", "y", "weight", "size", "cellSize", "bandwidth"];
function params(obj, _) {
  PARAMS.forEach((param2) => _[param2] != null ? obj[param2](_[param2]) : 0);
  return obj;
}
inherits(KDE2D, Transform, {
  transform(_, pulse2) {
    if (this.value && !pulse2.changed() && !_.modified())
      return pulse2.StopPropagation;
    var out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS), source3 = pulse2.materialize(pulse2.SOURCE).source, groups = partition3(source3, _.groupby), names = (_.groupby || []).map(accessorName), kde2 = params(density2D(), _), as = _.as || "grid", values2 = [];
    function set4(t, vals) {
      for (let i = 0; i < names.length; ++i)
        t[names[i]] = vals[i];
      return t;
    }
    values2 = groups.map((g) => ingest$1(set4({
      [as]: kde2(g, _.counts)
    }, g.dims)));
    if (this.value)
      out.rem = this.value;
    this.value = out.source = out.add = values2;
    return out;
  }
});
function partition3(data3, groupby) {
  var groups = [], get5 = (f) => f(t), map2, i, n, t, k2, g;
  if (groupby == null) {
    groups.push(data3);
  } else {
    for (map2 = {}, i = 0, n = data3.length; i < n; ++i) {
      t = data3[i];
      k2 = groupby.map(get5);
      g = map2[k2];
      if (!g) {
        map2[k2] = g = [];
        g.dims = k2;
        groups.push(g);
      }
      g.push(t);
    }
  }
  return groups;
}
function Contour(params2) {
  Transform.call(this, null, params2);
}
Contour.Definition = {
  "type": "Contour",
  "metadata": {
    "generates": true
  },
  "params": [{
    "name": "size",
    "type": "number",
    "array": true,
    "length": 2,
    "required": true
  }, {
    "name": "values",
    "type": "number",
    "array": true
  }, {
    "name": "x",
    "type": "field"
  }, {
    "name": "y",
    "type": "field"
  }, {
    "name": "weight",
    "type": "field"
  }, {
    "name": "cellSize",
    "type": "number"
  }, {
    "name": "bandwidth",
    "type": "number"
  }, {
    "name": "count",
    "type": "number"
  }, {
    "name": "nice",
    "type": "boolean",
    "default": false
  }, {
    "name": "thresholds",
    "type": "number",
    "array": true
  }, {
    "name": "smooth",
    "type": "boolean",
    "default": true
  }]
};
inherits(Contour, Transform, {
  transform(_, pulse2) {
    if (this.value && !pulse2.changed() && !_.modified()) {
      return pulse2.StopPropagation;
    }
    var out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS), contour = contours().smooth(_.smooth !== false), values2 = _.values, thresh = _.thresholds || quantize2(_.count || 10, _.nice, !!values2), size = _.size, grid, post;
    if (!values2) {
      values2 = pulse2.materialize(pulse2.SOURCE).source;
      grid = params(density2D(), _)(values2, true);
      post = transform2(grid, grid.scale || 1, grid.scale || 1, 0, 0);
      size = [grid.width, grid.height];
      values2 = grid.values;
    }
    thresh = isArray(thresh) ? thresh : thresh(values2);
    values2 = contour.size(size)(values2, thresh);
    if (post)
      values2.forEach(post);
    if (this.value)
      out.rem = this.value;
    this.value = out.source = out.add = (values2 || []).map(ingest$1);
    return out;
  }
});
var Feature = "Feature";
var FeatureCollection = "FeatureCollection";
var MultiPoint = "MultiPoint";
function GeoJSON(params2) {
  Transform.call(this, null, params2);
}
GeoJSON.Definition = {
  "type": "GeoJSON",
  "metadata": {},
  "params": [{
    "name": "fields",
    "type": "field",
    "array": true,
    "length": 2
  }, {
    "name": "geojson",
    "type": "field"
  }]
};
inherits(GeoJSON, Transform, {
  transform(_, pulse2) {
    var features = this._features, points2 = this._points, fields = _.fields, lon = fields && fields[0], lat = fields && fields[1], geojson = _.geojson || !fields && identity2, flag2 = pulse2.ADD, mod;
    mod = _.modified() || pulse2.changed(pulse2.REM) || pulse2.modified(accessorFields(geojson)) || lon && pulse2.modified(accessorFields(lon)) || lat && pulse2.modified(accessorFields(lat));
    if (!this.value || mod) {
      flag2 = pulse2.SOURCE;
      this._features = features = [];
      this._points = points2 = [];
    }
    if (geojson) {
      pulse2.visit(flag2, (t) => features.push(geojson(t)));
    }
    if (lon && lat) {
      pulse2.visit(flag2, (t) => {
        var x2 = lon(t), y2 = lat(t);
        if (x2 != null && y2 != null && (x2 = +x2) === x2 && (y2 = +y2) === y2) {
          points2.push([x2, y2]);
        }
      });
      features = features.concat({
        type: Feature,
        geometry: {
          type: MultiPoint,
          coordinates: points2
        }
      });
    }
    this.value = {
      type: FeatureCollection,
      features
    };
  }
});
function GeoPath(params2) {
  Transform.call(this, null, params2);
}
GeoPath.Definition = {
  "type": "GeoPath",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "projection",
    "type": "projection"
  }, {
    "name": "field",
    "type": "field"
  }, {
    "name": "pointRadius",
    "type": "number",
    "expr": true
  }, {
    "name": "as",
    "type": "string",
    "default": "path"
  }]
};
inherits(GeoPath, Transform, {
  transform(_, pulse2) {
    var out = pulse2.fork(pulse2.ALL), path3 = this.value, field3 = _.field || identity2, as = _.as || "path", flag2 = out.SOURCE;
    if (!path3 || _.modified()) {
      this.value = path3 = getProjectionPath(_.projection);
      out.materialize().reflow();
    } else {
      flag2 = field3 === identity2 || pulse2.modified(field3.fields) ? out.ADD_MOD : out.ADD;
    }
    const prev = initPath(path3, _.pointRadius);
    out.visit(flag2, (t) => t[as] = path3(field3(t)));
    path3.pointRadius(prev);
    return out.modifies(as);
  }
});
function initPath(path3, pointRadius) {
  const prev = path3.pointRadius();
  path3.context(null);
  if (pointRadius != null) {
    path3.pointRadius(pointRadius);
  }
  return prev;
}
function GeoPoint(params2) {
  Transform.call(this, null, params2);
}
GeoPoint.Definition = {
  "type": "GeoPoint",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "projection",
    "type": "projection",
    "required": true
  }, {
    "name": "fields",
    "type": "field",
    "array": true,
    "required": true,
    "length": 2
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "length": 2,
    "default": ["x", "y"]
  }]
};
inherits(GeoPoint, Transform, {
  transform(_, pulse2) {
    var proj = _.projection, lon = _.fields[0], lat = _.fields[1], as = _.as || ["x", "y"], x2 = as[0], y2 = as[1], mod;
    function set4(t) {
      const xy = proj([lon(t), lat(t)]);
      if (xy) {
        t[x2] = xy[0];
        t[y2] = xy[1];
      } else {
        t[x2] = void 0;
        t[y2] = void 0;
      }
    }
    if (_.modified()) {
      pulse2 = pulse2.materialize().reflow(true).visit(pulse2.SOURCE, set4);
    } else {
      mod = pulse2.modified(lon.fields) || pulse2.modified(lat.fields);
      pulse2.visit(mod ? pulse2.ADD_MOD : pulse2.ADD, set4);
    }
    return pulse2.modifies(as);
  }
});
function GeoShape(params2) {
  Transform.call(this, null, params2);
}
GeoShape.Definition = {
  "type": "GeoShape",
  "metadata": {
    "modifies": true,
    "nomod": true
  },
  "params": [{
    "name": "projection",
    "type": "projection"
  }, {
    "name": "field",
    "type": "field",
    "default": "datum"
  }, {
    "name": "pointRadius",
    "type": "number",
    "expr": true
  }, {
    "name": "as",
    "type": "string",
    "default": "shape"
  }]
};
inherits(GeoShape, Transform, {
  transform(_, pulse2) {
    var out = pulse2.fork(pulse2.ALL), shape2 = this.value, as = _.as || "shape", flag2 = out.ADD;
    if (!shape2 || _.modified()) {
      this.value = shape2 = shapeGenerator(getProjectionPath(_.projection), _.field || field("datum"), _.pointRadius);
      out.materialize().reflow();
      flag2 = out.SOURCE;
    }
    out.visit(flag2, (t) => t[as] = shape2);
    return out.modifies(as);
  }
});
function shapeGenerator(path3, field3, pointRadius) {
  const shape2 = pointRadius == null ? (_) => path3(field3(_)) : (_) => {
    var prev = path3.pointRadius(), value3 = path3.pointRadius(pointRadius)(field3(_));
    path3.pointRadius(prev);
    return value3;
  };
  shape2.context = (_) => {
    path3.context(_);
    return shape2;
  };
  return shape2;
}
function Graticule(params2) {
  Transform.call(this, [], params2);
  this.generator = graticule();
}
Graticule.Definition = {
  "type": "Graticule",
  "metadata": {
    "changes": true,
    "generates": true
  },
  "params": [{
    "name": "extent",
    "type": "array",
    "array": true,
    "length": 2,
    "content": {
      "type": "number",
      "array": true,
      "length": 2
    }
  }, {
    "name": "extentMajor",
    "type": "array",
    "array": true,
    "length": 2,
    "content": {
      "type": "number",
      "array": true,
      "length": 2
    }
  }, {
    "name": "extentMinor",
    "type": "array",
    "array": true,
    "length": 2,
    "content": {
      "type": "number",
      "array": true,
      "length": 2
    }
  }, {
    "name": "step",
    "type": "number",
    "array": true,
    "length": 2
  }, {
    "name": "stepMajor",
    "type": "number",
    "array": true,
    "length": 2,
    "default": [90, 360]
  }, {
    "name": "stepMinor",
    "type": "number",
    "array": true,
    "length": 2,
    "default": [10, 10]
  }, {
    "name": "precision",
    "type": "number",
    "default": 2.5
  }]
};
inherits(Graticule, Transform, {
  transform(_, pulse2) {
    var src = this.value, gen = this.generator, t;
    if (!src.length || _.modified()) {
      for (const prop in _) {
        if (isFunction(gen[prop])) {
          gen[prop](_[prop]);
        }
      }
    }
    t = gen();
    if (src.length) {
      pulse2.mod.push(replace(src[0], t));
    } else {
      pulse2.add.push(ingest$1(t));
    }
    src[0] = t;
    return pulse2;
  }
});
function Heatmap(params2) {
  Transform.call(this, null, params2);
}
Heatmap.Definition = {
  "type": "heatmap",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "field",
    "type": "field"
  }, {
    "name": "color",
    "type": "string",
    "expr": true
  }, {
    "name": "opacity",
    "type": "number",
    "expr": true
  }, {
    "name": "resolve",
    "type": "enum",
    "values": ["shared", "independent"],
    "default": "independent"
  }, {
    "name": "as",
    "type": "string",
    "default": "image"
  }]
};
inherits(Heatmap, Transform, {
  transform(_, pulse2) {
    if (!pulse2.changed() && !_.modified()) {
      return pulse2.StopPropagation;
    }
    var source3 = pulse2.materialize(pulse2.SOURCE).source, shared = _.resolve === "shared", field3 = _.field || identity2, opacity = opacity_(_.opacity, _), color3 = color_(_.color, _), as = _.as || "image", obj = {
      $x: 0,
      $y: 0,
      $value: 0,
      $max: shared ? max(source3.map((t) => max(field3(t).values))) : 0
    };
    source3.forEach((t) => {
      const v = field3(t);
      const o = extend({}, t, obj);
      if (!shared)
        o.$max = max(v.values || []);
      t[as] = toCanvas(v, o, color3.dep ? color3 : constant(color3(o)), opacity.dep ? opacity : constant(opacity(o)));
    });
    return pulse2.reflow(true).modifies(as);
  }
});
function color_(color3, _) {
  let f;
  if (isFunction(color3)) {
    f = (obj) => rgb(color3(obj, _));
    f.dep = dependency(color3);
  } else {
    f = constant(rgb(color3 || "#888"));
  }
  return f;
}
function opacity_(opacity, _) {
  let f;
  if (isFunction(opacity)) {
    f = (obj) => opacity(obj, _);
    f.dep = dependency(opacity);
  } else if (opacity) {
    f = constant(opacity);
  } else {
    f = (obj) => obj.$value / obj.$max || 0;
    f.dep = true;
  }
  return f;
}
function dependency(f) {
  if (!isFunction(f))
    return false;
  const set4 = toSet(accessorFields(f));
  return set4.$x || set4.$y || set4.$value || set4.$max;
}
function toCanvas(grid, obj, color3, opacity) {
  const n = grid.width, m = grid.height, x12 = grid.x1 || 0, y12 = grid.y1 || 0, x2 = grid.x2 || n, y2 = grid.y2 || m, val = grid.values, value3 = val ? (i) => val[i] : zero, can = domCanvas(x2 - x12, y2 - y12), ctx = can.getContext("2d"), img = ctx.getImageData(0, 0, x2 - x12, y2 - y12), pix = img.data;
  for (let j = y12, k2 = 0; j < y2; ++j) {
    obj.$y = j - y12;
    for (let i = x12, r = j * n; i < x2; ++i, k2 += 4) {
      obj.$x = i - x12;
      obj.$value = value3(i + r);
      const v = color3(obj);
      pix[k2 + 0] = v.r;
      pix[k2 + 1] = v.g;
      pix[k2 + 2] = v.b;
      pix[k2 + 3] = ~~(255 * opacity(obj));
    }
  }
  ctx.putImageData(img, 0, 0);
  return can;
}
function Projection(params2) {
  Transform.call(this, null, params2);
  this.modified(true);
}
inherits(Projection, Transform, {
  transform(_, pulse2) {
    let proj = this.value;
    if (!proj || _.modified("type")) {
      this.value = proj = create3(_.type);
      projectionProperties.forEach((prop) => {
        if (_[prop] != null)
          set3(proj, prop, _[prop]);
      });
    } else {
      projectionProperties.forEach((prop) => {
        if (_.modified(prop))
          set3(proj, prop, _[prop]);
      });
    }
    if (_.pointRadius != null)
      proj.path.pointRadius(_.pointRadius);
    if (_.fit)
      fit(proj, _);
    return pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS);
  }
});
function fit(proj, _) {
  const data3 = collectGeoJSON(_.fit);
  _.extent ? proj.fitExtent(_.extent, data3) : _.size ? proj.fitSize(_.size, data3) : 0;
}
function create3(type2) {
  const constructor = projection2((type2 || "mercator").toLowerCase());
  if (!constructor)
    error("Unrecognized projection type: " + type2);
  return constructor();
}
function set3(proj, key2, value3) {
  if (isFunction(proj[key2]))
    proj[key2](value3);
}
function collectGeoJSON(data3) {
  data3 = array(data3);
  return data3.length === 1 ? data3[0] : {
    type: FeatureCollection,
    features: data3.reduce((a, f) => a.concat(featurize(f)), [])
  };
}
function featurize(f) {
  return f.type === FeatureCollection ? f.features : array(f).filter((d) => d != null).map((d) => d.type === Feature ? d : {
    type: Feature,
    geometry: d
  });
}

// node_modules/vega-force/build/vega-force.module.js
var vega_force_module_exports = {};
__export(vega_force_module_exports, {
  force: () => Force
});
var ForceMap = {
  center: center_default,
  collide: collide_default,
  nbody: manyBody_default,
  link: link_default,
  x: x_default,
  y: y_default
};
var Forces = "forces";
var ForceParams = ["alpha", "alphaMin", "alphaTarget", "velocityDecay", "forces"];
var ForceConfig = ["static", "iterations"];
var ForceOutput = ["x", "y", "vx", "vy"];
function Force(params2) {
  Transform.call(this, null, params2);
}
Force.Definition = {
  "type": "Force",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "static",
    "type": "boolean",
    "default": false
  }, {
    "name": "restart",
    "type": "boolean",
    "default": false
  }, {
    "name": "iterations",
    "type": "number",
    "default": 300
  }, {
    "name": "alpha",
    "type": "number",
    "default": 1
  }, {
    "name": "alphaMin",
    "type": "number",
    "default": 1e-3
  }, {
    "name": "alphaTarget",
    "type": "number",
    "default": 0
  }, {
    "name": "velocityDecay",
    "type": "number",
    "default": 0.4
  }, {
    "name": "forces",
    "type": "param",
    "array": true,
    "params": [{
      "key": {
        "force": "center"
      },
      "params": [{
        "name": "x",
        "type": "number",
        "default": 0
      }, {
        "name": "y",
        "type": "number",
        "default": 0
      }]
    }, {
      "key": {
        "force": "collide"
      },
      "params": [{
        "name": "radius",
        "type": "number",
        "expr": true
      }, {
        "name": "strength",
        "type": "number",
        "default": 0.7
      }, {
        "name": "iterations",
        "type": "number",
        "default": 1
      }]
    }, {
      "key": {
        "force": "nbody"
      },
      "params": [{
        "name": "strength",
        "type": "number",
        "default": -30,
        "expr": true
      }, {
        "name": "theta",
        "type": "number",
        "default": 0.9
      }, {
        "name": "distanceMin",
        "type": "number",
        "default": 1
      }, {
        "name": "distanceMax",
        "type": "number"
      }]
    }, {
      "key": {
        "force": "link"
      },
      "params": [{
        "name": "links",
        "type": "data"
      }, {
        "name": "id",
        "type": "field"
      }, {
        "name": "distance",
        "type": "number",
        "default": 30,
        "expr": true
      }, {
        "name": "strength",
        "type": "number",
        "expr": true
      }, {
        "name": "iterations",
        "type": "number",
        "default": 1
      }]
    }, {
      "key": {
        "force": "x"
      },
      "params": [{
        "name": "strength",
        "type": "number",
        "default": 0.1
      }, {
        "name": "x",
        "type": "field"
      }]
    }, {
      "key": {
        "force": "y"
      },
      "params": [{
        "name": "strength",
        "type": "number",
        "default": 0.1
      }, {
        "name": "y",
        "type": "field"
      }]
    }]
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "modify": false,
    "default": ForceOutput
  }]
};
inherits(Force, Transform, {
  transform(_, pulse2) {
    var sim = this.value, change2 = pulse2.changed(pulse2.ADD_REM), params2 = _.modified(ForceParams), iters = _.iterations || 300;
    if (!sim) {
      this.value = sim = simulation(pulse2.source, _);
      sim.on("tick", rerun(pulse2.dataflow, this));
      if (!_.static) {
        change2 = true;
        sim.tick();
      }
      pulse2.modifies("index");
    } else {
      if (change2) {
        pulse2.modifies("index");
        sim.nodes(pulse2.source);
      }
      if (params2 || pulse2.changed(pulse2.MOD)) {
        setup(sim, _, 0, pulse2);
      }
    }
    if (params2 || change2 || _.modified(ForceConfig) || pulse2.changed() && _.restart) {
      sim.alpha(Math.max(sim.alpha(), _.alpha || 1)).alphaDecay(1 - Math.pow(sim.alphaMin(), 1 / iters));
      if (_.static) {
        for (sim.stop(); --iters >= 0; )
          sim.tick();
      } else {
        if (sim.stopped())
          sim.restart();
        if (!change2)
          return pulse2.StopPropagation;
      }
    }
    return this.finish(_, pulse2);
  },
  finish(_, pulse2) {
    const dataflow = pulse2.dataflow;
    for (let args = this._argops, j = 0, m = args.length, arg; j < m; ++j) {
      arg = args[j];
      if (arg.name !== Forces || arg.op._argval.force !== "link") {
        continue;
      }
      for (var ops2 = arg.op._argops, i = 0, n = ops2.length, op; i < n; ++i) {
        if (ops2[i].name === "links" && (op = ops2[i].op.source)) {
          dataflow.pulse(op, dataflow.changeset().reflow());
          break;
        }
      }
    }
    return pulse2.reflow(_.modified()).modifies(ForceOutput);
  }
});
function rerun(df, op) {
  return () => df.touch(op).run();
}
function simulation(nodes, _) {
  const sim = simulation_default(nodes), stop2 = sim.stop, restart = sim.restart;
  let stopped = false;
  sim.stopped = () => stopped;
  sim.restart = () => (stopped = false, restart());
  sim.stop = () => (stopped = true, stop2());
  return setup(sim, _, true).on("end", () => stopped = true);
}
function setup(sim, _, init2, pulse2) {
  var f = array(_.forces), i, n, p, name;
  for (i = 0, n = ForceParams.length; i < n; ++i) {
    p = ForceParams[i];
    if (p !== Forces && _.modified(p))
      sim[p](_[p]);
  }
  for (i = 0, n = f.length; i < n; ++i) {
    name = Forces + i;
    p = init2 || _.modified(Forces, i) ? getForce(f[i]) : pulse2 && modified(f[i], pulse2) ? sim.force(name) : null;
    if (p)
      sim.force(name, p);
  }
  for (n = sim.numForces || 0; i < n; ++i) {
    sim.force(Forces + i, null);
  }
  sim.numForces = f.length;
  return sim;
}
function modified(f, pulse2) {
  var k2, v;
  for (k2 in f) {
    if (isFunction(v = f[k2]) && pulse2.modified(accessorFields(v)))
      return 1;
  }
  return 0;
}
function getForce(_) {
  var f, p;
  if (!has(ForceMap, _.force)) {
    error("Unrecognized force: " + _.force);
  }
  f = ForceMap[_.force]();
  for (p in _) {
    if (isFunction(f[p]))
      setForceParam(f[p], _[p], _);
  }
  return f;
}
function setForceParam(f, v, _) {
  f(isFunction(v) ? (d) => v(d, _) : v);
}

// node_modules/vega-hierarchy/build/vega-hierarchy.module.js
var vega_hierarchy_module_exports = {};
__export(vega_hierarchy_module_exports, {
  nest: () => Nest,
  pack: () => Pack,
  partition: () => Partition,
  stratify: () => Stratify,
  tree: () => Tree,
  treelinks: () => TreeLinks,
  treemap: () => Treemap
});
function lookup3(tree, key2, filter3) {
  const map2 = {};
  tree.each((node) => {
    const t = node.data;
    if (filter3(t))
      map2[key2(t)] = node;
  });
  tree.lookup = map2;
  return tree;
}
function Nest(params2) {
  Transform.call(this, null, params2);
}
Nest.Definition = {
  "type": "Nest",
  "metadata": {
    "treesource": true,
    "changes": true
  },
  "params": [{
    "name": "keys",
    "type": "field",
    "array": true
  }, {
    "name": "generate",
    "type": "boolean"
  }]
};
var children = (n) => n.values;
inherits(Nest, Transform, {
  transform(_, pulse2) {
    if (!pulse2.source) {
      error("Nest transform requires an upstream data source.");
    }
    var gen = _.generate, mod = _.modified(), out = pulse2.clone(), tree = this.value;
    if (!tree || mod || pulse2.changed()) {
      if (tree) {
        tree.each((node) => {
          if (node.children && isTuple(node.data)) {
            out.rem.push(node.data);
          }
        });
      }
      this.value = tree = hierarchy({
        values: array(_.keys).reduce((n, k2) => {
          n.key(k2);
          return n;
        }, nest()).entries(out.source)
      }, children);
      if (gen) {
        tree.each((node) => {
          if (node.children) {
            node = ingest$1(node.data);
            out.add.push(node);
            out.source.push(node);
          }
        });
      }
      lookup3(tree, tupleid, tupleid);
    }
    out.source.root = tree;
    return out;
  }
});
function nest() {
  const keys3 = [], nest2 = {
    entries: (array4) => entries(apply2(array4, 0), 0),
    key: (d) => (keys3.push(d), nest2)
  };
  function apply2(array4, depth) {
    if (depth >= keys3.length) {
      return array4;
    }
    const n = array4.length, key2 = keys3[depth++], valuesByKey = {}, result = {};
    let i = -1, keyValue, value3, values2;
    while (++i < n) {
      keyValue = key2(value3 = array4[i]) + "";
      if (values2 = valuesByKey[keyValue]) {
        values2.push(value3);
      } else {
        valuesByKey[keyValue] = [value3];
      }
    }
    for (keyValue in valuesByKey) {
      result[keyValue] = apply2(valuesByKey[keyValue], depth);
    }
    return result;
  }
  function entries(map2, depth) {
    if (++depth > keys3.length)
      return map2;
    const array4 = [];
    for (const key2 in map2) {
      array4.push({
        key: key2,
        values: entries(map2[key2], depth)
      });
    }
    return array4;
  }
  return nest2;
}
function HierarchyLayout(params2) {
  Transform.call(this, null, params2);
}
var defaultSeparation = (a, b2) => a.parent === b2.parent ? 1 : 2;
inherits(HierarchyLayout, Transform, {
  transform(_, pulse2) {
    if (!pulse2.source || !pulse2.source.root) {
      error(this.constructor.name + " transform requires a backing tree data source.");
    }
    const layout = this.layout(_.method), fields = this.fields, root = pulse2.source.root, as = _.as || fields;
    if (_.field)
      root.sum(_.field);
    else
      root.count();
    if (_.sort)
      root.sort(stableCompare(_.sort, (d) => d.data));
    setParams(layout, this.params, _);
    if (layout.separation) {
      layout.separation(_.separation !== false ? defaultSeparation : one);
    }
    try {
      this.value = layout(root);
    } catch (err) {
      error(err);
    }
    root.each((node) => setFields(node, fields, as));
    return pulse2.reflow(_.modified()).modifies(as).modifies("leaf");
  }
});
function setParams(layout, params2, _) {
  for (let p, i = 0, n = params2.length; i < n; ++i) {
    p = params2[i];
    if (p in _)
      layout[p](_[p]);
  }
}
function setFields(node, fields, as) {
  const t = node.data, n = fields.length - 1;
  for (let i = 0; i < n; ++i) {
    t[as[i]] = node[fields[i]];
  }
  t[as[n]] = node.children ? node.children.length : 0;
}
var Output$3 = ["x", "y", "r", "depth", "children"];
function Pack(params2) {
  HierarchyLayout.call(this, params2);
}
Pack.Definition = {
  "type": "Pack",
  "metadata": {
    "tree": true,
    "modifies": true
  },
  "params": [{
    "name": "field",
    "type": "field"
  }, {
    "name": "sort",
    "type": "compare"
  }, {
    "name": "padding",
    "type": "number",
    "default": 0
  }, {
    "name": "radius",
    "type": "field",
    "default": null
  }, {
    "name": "size",
    "type": "number",
    "array": true,
    "length": 2
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "length": Output$3.length,
    "default": Output$3
  }]
};
inherits(Pack, HierarchyLayout, {
  layout: pack_default,
  params: ["radius", "size", "padding"],
  fields: Output$3
});
var Output$2 = ["x0", "y0", "x1", "y1", "depth", "children"];
function Partition(params2) {
  HierarchyLayout.call(this, params2);
}
Partition.Definition = {
  "type": "Partition",
  "metadata": {
    "tree": true,
    "modifies": true
  },
  "params": [{
    "name": "field",
    "type": "field"
  }, {
    "name": "sort",
    "type": "compare"
  }, {
    "name": "padding",
    "type": "number",
    "default": 0
  }, {
    "name": "round",
    "type": "boolean",
    "default": false
  }, {
    "name": "size",
    "type": "number",
    "array": true,
    "length": 2
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "length": Output$2.length,
    "default": Output$2
  }]
};
inherits(Partition, HierarchyLayout, {
  layout: partition_default,
  params: ["size", "round", "padding"],
  fields: Output$2
});
function Stratify(params2) {
  Transform.call(this, null, params2);
}
Stratify.Definition = {
  "type": "Stratify",
  "metadata": {
    "treesource": true
  },
  "params": [{
    "name": "key",
    "type": "field",
    "required": true
  }, {
    "name": "parentKey",
    "type": "field",
    "required": true
  }]
};
inherits(Stratify, Transform, {
  transform(_, pulse2) {
    if (!pulse2.source) {
      error("Stratify transform requires an upstream data source.");
    }
    let tree = this.value;
    const mod = _.modified(), out = pulse2.fork(pulse2.ALL).materialize(pulse2.SOURCE), run2 = !tree || mod || pulse2.changed(pulse2.ADD_REM) || pulse2.modified(_.key.fields) || pulse2.modified(_.parentKey.fields);
    out.source = out.source.slice();
    if (run2) {
      tree = out.source.length ? lookup3(stratify_default().id(_.key).parentId(_.parentKey)(out.source), _.key, truthy) : lookup3(stratify_default()([{}]), _.key, _.key);
    }
    out.source.root = this.value = tree;
    return out;
  }
});
var Layouts = {
  tidy: tree_default,
  cluster: cluster_default
};
var Output$1 = ["x", "y", "depth", "children"];
function Tree(params2) {
  HierarchyLayout.call(this, params2);
}
Tree.Definition = {
  "type": "Tree",
  "metadata": {
    "tree": true,
    "modifies": true
  },
  "params": [{
    "name": "field",
    "type": "field"
  }, {
    "name": "sort",
    "type": "compare"
  }, {
    "name": "method",
    "type": "enum",
    "default": "tidy",
    "values": ["tidy", "cluster"]
  }, {
    "name": "size",
    "type": "number",
    "array": true,
    "length": 2
  }, {
    "name": "nodeSize",
    "type": "number",
    "array": true,
    "length": 2
  }, {
    "name": "separation",
    "type": "boolean",
    "default": true
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "length": Output$1.length,
    "default": Output$1
  }]
};
inherits(Tree, HierarchyLayout, {
  /**
   * Tree layout generator. Supports both 'tidy' and 'cluster' layouts.
   */
  layout(method2) {
    const m = method2 || "tidy";
    if (has(Layouts, m))
      return Layouts[m]();
    else
      error("Unrecognized Tree layout method: " + m);
  },
  params: ["size", "nodeSize"],
  fields: Output$1
});
function TreeLinks(params2) {
  Transform.call(this, [], params2);
}
TreeLinks.Definition = {
  "type": "TreeLinks",
  "metadata": {
    "tree": true,
    "generates": true,
    "changes": true
  },
  "params": []
};
inherits(TreeLinks, Transform, {
  transform(_, pulse2) {
    const links = this.value, tree = pulse2.source && pulse2.source.root, out = pulse2.fork(pulse2.NO_SOURCE), lut = {};
    if (!tree)
      error("TreeLinks transform requires a tree data source.");
    if (pulse2.changed(pulse2.ADD_REM)) {
      out.rem = links;
      pulse2.visit(pulse2.SOURCE, (t) => lut[tupleid(t)] = 1);
      tree.each((node) => {
        const t = node.data, p = node.parent && node.parent.data;
        if (p && lut[tupleid(t)] && lut[tupleid(p)]) {
          out.add.push(ingest$1({
            source: p,
            target: t
          }));
        }
      });
      this.value = out.add;
    } else if (pulse2.changed(pulse2.MOD)) {
      pulse2.visit(pulse2.MOD, (t) => lut[tupleid(t)] = 1);
      links.forEach((link) => {
        if (lut[tupleid(link.source)] || lut[tupleid(link.target)]) {
          out.mod.push(link);
        }
      });
    }
    return out;
  }
});
var Tiles = {
  binary: binary_default,
  dice: dice_default,
  slice: slice_default,
  slicedice: sliceDice_default,
  squarify: squarify_default,
  resquarify: resquarify_default
};
var Output2 = ["x0", "y0", "x1", "y1", "depth", "children"];
function Treemap(params2) {
  HierarchyLayout.call(this, params2);
}
Treemap.Definition = {
  "type": "Treemap",
  "metadata": {
    "tree": true,
    "modifies": true
  },
  "params": [{
    "name": "field",
    "type": "field"
  }, {
    "name": "sort",
    "type": "compare"
  }, {
    "name": "method",
    "type": "enum",
    "default": "squarify",
    "values": ["squarify", "resquarify", "binary", "dice", "slice", "slicedice"]
  }, {
    "name": "padding",
    "type": "number",
    "default": 0
  }, {
    "name": "paddingInner",
    "type": "number",
    "default": 0
  }, {
    "name": "paddingOuter",
    "type": "number",
    "default": 0
  }, {
    "name": "paddingTop",
    "type": "number",
    "default": 0
  }, {
    "name": "paddingRight",
    "type": "number",
    "default": 0
  }, {
    "name": "paddingBottom",
    "type": "number",
    "default": 0
  }, {
    "name": "paddingLeft",
    "type": "number",
    "default": 0
  }, {
    "name": "ratio",
    "type": "number",
    "default": 1.618033988749895
  }, {
    "name": "round",
    "type": "boolean",
    "default": false
  }, {
    "name": "size",
    "type": "number",
    "array": true,
    "length": 2
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "length": Output2.length,
    "default": Output2
  }]
};
inherits(Treemap, HierarchyLayout, {
  /**
   * Treemap layout generator. Adds 'method' and 'ratio' parameters
   * to configure the underlying tile method.
   */
  layout() {
    const x2 = treemap_default();
    x2.ratio = (_) => {
      const t = x2.tile();
      if (t.ratio)
        x2.tile(t.ratio(_));
    };
    x2.method = (_) => {
      if (has(Tiles, _))
        x2.tile(Tiles[_]);
      else
        error("Unrecognized Treemap layout method: " + _);
    };
    return x2;
  },
  params: ["method", "ratio", "size", "round", "padding", "paddingInner", "paddingOuter", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft"],
  fields: Output2
});

// node_modules/vega-label/build/vega-label.module.js
var vega_label_module_exports = {};
__export(vega_label_module_exports, {
  label: () => Label
});
var ALPHA_MASK = 4278190080;
function baseBitmaps($2, data3) {
  const bitmap = $2.bitmap();
  (data3 || []).forEach((d) => bitmap.set($2(d.boundary[0]), $2(d.boundary[3])));
  return [bitmap, void 0];
}
function markBitmaps($2, baseMark, avoidMarks, labelInside, isGroupArea) {
  const width2 = $2.width, height2 = $2.height, border = labelInside || isGroupArea, context3 = domCanvas(width2, height2).getContext("2d"), baseMarkContext = domCanvas(width2, height2).getContext("2d"), strokeContext = border && domCanvas(width2, height2).getContext("2d");
  avoidMarks.forEach((items) => draw2(context3, items, false));
  draw2(baseMarkContext, baseMark, false);
  if (border) {
    draw2(strokeContext, baseMark, true);
  }
  const buffer = getBuffer(context3, width2, height2), baseMarkBuffer = getBuffer(baseMarkContext, width2, height2), strokeBuffer = border && getBuffer(strokeContext, width2, height2), layer1 = $2.bitmap(), layer2 = border && $2.bitmap();
  let x2, y2, u, v, index2, alpha, strokeAlpha, baseMarkAlpha;
  for (y2 = 0; y2 < height2; ++y2) {
    for (x2 = 0; x2 < width2; ++x2) {
      index2 = y2 * width2 + x2;
      alpha = buffer[index2] & ALPHA_MASK;
      baseMarkAlpha = baseMarkBuffer[index2] & ALPHA_MASK;
      strokeAlpha = border && strokeBuffer[index2] & ALPHA_MASK;
      if (alpha || strokeAlpha || baseMarkAlpha) {
        u = $2(x2);
        v = $2(y2);
        if (!isGroupArea && (alpha || baseMarkAlpha))
          layer1.set(u, v);
        if (border && (alpha || strokeAlpha))
          layer2.set(u, v);
      }
    }
  }
  return [layer1, layer2];
}
function getBuffer(context3, width2, height2) {
  return new Uint32Array(context3.getImageData(0, 0, width2, height2).data.buffer);
}
function draw2(context3, items, interior) {
  if (!items.length)
    return;
  const type2 = items[0].mark.marktype;
  if (type2 === "group") {
    items.forEach((group2) => {
      group2.items.forEach((mark) => draw2(context3, mark.items, interior));
    });
  } else {
    Marks[type2].draw(context3, {
      items: interior ? items.map(prepare) : items
    });
  }
}
function prepare(source3) {
  const item = rederive(source3, {});
  if (item.stroke && item.strokeOpacity !== 0 || item.fill && item.fillOpacity !== 0) {
    return {
      ...item,
      strokeOpacity: 1,
      stroke: "#000",
      fillOpacity: 0
    };
  }
  return item;
}
var DIV = 5;
var MOD2 = 31;
var SIZE = 32;
var RIGHT0 = new Uint32Array(SIZE + 1);
var RIGHT1 = new Uint32Array(SIZE + 1);
RIGHT1[0] = 0;
RIGHT0[0] = ~RIGHT1[0];
for (let i = 1; i <= SIZE; ++i) {
  RIGHT1[i] = RIGHT1[i - 1] << 1 | 1;
  RIGHT0[i] = ~RIGHT1[i];
}
function Bitmap(w3, h2) {
  const array4 = new Uint32Array(~~((w3 * h2 + SIZE) / SIZE));
  function _set(index2, mask) {
    array4[index2] |= mask;
  }
  function _clear(index2, mask) {
    array4[index2] &= mask;
  }
  return {
    array: array4,
    get: (x2, y2) => {
      const index2 = y2 * w3 + x2;
      return array4[index2 >>> DIV] & 1 << (index2 & MOD2);
    },
    set: (x2, y2) => {
      const index2 = y2 * w3 + x2;
      _set(index2 >>> DIV, 1 << (index2 & MOD2));
    },
    clear: (x2, y2) => {
      const index2 = y2 * w3 + x2;
      _clear(index2 >>> DIV, ~(1 << (index2 & MOD2)));
    },
    getRange: (x2, y2, x22, y22) => {
      let r = y22, start, end, indexStart, indexEnd;
      for (; r >= y2; --r) {
        start = r * w3 + x2;
        end = r * w3 + x22;
        indexStart = start >>> DIV;
        indexEnd = end >>> DIV;
        if (indexStart === indexEnd) {
          if (array4[indexStart] & RIGHT0[start & MOD2] & RIGHT1[(end & MOD2) + 1]) {
            return true;
          }
        } else {
          if (array4[indexStart] & RIGHT0[start & MOD2])
            return true;
          if (array4[indexEnd] & RIGHT1[(end & MOD2) + 1])
            return true;
          for (let i = indexStart + 1; i < indexEnd; ++i) {
            if (array4[i])
              return true;
          }
        }
      }
      return false;
    },
    setRange: (x2, y2, x22, y22) => {
      let start, end, indexStart, indexEnd, i;
      for (; y2 <= y22; ++y2) {
        start = y2 * w3 + x2;
        end = y2 * w3 + x22;
        indexStart = start >>> DIV;
        indexEnd = end >>> DIV;
        if (indexStart === indexEnd) {
          _set(indexStart, RIGHT0[start & MOD2] & RIGHT1[(end & MOD2) + 1]);
        } else {
          _set(indexStart, RIGHT0[start & MOD2]);
          _set(indexEnd, RIGHT1[(end & MOD2) + 1]);
          for (i = indexStart + 1; i < indexEnd; ++i)
            _set(i, 4294967295);
        }
      }
    },
    clearRange: (x2, y2, x22, y22) => {
      let start, end, indexStart, indexEnd, i;
      for (; y2 <= y22; ++y2) {
        start = y2 * w3 + x2;
        end = y2 * w3 + x22;
        indexStart = start >>> DIV;
        indexEnd = end >>> DIV;
        if (indexStart === indexEnd) {
          _clear(indexStart, RIGHT1[start & MOD2] | RIGHT0[(end & MOD2) + 1]);
        } else {
          _clear(indexStart, RIGHT1[start & MOD2]);
          _clear(indexEnd, RIGHT0[(end & MOD2) + 1]);
          for (i = indexStart + 1; i < indexEnd; ++i)
            _clear(i, 0);
        }
      }
    },
    outOfBounds: (x2, y2, x22, y22) => x2 < 0 || y2 < 0 || y22 >= h2 || x22 >= w3
  };
}
function scaler(width2, height2, padding2) {
  const ratio = Math.max(1, Math.sqrt(width2 * height2 / 1e6)), w3 = ~~((width2 + 2 * padding2 + ratio) / ratio), h2 = ~~((height2 + 2 * padding2 + ratio) / ratio), scale6 = (_) => ~~((_ + padding2) / ratio);
  scale6.invert = (_) => _ * ratio - padding2;
  scale6.bitmap = () => Bitmap(w3, h2);
  scale6.ratio = ratio;
  scale6.padding = padding2;
  scale6.width = width2;
  scale6.height = height2;
  return scale6;
}
function placeAreaLabelNaive($2, bitmaps, avoidBaseMark, markIndex) {
  const width2 = $2.width, height2 = $2.height;
  return function(d) {
    const items = d.datum.datum.items[markIndex].items, n = items.length, textHeight = d.datum.fontSize, textWidth = textMetrics.width(d.datum, d.datum.text);
    let maxAreaWidth = 0, x12, x2, y12, y2, x3, y3, areaWidth;
    for (let i = 0; i < n; ++i) {
      x12 = items[i].x;
      y12 = items[i].y;
      x2 = items[i].x2 === void 0 ? x12 : items[i].x2;
      y2 = items[i].y2 === void 0 ? y12 : items[i].y2;
      x3 = (x12 + x2) / 2;
      y3 = (y12 + y2) / 2;
      areaWidth = Math.abs(x2 - x12 + y2 - y12);
      if (areaWidth >= maxAreaWidth) {
        maxAreaWidth = areaWidth;
        d.x = x3;
        d.y = y3;
      }
    }
    x3 = textWidth / 2;
    y3 = textHeight / 2;
    x12 = d.x - x3;
    x2 = d.x + x3;
    y12 = d.y - y3;
    y2 = d.y + y3;
    d.align = "center";
    if (x12 < 0 && x2 <= width2) {
      d.align = "left";
    } else if (0 <= x12 && width2 < x2) {
      d.align = "right";
    }
    d.baseline = "middle";
    if (y12 < 0 && y2 <= height2) {
      d.baseline = "top";
    } else if (0 <= y12 && height2 < y2) {
      d.baseline = "bottom";
    }
    return true;
  };
}
function outOfBounds(x2, y2, textWidth, textHeight, width2, height2) {
  let r = textWidth / 2;
  return x2 - r < 0 || x2 + r > width2 || y2 - (r = textHeight / 2) < 0 || y2 + r > height2;
}
function collision($2, x2, y2, textHeight, textWidth, h2, bm0, bm1) {
  const w3 = textWidth * h2 / (textHeight * 2), x12 = $2(x2 - w3), x22 = $2(x2 + w3), y12 = $2(y2 - (h2 = h2 / 2)), y22 = $2(y2 + h2);
  return bm0.outOfBounds(x12, y12, x22, y22) || bm0.getRange(x12, y12, x22, y22) || bm1 && bm1.getRange(x12, y12, x22, y22);
}
function placeAreaLabelReducedSearch($2, bitmaps, avoidBaseMark, markIndex) {
  const width2 = $2.width, height2 = $2.height, bm0 = bitmaps[0], bm1 = bitmaps[1];
  function tryLabel(_x, _y, maxSize, textWidth, textHeight) {
    const x2 = $2.invert(_x), y2 = $2.invert(_y);
    let lo = maxSize, hi = height2, mid;
    if (!outOfBounds(x2, y2, textWidth, textHeight, width2, height2) && !collision($2, x2, y2, textHeight, textWidth, lo, bm0, bm1) && !collision($2, x2, y2, textHeight, textWidth, textHeight, bm0, null)) {
      while (hi - lo >= 1) {
        mid = (lo + hi) / 2;
        if (collision($2, x2, y2, textHeight, textWidth, mid, bm0, bm1)) {
          hi = mid;
        } else {
          lo = mid;
        }
      }
      if (lo > maxSize) {
        return [x2, y2, lo, true];
      }
    }
  }
  return function(d) {
    const items = d.datum.datum.items[markIndex].items, n = items.length, textHeight = d.datum.fontSize, textWidth = textMetrics.width(d.datum, d.datum.text);
    let maxSize = avoidBaseMark ? textHeight : 0, labelPlaced = false, labelPlaced2 = false, maxAreaWidth = 0, x12, x2, y12, y2, x3, y3, _x, _y, _x1, _xMid, _x2, _y1, _yMid, _y2, areaWidth, result, swapTmp;
    for (let i = 0; i < n; ++i) {
      x12 = items[i].x;
      y12 = items[i].y;
      x2 = items[i].x2 === void 0 ? x12 : items[i].x2;
      y2 = items[i].y2 === void 0 ? y12 : items[i].y2;
      if (x12 > x2) {
        swapTmp = x12;
        x12 = x2;
        x2 = swapTmp;
      }
      if (y12 > y2) {
        swapTmp = y12;
        y12 = y2;
        y2 = swapTmp;
      }
      _x1 = $2(x12);
      _x2 = $2(x2);
      _xMid = ~~((_x1 + _x2) / 2);
      _y1 = $2(y12);
      _y2 = $2(y2);
      _yMid = ~~((_y1 + _y2) / 2);
      for (_x = _xMid; _x >= _x1; --_x) {
        for (_y = _yMid; _y >= _y1; --_y) {
          result = tryLabel(_x, _y, maxSize, textWidth, textHeight);
          if (result) {
            [d.x, d.y, maxSize, labelPlaced] = result;
          }
        }
      }
      for (_x = _xMid; _x <= _x2; ++_x) {
        for (_y = _yMid; _y <= _y2; ++_y) {
          result = tryLabel(_x, _y, maxSize, textWidth, textHeight);
          if (result) {
            [d.x, d.y, maxSize, labelPlaced] = result;
          }
        }
      }
      if (!labelPlaced && !avoidBaseMark) {
        areaWidth = Math.abs(x2 - x12 + y2 - y12);
        x3 = (x12 + x2) / 2;
        y3 = (y12 + y2) / 2;
        if (areaWidth >= maxAreaWidth && !outOfBounds(x3, y3, textWidth, textHeight, width2, height2) && !collision($2, x3, y3, textHeight, textWidth, textHeight, bm0, null)) {
          maxAreaWidth = areaWidth;
          d.x = x3;
          d.y = y3;
          labelPlaced2 = true;
        }
      }
    }
    if (labelPlaced || labelPlaced2) {
      x3 = textWidth / 2;
      y3 = textHeight / 2;
      bm0.setRange($2(d.x - x3), $2(d.y - y3), $2(d.x + x3), $2(d.y + y3));
      d.align = "center";
      d.baseline = "middle";
      return true;
    } else {
      return false;
    }
  };
}
var X_DIR = [-1, -1, 1, 1];
var Y_DIR = [-1, 1, -1, 1];
function placeAreaLabelFloodFill($2, bitmaps, avoidBaseMark, markIndex) {
  const width2 = $2.width, height2 = $2.height, bm0 = bitmaps[0], bm1 = bitmaps[1], bm2 = $2.bitmap();
  return function(d) {
    const items = d.datum.datum.items[markIndex].items, n = items.length, textHeight = d.datum.fontSize, textWidth = textMetrics.width(d.datum, d.datum.text), stack = [];
    let maxSize = avoidBaseMark ? textHeight : 0, labelPlaced = false, labelPlaced2 = false, maxAreaWidth = 0, x12, x2, y12, y2, x3, y3, _x, _y, lo, hi, mid, areaWidth;
    for (let i = 0; i < n; ++i) {
      x12 = items[i].x;
      y12 = items[i].y;
      x2 = items[i].x2 === void 0 ? x12 : items[i].x2;
      y2 = items[i].y2 === void 0 ? y12 : items[i].y2;
      stack.push([$2((x12 + x2) / 2), $2((y12 + y2) / 2)]);
      while (stack.length) {
        [_x, _y] = stack.pop();
        if (bm0.get(_x, _y) || bm1.get(_x, _y) || bm2.get(_x, _y))
          continue;
        bm2.set(_x, _y);
        for (let j = 0; j < 4; ++j) {
          x3 = _x + X_DIR[j];
          y3 = _y + Y_DIR[j];
          if (!bm2.outOfBounds(x3, y3, x3, y3))
            stack.push([x3, y3]);
        }
        x3 = $2.invert(_x);
        y3 = $2.invert(_y);
        lo = maxSize;
        hi = height2;
        if (!outOfBounds(x3, y3, textWidth, textHeight, width2, height2) && !collision($2, x3, y3, textHeight, textWidth, lo, bm0, bm1) && !collision($2, x3, y3, textHeight, textWidth, textHeight, bm0, null)) {
          while (hi - lo >= 1) {
            mid = (lo + hi) / 2;
            if (collision($2, x3, y3, textHeight, textWidth, mid, bm0, bm1)) {
              hi = mid;
            } else {
              lo = mid;
            }
          }
          if (lo > maxSize) {
            d.x = x3;
            d.y = y3;
            maxSize = lo;
            labelPlaced = true;
          }
        }
      }
      if (!labelPlaced && !avoidBaseMark) {
        areaWidth = Math.abs(x2 - x12 + y2 - y12);
        x3 = (x12 + x2) / 2;
        y3 = (y12 + y2) / 2;
        if (areaWidth >= maxAreaWidth && !outOfBounds(x3, y3, textWidth, textHeight, width2, height2) && !collision($2, x3, y3, textHeight, textWidth, textHeight, bm0, null)) {
          maxAreaWidth = areaWidth;
          d.x = x3;
          d.y = y3;
          labelPlaced2 = true;
        }
      }
    }
    if (labelPlaced || labelPlaced2) {
      x3 = textWidth / 2;
      y3 = textHeight / 2;
      bm0.setRange($2(d.x - x3), $2(d.y - y3), $2(d.x + x3), $2(d.y + y3));
      d.align = "center";
      d.baseline = "middle";
      return true;
    } else {
      return false;
    }
  };
}
var Aligns = ["right", "center", "left"];
var Baselines = ["bottom", "middle", "top"];
function placeMarkLabel($2, bitmaps, anchors, offsets2) {
  const width2 = $2.width, height2 = $2.height, bm0 = bitmaps[0], bm1 = bitmaps[1], n = offsets2.length;
  return function(d) {
    const boundary = d.boundary, textHeight = d.datum.fontSize;
    if (boundary[2] < 0 || boundary[5] < 0 || boundary[0] > width2 || boundary[3] > height2) {
      return false;
    }
    let textWidth = d.textWidth ?? 0, dx, dy, isInside, sizeFactor, insideFactor, x12, x2, y12, y2, xc, yc, _x1, _x2, _y1, _y2;
    for (let i = 0; i < n; ++i) {
      dx = (anchors[i] & 3) - 1;
      dy = (anchors[i] >>> 2 & 3) - 1;
      isInside = dx === 0 && dy === 0 || offsets2[i] < 0;
      sizeFactor = dx && dy ? Math.SQRT1_2 : 1;
      insideFactor = offsets2[i] < 0 ? -1 : 1;
      x12 = boundary[1 + dx] + offsets2[i] * dx * sizeFactor;
      yc = boundary[4 + dy] + insideFactor * textHeight * dy / 2 + offsets2[i] * dy * sizeFactor;
      y12 = yc - textHeight / 2;
      y2 = yc + textHeight / 2;
      _x1 = $2(x12);
      _y1 = $2(y12);
      _y2 = $2(y2);
      if (!textWidth) {
        if (!test(_x1, _x1, _y1, _y2, bm0, bm1, x12, x12, y12, y2, boundary, isInside)) {
          continue;
        } else {
          textWidth = textMetrics.width(d.datum, d.datum.text);
        }
      }
      xc = x12 + insideFactor * textWidth * dx / 2;
      x12 = xc - textWidth / 2;
      x2 = xc + textWidth / 2;
      _x1 = $2(x12);
      _x2 = $2(x2);
      if (test(_x1, _x2, _y1, _y2, bm0, bm1, x12, x2, y12, y2, boundary, isInside)) {
        d.x = !dx ? xc : dx * insideFactor < 0 ? x2 : x12;
        d.y = !dy ? yc : dy * insideFactor < 0 ? y2 : y12;
        d.align = Aligns[dx * insideFactor + 1];
        d.baseline = Baselines[dy * insideFactor + 1];
        bm0.setRange(_x1, _y1, _x2, _y2);
        return true;
      }
    }
    return false;
  };
}
function test(_x1, _x2, _y1, _y2, bm0, bm1, x12, x2, y12, y2, boundary, isInside) {
  return !(bm0.outOfBounds(_x1, _y1, _x2, _y2) || (isInside && bm1 || bm0).getRange(_x1, _y1, _x2, _y2));
}
var TOP = 0;
var MIDDLE = 4;
var BOTTOM = 8;
var LEFT = 0;
var CENTER = 1;
var RIGHT = 2;
var anchorCode = {
  "top-left": TOP + LEFT,
  "top": TOP + CENTER,
  "top-right": TOP + RIGHT,
  "left": MIDDLE + LEFT,
  "middle": MIDDLE + CENTER,
  "right": MIDDLE + RIGHT,
  "bottom-left": BOTTOM + LEFT,
  "bottom": BOTTOM + CENTER,
  "bottom-right": BOTTOM + RIGHT
};
var placeAreaLabel = {
  "naive": placeAreaLabelNaive,
  "reduced-search": placeAreaLabelReducedSearch,
  "floodfill": placeAreaLabelFloodFill
};
function labelLayout(texts, size, compare3, offset4, anchor, avoidMarks, avoidBaseMark, lineAnchor, markIndex, padding2, method2) {
  if (!texts.length)
    return texts;
  const positions = Math.max(offset4.length, anchor.length), offsets2 = getOffsets(offset4, positions), anchors = getAnchors(anchor, positions), marktype = markType(texts[0].datum), grouptype = marktype === "group" && texts[0].datum.items[markIndex].marktype, isGroupArea = grouptype === "area", boundary = markBoundary(marktype, grouptype, lineAnchor, markIndex), infPadding = padding2 === null || padding2 === Infinity, isNaiveGroupArea = isGroupArea && method2 === "naive";
  let maxTextWidth = -1, maxTextHeight = -1;
  const data3 = texts.map((d) => {
    const textWidth = infPadding ? textMetrics.width(d, d.text) : void 0;
    maxTextWidth = Math.max(maxTextWidth, textWidth);
    maxTextHeight = Math.max(maxTextHeight, d.fontSize);
    return {
      datum: d,
      opacity: 0,
      x: void 0,
      y: void 0,
      align: void 0,
      baseline: void 0,
      boundary: boundary(d),
      textWidth
    };
  });
  padding2 = padding2 === null || padding2 === Infinity ? Math.max(maxTextWidth, maxTextHeight) + Math.max(...offset4) : padding2;
  const $2 = scaler(size[0], size[1], padding2);
  let bitmaps;
  if (!isNaiveGroupArea) {
    if (compare3) {
      data3.sort((a, b2) => compare3(a.datum, b2.datum));
    }
    let labelInside = false;
    for (let i = 0; i < anchors.length && !labelInside; ++i) {
      labelInside = anchors[i] === 5 || offsets2[i] < 0;
    }
    const baseMark = (marktype && avoidBaseMark || isGroupArea) && texts.map((d) => d.datum);
    bitmaps = avoidMarks.length || baseMark ? markBitmaps($2, baseMark || [], avoidMarks, labelInside, isGroupArea) : baseBitmaps($2, avoidBaseMark && data3);
  }
  const place = isGroupArea ? placeAreaLabel[method2]($2, bitmaps, avoidBaseMark, markIndex) : placeMarkLabel($2, bitmaps, anchors, offsets2);
  data3.forEach((d) => d.opacity = +place(d));
  return data3;
}
function getOffsets(_, count) {
  const offsets2 = new Float64Array(count), n = _.length;
  for (let i = 0; i < n; ++i)
    offsets2[i] = _[i] || 0;
  for (let i = n; i < count; ++i)
    offsets2[i] = offsets2[n - 1];
  return offsets2;
}
function getAnchors(_, count) {
  const anchors = new Int8Array(count), n = _.length;
  for (let i = 0; i < n; ++i)
    anchors[i] |= anchorCode[_[i]];
  for (let i = n; i < count; ++i)
    anchors[i] = anchors[n - 1];
  return anchors;
}
function markType(item) {
  return item && item.mark && item.mark.marktype;
}
function markBoundary(marktype, grouptype, lineAnchor, markIndex) {
  const xy = (d) => [d.x, d.x, d.x, d.y, d.y, d.y];
  if (!marktype) {
    return xy;
  } else if (marktype === "line" || marktype === "area") {
    return (d) => xy(d.datum);
  } else if (grouptype === "line") {
    return (d) => {
      const items = d.datum.items[markIndex].items;
      return xy(items.length ? items[lineAnchor === "start" ? 0 : items.length - 1] : {
        x: NaN,
        y: NaN
      });
    };
  } else {
    return (d) => {
      const b2 = d.datum.bounds;
      return [b2.x1, (b2.x1 + b2.x2) / 2, b2.x2, b2.y1, (b2.y1 + b2.y2) / 2, b2.y2];
    };
  }
}
var Output3 = ["x", "y", "opacity", "align", "baseline"];
var Anchors = ["top-left", "left", "bottom-left", "top", "bottom", "top-right", "right", "bottom-right"];
function Label(params2) {
  Transform.call(this, null, params2);
}
Label.Definition = {
  type: "Label",
  metadata: {
    modifies: true
  },
  params: [{
    name: "size",
    type: "number",
    array: true,
    length: 2,
    required: true
  }, {
    name: "sort",
    type: "compare"
  }, {
    name: "anchor",
    type: "string",
    array: true,
    default: Anchors
  }, {
    name: "offset",
    type: "number",
    array: true,
    default: [1]
  }, {
    name: "padding",
    type: "number",
    default: 0,
    null: true
  }, {
    name: "lineAnchor",
    type: "string",
    values: ["start", "end"],
    default: "end"
  }, {
    name: "markIndex",
    type: "number",
    default: 0
  }, {
    name: "avoidBaseMark",
    type: "boolean",
    default: true
  }, {
    name: "avoidMarks",
    type: "data",
    array: true
  }, {
    name: "method",
    type: "string",
    default: "naive"
  }, {
    name: "as",
    type: "string",
    array: true,
    length: Output3.length,
    default: Output3
  }]
};
inherits(Label, Transform, {
  transform(_, pulse2) {
    function modp(param2) {
      const p = _[param2];
      return isFunction(p) && pulse2.modified(p.fields);
    }
    const mod = _.modified();
    if (!(mod || pulse2.changed(pulse2.ADD_REM) || modp("sort")))
      return;
    if (!_.size || _.size.length !== 2) {
      error("Size parameter should be specified as a [width, height] array.");
    }
    const as = _.as || Output3;
    labelLayout(pulse2.materialize(pulse2.SOURCE).source || [], _.size, _.sort, array(_.offset == null ? 1 : _.offset), array(_.anchor || Anchors), _.avoidMarks || [], _.avoidBaseMark !== false, _.lineAnchor || "end", _.markIndex || 0, _.padding === void 0 ? 0 : _.padding, _.method || "naive").forEach((l) => {
      const t = l.datum;
      t[as[0]] = l.x;
      t[as[1]] = l.y;
      t[as[2]] = l.opacity;
      t[as[3]] = l.align;
      t[as[4]] = l.baseline;
    });
    return pulse2.reflow(mod).modifies(as);
  }
});

// node_modules/vega-regression/build/vega-regression.module.js
var vega_regression_module_exports = {};
__export(vega_regression_module_exports, {
  loess: () => Loess,
  regression: () => Regression
});
function partition4(data3, groupby) {
  var groups = [], get5 = function(f) {
    return f(t);
  }, map2, i, n, t, k2, g;
  if (groupby == null) {
    groups.push(data3);
  } else {
    for (map2 = {}, i = 0, n = data3.length; i < n; ++i) {
      t = data3[i];
      k2 = groupby.map(get5);
      g = map2[k2];
      if (!g) {
        map2[k2] = g = [];
        g.dims = k2;
        groups.push(g);
      }
      g.push(t);
    }
  }
  return groups;
}
function Loess(params2) {
  Transform.call(this, null, params2);
}
Loess.Definition = {
  "type": "Loess",
  "metadata": {
    "generates": true
  },
  "params": [{
    "name": "x",
    "type": "field",
    "required": true
  }, {
    "name": "y",
    "type": "field",
    "required": true
  }, {
    "name": "groupby",
    "type": "field",
    "array": true
  }, {
    "name": "bandwidth",
    "type": "number",
    "default": 0.3
  }, {
    "name": "as",
    "type": "string",
    "array": true
  }]
};
inherits(Loess, Transform, {
  transform(_, pulse2) {
    const out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS);
    if (!this.value || pulse2.changed() || _.modified()) {
      const source3 = pulse2.materialize(pulse2.SOURCE).source, groups = partition4(source3, _.groupby), names = (_.groupby || []).map(accessorName), m = names.length, as = _.as || [accessorName(_.x), accessorName(_.y)], values2 = [];
      groups.forEach((g) => {
        loess(g, _.x, _.y, _.bandwidth || 0.3).forEach((p) => {
          const t = {};
          for (let i = 0; i < m; ++i) {
            t[names[i]] = g.dims[i];
          }
          t[as[0]] = p[0];
          t[as[1]] = p[1];
          values2.push(ingest$1(t));
        });
      });
      if (this.value)
        out.rem = this.value;
      this.value = out.add = out.source = values2;
    }
    return out;
  }
});
var Methods2 = {
  constant: constant2,
  linear: linear2,
  log: log3,
  exp: exp2,
  pow: pow3,
  quad,
  poly
};
var degreesOfFreedom = (method2, order) => method2 === "poly" ? order : method2 === "quad" ? 2 : 1;
function Regression(params2) {
  Transform.call(this, null, params2);
}
Regression.Definition = {
  "type": "Regression",
  "metadata": {
    "generates": true
  },
  "params": [{
    "name": "x",
    "type": "field",
    "required": true
  }, {
    "name": "y",
    "type": "field",
    "required": true
  }, {
    "name": "groupby",
    "type": "field",
    "array": true
  }, {
    "name": "method",
    "type": "string",
    "default": "linear",
    "values": Object.keys(Methods2)
  }, {
    "name": "order",
    "type": "number",
    "default": 3
  }, {
    "name": "extent",
    "type": "number",
    "array": true,
    "length": 2
  }, {
    "name": "params",
    "type": "boolean",
    "default": false
  }, {
    "name": "as",
    "type": "string",
    "array": true
  }]
};
inherits(Regression, Transform, {
  transform(_, pulse2) {
    const out = pulse2.fork(pulse2.NO_SOURCE | pulse2.NO_FIELDS);
    if (!this.value || pulse2.changed() || _.modified()) {
      const source3 = pulse2.materialize(pulse2.SOURCE).source, groups = partition4(source3, _.groupby), names = (_.groupby || []).map(accessorName), method2 = _.method || "linear", order = _.order == null ? 3 : _.order, dof = degreesOfFreedom(method2, order), as = _.as || [accessorName(_.x), accessorName(_.y)], fit2 = Methods2[method2], values2 = [];
      let domain2 = _.extent;
      if (!has(Methods2, method2)) {
        error("Invalid regression method: " + method2);
      }
      if (domain2 != null) {
        if (method2 === "log" && domain2[0] <= 0) {
          pulse2.dataflow.warn("Ignoring extent with values <= 0 for log regression.");
          domain2 = null;
        }
      }
      groups.forEach((g) => {
        const n = g.length;
        if (n <= dof) {
          pulse2.dataflow.warn("Skipping regression with more parameters than data points.");
          return;
        }
        const model = fit2(g, _.x, _.y, order);
        if (_.params) {
          values2.push(ingest$1({
            keys: g.dims,
            coef: model.coef,
            rSquared: model.rSquared
          }));
          return;
        }
        const dom = domain2 || extent(g, _.x), add4 = (p) => {
          const t = {};
          for (let i = 0; i < names.length; ++i) {
            t[names[i]] = g.dims[i];
          }
          t[as[0]] = p[0];
          t[as[1]] = p[1];
          values2.push(ingest$1(t));
        };
        if (method2 === "linear" || method2 === "constant") {
          dom.forEach((x2) => add4([x2, model.predict(x2)]));
        } else {
          sampleCurve(model.predict, dom, 25, 200).forEach(add4);
        }
      });
      if (this.value)
        out.rem = this.value;
      this.value = out.add = out.source = values2;
    }
    return out;
  }
});

// node_modules/vega-voronoi/build/vega-voronoi.module.js
var vega_voronoi_module_exports = {};
__export(vega_voronoi_module_exports, {
  voronoi: () => Voronoi
});
function Voronoi(params2) {
  Transform.call(this, null, params2);
}
Voronoi.Definition = {
  "type": "Voronoi",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "x",
    "type": "field",
    "required": true
  }, {
    "name": "y",
    "type": "field",
    "required": true
  }, {
    "name": "size",
    "type": "number",
    "array": true,
    "length": 2
  }, {
    "name": "extent",
    "type": "array",
    "array": true,
    "length": 2,
    "default": [[-1e5, -1e5], [1e5, 1e5]],
    "content": {
      "type": "number",
      "array": true,
      "length": 2
    }
  }, {
    "name": "as",
    "type": "string",
    "default": "path"
  }]
};
var defaultExtent = [-1e5, -1e5, 1e5, 1e5];
inherits(Voronoi, Transform, {
  transform(_, pulse2) {
    const as = _.as || "path", data3 = pulse2.source;
    if (!data3 || !data3.length)
      return pulse2;
    let s = _.size;
    s = s ? [0, 0, s[0], s[1]] : (s = _.extent) ? [s[0][0], s[0][1], s[1][0], s[1][1]] : defaultExtent;
    const voronoi = this.value = Delaunay.from(data3, _.x, _.y).voronoi(s);
    for (let i = 0, n = data3.length; i < n; ++i) {
      const polygon = voronoi.cellPolygon(i);
      data3[i][as] = polygon && !isPoint(polygon) ? toPathString(polygon) : null;
    }
    return pulse2.reflow(_.modified()).modifies(as);
  }
});
function toPathString(p) {
  const x2 = p[0][0], y2 = p[0][1];
  let n = p.length - 1;
  for (; p[n][0] === x2 && p[n][1] === y2; --n)
    ;
  return "M" + p.slice(0, n + 1).join("L") + "Z";
}
function isPoint(p) {
  return p.length === 2 && p[0][0] === p[1][0] && p[0][1] === p[1][1];
}

// node_modules/vega-wordcloud/build/vega-wordcloud.module.js
var vega_wordcloud_module_exports = {};
__export(vega_wordcloud_module_exports, {
  wordcloud: () => Wordcloud
});
var cloudRadians = Math.PI / 180;
var cw = 1 << 11 >> 5;
var ch = 1 << 11;
function cloud() {
  var size = [256, 256], text2, font2, fontSize2, fontStyle, fontWeight, rotate2, padding2, spiral = archimedeanSpiral, words = [], random2 = Math.random, cloud2 = {};
  cloud2.layout = function() {
    var contextAndRatio = getContext2(domCanvas()), board = zeroArray((size[0] >> 5) * size[1]), bounds2 = null, n = words.length, i = -1, tags = [], data3 = words.map((d2) => ({
      text: text2(d2),
      font: font2(d2),
      style: fontStyle(d2),
      weight: fontWeight(d2),
      rotate: rotate2(d2),
      size: ~~(fontSize2(d2) + 1e-14),
      padding: padding2(d2),
      xoff: 0,
      yoff: 0,
      x1: 0,
      y1: 0,
      x0: 0,
      y0: 0,
      hasText: false,
      sprite: null,
      datum: d2
    })).sort((a, b2) => b2.size - a.size);
    while (++i < n) {
      var d = data3[i];
      d.x = size[0] * (random2() + 0.5) >> 1;
      d.y = size[1] * (random2() + 0.5) >> 1;
      cloudSprite(contextAndRatio, d, data3, i);
      if (d.hasText && place(board, d, bounds2)) {
        tags.push(d);
        if (bounds2)
          cloudBounds(bounds2, d);
        else
          bounds2 = [{
            x: d.x + d.x0,
            y: d.y + d.y0
          }, {
            x: d.x + d.x1,
            y: d.y + d.y1
          }];
        d.x -= size[0] >> 1;
        d.y -= size[1] >> 1;
      }
    }
    return tags;
  };
  function getContext2(canvas) {
    canvas.width = canvas.height = 1;
    var ratio = Math.sqrt(canvas.getContext("2d").getImageData(0, 0, 1, 1).data.length >> 2);
    canvas.width = (cw << 5) / ratio;
    canvas.height = ch / ratio;
    var context3 = canvas.getContext("2d");
    context3.fillStyle = context3.strokeStyle = "red";
    context3.textAlign = "center";
    return {
      context: context3,
      ratio
    };
  }
  function place(board, tag, bounds2) {
    var startX = tag.x, startY = tag.y, maxDelta = Math.sqrt(size[0] * size[0] + size[1] * size[1]), s = spiral(size), dt = random2() < 0.5 ? 1 : -1, t = -dt, dxdy, dx, dy;
    while (dxdy = s(t += dt)) {
      dx = ~~dxdy[0];
      dy = ~~dxdy[1];
      if (Math.min(Math.abs(dx), Math.abs(dy)) >= maxDelta)
        break;
      tag.x = startX + dx;
      tag.y = startY + dy;
      if (tag.x + tag.x0 < 0 || tag.y + tag.y0 < 0 || tag.x + tag.x1 > size[0] || tag.y + tag.y1 > size[1])
        continue;
      if (!bounds2 || !cloudCollide(tag, board, size[0])) {
        if (!bounds2 || collideRects(tag, bounds2)) {
          var sprite = tag.sprite, w3 = tag.width >> 5, sw = size[0] >> 5, lx2 = tag.x - (w3 << 4), sx = lx2 & 127, msx = 32 - sx, h2 = tag.y1 - tag.y0, x2 = (tag.y + tag.y0) * sw + (lx2 >> 5), last;
          for (var j = 0; j < h2; j++) {
            last = 0;
            for (var i = 0; i <= w3; i++) {
              board[x2 + i] |= last << msx | (i < w3 ? (last = sprite[j * w3 + i]) >>> sx : 0);
            }
            x2 += sw;
          }
          tag.sprite = null;
          return true;
        }
      }
    }
    return false;
  }
  cloud2.words = function(_) {
    if (arguments.length) {
      words = _;
      return cloud2;
    } else {
      return words;
    }
  };
  cloud2.size = function(_) {
    if (arguments.length) {
      size = [+_[0], +_[1]];
      return cloud2;
    } else {
      return size;
    }
  };
  cloud2.font = function(_) {
    if (arguments.length) {
      font2 = functor(_);
      return cloud2;
    } else {
      return font2;
    }
  };
  cloud2.fontStyle = function(_) {
    if (arguments.length) {
      fontStyle = functor(_);
      return cloud2;
    } else {
      return fontStyle;
    }
  };
  cloud2.fontWeight = function(_) {
    if (arguments.length) {
      fontWeight = functor(_);
      return cloud2;
    } else {
      return fontWeight;
    }
  };
  cloud2.rotate = function(_) {
    if (arguments.length) {
      rotate2 = functor(_);
      return cloud2;
    } else {
      return rotate2;
    }
  };
  cloud2.text = function(_) {
    if (arguments.length) {
      text2 = functor(_);
      return cloud2;
    } else {
      return text2;
    }
  };
  cloud2.spiral = function(_) {
    if (arguments.length) {
      spiral = spirals[_] || _;
      return cloud2;
    } else {
      return spiral;
    }
  };
  cloud2.fontSize = function(_) {
    if (arguments.length) {
      fontSize2 = functor(_);
      return cloud2;
    } else {
      return fontSize2;
    }
  };
  cloud2.padding = function(_) {
    if (arguments.length) {
      padding2 = functor(_);
      return cloud2;
    } else {
      return padding2;
    }
  };
  cloud2.random = function(_) {
    if (arguments.length) {
      random2 = _;
      return cloud2;
    } else {
      return random2;
    }
  };
  return cloud2;
}
function cloudSprite(contextAndRatio, d, data3, di) {
  if (d.sprite)
    return;
  var c = contextAndRatio.context, ratio = contextAndRatio.ratio;
  c.clearRect(0, 0, (cw << 5) / ratio, ch / ratio);
  var x2 = 0, y2 = 0, maxh = 0, n = data3.length, w3, w32, h2, i, j;
  --di;
  while (++di < n) {
    d = data3[di];
    c.save();
    c.font = d.style + " " + d.weight + " " + ~~((d.size + 1) / ratio) + "px " + d.font;
    w3 = c.measureText(d.text + "m").width * ratio;
    h2 = d.size << 1;
    if (d.rotate) {
      var sr = Math.sin(d.rotate * cloudRadians), cr2 = Math.cos(d.rotate * cloudRadians), wcr = w3 * cr2, wsr = w3 * sr, hcr = h2 * cr2, hsr = h2 * sr;
      w3 = Math.max(Math.abs(wcr + hsr), Math.abs(wcr - hsr)) + 31 >> 5 << 5;
      h2 = ~~Math.max(Math.abs(wsr + hcr), Math.abs(wsr - hcr));
    } else {
      w3 = w3 + 31 >> 5 << 5;
    }
    if (h2 > maxh)
      maxh = h2;
    if (x2 + w3 >= cw << 5) {
      x2 = 0;
      y2 += maxh;
      maxh = 0;
    }
    if (y2 + h2 >= ch)
      break;
    c.translate((x2 + (w3 >> 1)) / ratio, (y2 + (h2 >> 1)) / ratio);
    if (d.rotate)
      c.rotate(d.rotate * cloudRadians);
    c.fillText(d.text, 0, 0);
    if (d.padding) {
      c.lineWidth = 2 * d.padding;
      c.strokeText(d.text, 0, 0);
    }
    c.restore();
    d.width = w3;
    d.height = h2;
    d.xoff = x2;
    d.yoff = y2;
    d.x1 = w3 >> 1;
    d.y1 = h2 >> 1;
    d.x0 = -d.x1;
    d.y0 = -d.y1;
    d.hasText = true;
    x2 += w3;
  }
  var pixels = c.getImageData(0, 0, (cw << 5) / ratio, ch / ratio).data, sprite = [];
  while (--di >= 0) {
    d = data3[di];
    if (!d.hasText)
      continue;
    w3 = d.width;
    w32 = w3 >> 5;
    h2 = d.y1 - d.y0;
    for (i = 0; i < h2 * w32; i++)
      sprite[i] = 0;
    x2 = d.xoff;
    if (x2 == null)
      return;
    y2 = d.yoff;
    var seen = 0, seenRow = -1;
    for (j = 0; j < h2; j++) {
      for (i = 0; i < w3; i++) {
        var k2 = w32 * j + (i >> 5), m = pixels[(y2 + j) * (cw << 5) + (x2 + i) << 2] ? 1 << 31 - i % 32 : 0;
        sprite[k2] |= m;
        seen |= m;
      }
      if (seen)
        seenRow = j;
      else {
        d.y0++;
        h2--;
        j--;
        y2++;
      }
    }
    d.y1 = d.y0 + seenRow;
    d.sprite = sprite.slice(0, (d.y1 - d.y0) * w32);
  }
}
function cloudCollide(tag, board, sw) {
  sw >>= 5;
  var sprite = tag.sprite, w3 = tag.width >> 5, lx2 = tag.x - (w3 << 4), sx = lx2 & 127, msx = 32 - sx, h2 = tag.y1 - tag.y0, x2 = (tag.y + tag.y0) * sw + (lx2 >> 5), last;
  for (var j = 0; j < h2; j++) {
    last = 0;
    for (var i = 0; i <= w3; i++) {
      if ((last << msx | (i < w3 ? (last = sprite[j * w3 + i]) >>> sx : 0)) & board[x2 + i])
        return true;
    }
    x2 += sw;
  }
  return false;
}
function cloudBounds(bounds2, d) {
  var b0 = bounds2[0], b1 = bounds2[1];
  if (d.x + d.x0 < b0.x)
    b0.x = d.x + d.x0;
  if (d.y + d.y0 < b0.y)
    b0.y = d.y + d.y0;
  if (d.x + d.x1 > b1.x)
    b1.x = d.x + d.x1;
  if (d.y + d.y1 > b1.y)
    b1.y = d.y + d.y1;
}
function collideRects(a, b2) {
  return a.x + a.x1 > b2[0].x && a.x + a.x0 < b2[1].x && a.y + a.y1 > b2[0].y && a.y + a.y0 < b2[1].y;
}
function archimedeanSpiral(size) {
  var e = size[0] / size[1];
  return function(t) {
    return [e * (t *= 0.1) * Math.cos(t), t * Math.sin(t)];
  };
}
function rectangularSpiral(size) {
  var dy = 4, dx = dy * size[0] / size[1], x2 = 0, y2 = 0;
  return function(t) {
    var sign2 = t < 0 ? -1 : 1;
    switch (Math.sqrt(1 + 4 * sign2 * t) - sign2 & 3) {
      case 0:
        x2 += dx;
        break;
      case 1:
        y2 += dy;
        break;
      case 2:
        x2 -= dx;
        break;
      default:
        y2 -= dy;
        break;
    }
    return [x2, y2];
  };
}
function zeroArray(n) {
  var a = [], i = -1;
  while (++i < n)
    a[i] = 0;
  return a;
}
function functor(d) {
  return typeof d === "function" ? d : function() {
    return d;
  };
}
var spirals = {
  archimedean: archimedeanSpiral,
  rectangular: rectangularSpiral
};
var Output4 = ["x", "y", "font", "fontSize", "fontStyle", "fontWeight", "angle"];
var Params2 = ["text", "font", "rotate", "fontSize", "fontStyle", "fontWeight"];
function Wordcloud(params2) {
  Transform.call(this, cloud(), params2);
}
Wordcloud.Definition = {
  "type": "Wordcloud",
  "metadata": {
    "modifies": true
  },
  "params": [{
    "name": "size",
    "type": "number",
    "array": true,
    "length": 2
  }, {
    "name": "font",
    "type": "string",
    "expr": true,
    "default": "sans-serif"
  }, {
    "name": "fontStyle",
    "type": "string",
    "expr": true,
    "default": "normal"
  }, {
    "name": "fontWeight",
    "type": "string",
    "expr": true,
    "default": "normal"
  }, {
    "name": "fontSize",
    "type": "number",
    "expr": true,
    "default": 14
  }, {
    "name": "fontSizeRange",
    "type": "number",
    "array": "nullable",
    "default": [10, 50]
  }, {
    "name": "rotate",
    "type": "number",
    "expr": true,
    "default": 0
  }, {
    "name": "text",
    "type": "field"
  }, {
    "name": "spiral",
    "type": "string",
    "values": ["archimedean", "rectangular"]
  }, {
    "name": "padding",
    "type": "number",
    "expr": true
  }, {
    "name": "as",
    "type": "string",
    "array": true,
    "length": 7,
    "default": Output4
  }]
};
inherits(Wordcloud, Transform, {
  transform(_, pulse2) {
    if (_.size && !(_.size[0] && _.size[1])) {
      error("Wordcloud size dimensions must be non-zero.");
    }
    function modp(param2) {
      const p = _[param2];
      return isFunction(p) && pulse2.modified(p.fields);
    }
    const mod = _.modified();
    if (!(mod || pulse2.changed(pulse2.ADD_REM) || Params2.some(modp)))
      return;
    const data3 = pulse2.materialize(pulse2.SOURCE).source, layout = this.value, as = _.as || Output4;
    let fontSize2 = _.fontSize || 14, range4;
    isFunction(fontSize2) ? range4 = _.fontSizeRange : fontSize2 = constant(fontSize2);
    if (range4) {
      const fsize = fontSize2, sizeScale = scale("sqrt")().domain(extent(data3, fsize)).range(range4);
      fontSize2 = (x2) => sizeScale(fsize(x2));
    }
    data3.forEach((t) => {
      t[as[0]] = NaN;
      t[as[1]] = NaN;
      t[as[3]] = 0;
    });
    const words = layout.words(data3).text(_.text).size(_.size || [500, 500]).padding(_.padding || 1).spiral(_.spiral || "archimedean").rotate(_.rotate || 0).font(_.font || "sans-serif").fontStyle(_.fontStyle || "normal").fontWeight(_.fontWeight || "normal").fontSize(fontSize2).random(random).layout();
    const size = layout.size(), dx = size[0] >> 1, dy = size[1] >> 1, n = words.length;
    for (let i = 0, w3, t; i < n; ++i) {
      w3 = words[i];
      t = w3.datum;
      t[as[0]] = w3.x + dx;
      t[as[1]] = w3.y + dy;
      t[as[2]] = w3.font;
      t[as[3]] = w3.size;
      t[as[4]] = w3.style;
      t[as[5]] = w3.weight;
      t[as[6]] = w3.rotate;
    }
    return pulse2.reflow(mod).modifies(as);
  }
});

// node_modules/vega-crossfilter/build/vega-crossfilter.module.js
var vega_crossfilter_module_exports = {};
__export(vega_crossfilter_module_exports, {
  crossfilter: () => CrossFilter,
  resolvefilter: () => ResolveFilter
});
var array8 = (n) => new Uint8Array(n);
var array16 = (n) => new Uint16Array(n);
var array32 = (n) => new Uint32Array(n);
function Bitmaps() {
  let width2 = 8, data3 = [], seen = array32(0), curr = array2(0, width2), prev = array2(0, width2);
  return {
    data: () => data3,
    seen: () => seen = lengthen(seen, data3.length),
    add(array4) {
      for (let i = 0, j = data3.length, n = array4.length, t; i < n; ++i) {
        t = array4[i];
        t._index = j++;
        data3.push(t);
      }
    },
    remove(num, map2) {
      const n = data3.length, copy2 = Array(n - num), reindex = data3;
      let t, i, j;
      for (i = 0; !map2[i] && i < n; ++i) {
        copy2[i] = data3[i];
        reindex[i] = i;
      }
      for (j = i; i < n; ++i) {
        t = data3[i];
        if (!map2[i]) {
          reindex[i] = j;
          curr[j] = curr[i];
          prev[j] = prev[i];
          copy2[j] = t;
          t._index = j++;
        } else {
          reindex[i] = -1;
        }
        curr[i] = 0;
      }
      data3 = copy2;
      return reindex;
    },
    size: () => data3.length,
    curr: () => curr,
    prev: () => prev,
    reset: (k2) => prev[k2] = curr[k2],
    all: () => width2 < 257 ? 255 : width2 < 65537 ? 65535 : 4294967295,
    set(k2, one3) {
      curr[k2] |= one3;
    },
    clear(k2, one3) {
      curr[k2] &= ~one3;
    },
    resize(n, m) {
      const k2 = curr.length;
      if (n > k2 || m > width2) {
        width2 = Math.max(m, width2);
        curr = array2(n, width2, curr);
        prev = array2(n, width2);
      }
    }
  };
}
function lengthen(array4, length2, copy2) {
  if (array4.length >= length2)
    return array4;
  copy2 = copy2 || new array4.constructor(length2);
  copy2.set(array4);
  return copy2;
}
function array2(n, m, array4) {
  const copy2 = (m < 257 ? array8 : m < 65537 ? array16 : array32)(n);
  if (array4)
    copy2.set(array4);
  return copy2;
}
function Dimension(index2, i, query) {
  const bit = 1 << i;
  return {
    one: bit,
    zero: ~bit,
    range: query.slice(),
    bisect: index2.bisect,
    index: index2.index,
    size: index2.size,
    onAdd(added, curr) {
      const dim = this, range4 = dim.bisect(dim.range, added.value), idx = added.index, lo = range4[0], hi = range4[1], n1 = idx.length;
      let i2;
      for (i2 = 0; i2 < lo; ++i2)
        curr[idx[i2]] |= bit;
      for (i2 = hi; i2 < n1; ++i2)
        curr[idx[i2]] |= bit;
      return dim;
    }
  };
}
function SortedIndex() {
  let index2 = array32(0), value3 = [], size = 0;
  function insert2(key2, data3, base2) {
    if (!data3.length)
      return [];
    const n0 = size, n1 = data3.length, addi = array32(n1);
    let addv = Array(n1), oldv, oldi, i;
    for (i = 0; i < n1; ++i) {
      addv[i] = key2(data3[i]);
      addi[i] = i;
    }
    addv = sort(addv, addi);
    if (n0) {
      oldv = value3;
      oldi = index2;
      value3 = Array(n0 + n1);
      index2 = array32(n0 + n1);
      merge3(base2, oldv, oldi, n0, addv, addi, n1, value3, index2);
    } else {
      if (base2 > 0)
        for (i = 0; i < n1; ++i) {
          addi[i] += base2;
        }
      value3 = addv;
      index2 = addi;
    }
    size = n0 + n1;
    return {
      index: addi,
      value: addv
    };
  }
  function remove2(num, map2) {
    const n = size;
    let idx, i, j;
    for (i = 0; !map2[index2[i]] && i < n; ++i)
      ;
    for (j = i; i < n; ++i) {
      if (!map2[idx = index2[i]]) {
        index2[j] = idx;
        value3[j] = value3[i];
        ++j;
      }
    }
    size = n - num;
  }
  function reindex(map2) {
    for (let i = 0, n = size; i < n; ++i) {
      index2[i] = map2[index2[i]];
    }
  }
  function bisect2(range4, array4) {
    let n;
    if (array4) {
      n = array4.length;
    } else {
      array4 = value3;
      n = size;
    }
    return [bisectLeft(array4, range4[0], 0, n), bisectRight(array4, range4[1], 0, n)];
  }
  return {
    insert: insert2,
    remove: remove2,
    bisect: bisect2,
    reindex,
    index: () => index2,
    size: () => size
  };
}
function sort(values2, index2) {
  values2.sort.call(index2, (a, b2) => {
    const x2 = values2[a], y2 = values2[b2];
    return x2 < y2 ? -1 : x2 > y2 ? 1 : 0;
  });
  return permute(values2, index2);
}
function merge3(base2, value0, index0, n0, value1, index1, n1, value3, index2) {
  let i0 = 0, i1 = 0, i;
  for (i = 0; i0 < n0 && i1 < n1; ++i) {
    if (value0[i0] < value1[i1]) {
      value3[i] = value0[i0];
      index2[i] = index0[i0++];
    } else {
      value3[i] = value1[i1];
      index2[i] = index1[i1++] + base2;
    }
  }
  for (; i0 < n0; ++i0, ++i) {
    value3[i] = value0[i0];
    index2[i] = index0[i0];
  }
  for (; i1 < n1; ++i1, ++i) {
    value3[i] = value1[i1];
    index2[i] = index1[i1] + base2;
  }
}
function CrossFilter(params2) {
  Transform.call(this, Bitmaps(), params2);
  this._indices = null;
  this._dims = null;
}
CrossFilter.Definition = {
  "type": "CrossFilter",
  "metadata": {},
  "params": [{
    "name": "fields",
    "type": "field",
    "array": true,
    "required": true
  }, {
    "name": "query",
    "type": "array",
    "array": true,
    "required": true,
    "content": {
      "type": "number",
      "array": true,
      "length": 2
    }
  }]
};
inherits(CrossFilter, Transform, {
  transform(_, pulse2) {
    if (!this._dims) {
      return this.init(_, pulse2);
    } else {
      var init2 = _.modified("fields") || _.fields.some((f) => pulse2.modified(f.fields));
      return init2 ? this.reinit(_, pulse2) : this.eval(_, pulse2);
    }
  },
  init(_, pulse2) {
    const fields = _.fields, query = _.query, indices = this._indices = {}, dims = this._dims = [], m = query.length;
    let i = 0, key2, index2;
    for (; i < m; ++i) {
      key2 = fields[i].fname;
      index2 = indices[key2] || (indices[key2] = SortedIndex());
      dims.push(Dimension(index2, i, query[i]));
    }
    return this.eval(_, pulse2);
  },
  reinit(_, pulse2) {
    const output3 = pulse2.materialize().fork(), fields = _.fields, query = _.query, indices = this._indices, dims = this._dims, bits = this.value, curr = bits.curr(), prev = bits.prev(), all = bits.all(), out = output3.rem = output3.add, mod = output3.mod, m = query.length, adds = {};
    let add4, index2, key2, mods, remMap, modMap, i, n, f;
    prev.set(curr);
    if (pulse2.rem.length) {
      remMap = this.remove(_, pulse2, output3);
    }
    if (pulse2.add.length) {
      bits.add(pulse2.add);
    }
    if (pulse2.mod.length) {
      modMap = {};
      for (mods = pulse2.mod, i = 0, n = mods.length; i < n; ++i) {
        modMap[mods[i]._index] = 1;
      }
    }
    for (i = 0; i < m; ++i) {
      f = fields[i];
      if (!dims[i] || _.modified("fields", i) || pulse2.modified(f.fields)) {
        key2 = f.fname;
        if (!(add4 = adds[key2])) {
          indices[key2] = index2 = SortedIndex();
          adds[key2] = add4 = index2.insert(f, pulse2.source, 0);
        }
        dims[i] = Dimension(index2, i, query[i]).onAdd(add4, curr);
      }
    }
    for (i = 0, n = bits.data().length; i < n; ++i) {
      if (remMap[i]) {
        continue;
      } else if (prev[i] !== curr[i]) {
        out.push(i);
      } else if (modMap[i] && curr[i] !== all) {
        mod.push(i);
      }
    }
    bits.mask = (1 << m) - 1;
    return output3;
  },
  eval(_, pulse2) {
    const output3 = pulse2.materialize().fork(), m = this._dims.length;
    let mask = 0;
    if (pulse2.rem.length) {
      this.remove(_, pulse2, output3);
      mask |= (1 << m) - 1;
    }
    if (_.modified("query") && !_.modified("fields")) {
      mask |= this.update(_, pulse2, output3);
    }
    if (pulse2.add.length) {
      this.insert(_, pulse2, output3);
      mask |= (1 << m) - 1;
    }
    if (pulse2.mod.length) {
      this.modify(pulse2, output3);
      mask |= (1 << m) - 1;
    }
    this.value.mask = mask;
    return output3;
  },
  insert(_, pulse2, output3) {
    const tuples = pulse2.add, bits = this.value, dims = this._dims, indices = this._indices, fields = _.fields, adds = {}, out = output3.add, n = bits.size() + tuples.length, m = dims.length;
    let k2 = bits.size(), j, key2, add4;
    bits.resize(n, m);
    bits.add(tuples);
    const curr = bits.curr(), prev = bits.prev(), all = bits.all();
    for (j = 0; j < m; ++j) {
      key2 = fields[j].fname;
      add4 = adds[key2] || (adds[key2] = indices[key2].insert(fields[j], tuples, k2));
      dims[j].onAdd(add4, curr);
    }
    for (; k2 < n; ++k2) {
      prev[k2] = all;
      if (curr[k2] !== all)
        out.push(k2);
    }
  },
  modify(pulse2, output3) {
    const out = output3.mod, bits = this.value, curr = bits.curr(), all = bits.all(), tuples = pulse2.mod;
    let i, n, k2;
    for (i = 0, n = tuples.length; i < n; ++i) {
      k2 = tuples[i]._index;
      if (curr[k2] !== all)
        out.push(k2);
    }
  },
  remove(_, pulse2, output3) {
    const indices = this._indices, bits = this.value, curr = bits.curr(), prev = bits.prev(), all = bits.all(), map2 = {}, out = output3.rem, tuples = pulse2.rem;
    let i, n, k2, f;
    for (i = 0, n = tuples.length; i < n; ++i) {
      k2 = tuples[i]._index;
      map2[k2] = 1;
      prev[k2] = f = curr[k2];
      curr[k2] = all;
      if (f !== all)
        out.push(k2);
    }
    for (k2 in indices) {
      indices[k2].remove(n, map2);
    }
    this.reindex(pulse2, n, map2);
    return map2;
  },
  // reindex filters and indices after propagation completes
  reindex(pulse2, num, map2) {
    const indices = this._indices, bits = this.value;
    pulse2.runAfter(() => {
      const indexMap = bits.remove(num, map2);
      for (const key2 in indices)
        indices[key2].reindex(indexMap);
    });
  },
  update(_, pulse2, output3) {
    const dims = this._dims, query = _.query, stamp = pulse2.stamp, m = dims.length;
    let mask = 0, i, q;
    output3.filters = 0;
    for (q = 0; q < m; ++q) {
      if (_.modified("query", q)) {
        i = q;
        ++mask;
      }
    }
    if (mask === 1) {
      mask = dims[i].one;
      this.incrementOne(dims[i], query[i], output3.add, output3.rem);
    } else {
      for (q = 0, mask = 0; q < m; ++q) {
        if (!_.modified("query", q))
          continue;
        mask |= dims[q].one;
        this.incrementAll(dims[q], query[q], stamp, output3.add);
        output3.rem = output3.add;
      }
    }
    return mask;
  },
  incrementAll(dim, query, stamp, out) {
    const bits = this.value, seen = bits.seen(), curr = bits.curr(), prev = bits.prev(), index2 = dim.index(), old = dim.bisect(dim.range), range4 = dim.bisect(query), lo1 = range4[0], hi1 = range4[1], lo0 = old[0], hi0 = old[1], one3 = dim.one;
    let i, j, k2;
    if (lo1 < lo0) {
      for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {
        k2 = index2[i];
        if (seen[k2] !== stamp) {
          prev[k2] = curr[k2];
          seen[k2] = stamp;
          out.push(k2);
        }
        curr[k2] ^= one3;
      }
    } else if (lo1 > lo0) {
      for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {
        k2 = index2[i];
        if (seen[k2] !== stamp) {
          prev[k2] = curr[k2];
          seen[k2] = stamp;
          out.push(k2);
        }
        curr[k2] ^= one3;
      }
    }
    if (hi1 > hi0) {
      for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {
        k2 = index2[i];
        if (seen[k2] !== stamp) {
          prev[k2] = curr[k2];
          seen[k2] = stamp;
          out.push(k2);
        }
        curr[k2] ^= one3;
      }
    } else if (hi1 < hi0) {
      for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {
        k2 = index2[i];
        if (seen[k2] !== stamp) {
          prev[k2] = curr[k2];
          seen[k2] = stamp;
          out.push(k2);
        }
        curr[k2] ^= one3;
      }
    }
    dim.range = query.slice();
  },
  incrementOne(dim, query, add4, rem2) {
    const bits = this.value, curr = bits.curr(), index2 = dim.index(), old = dim.bisect(dim.range), range4 = dim.bisect(query), lo1 = range4[0], hi1 = range4[1], lo0 = old[0], hi0 = old[1], one3 = dim.one;
    let i, j, k2;
    if (lo1 < lo0) {
      for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {
        k2 = index2[i];
        curr[k2] ^= one3;
        add4.push(k2);
      }
    } else if (lo1 > lo0) {
      for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {
        k2 = index2[i];
        curr[k2] ^= one3;
        rem2.push(k2);
      }
    }
    if (hi1 > hi0) {
      for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {
        k2 = index2[i];
        curr[k2] ^= one3;
        add4.push(k2);
      }
    } else if (hi1 < hi0) {
      for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {
        k2 = index2[i];
        curr[k2] ^= one3;
        rem2.push(k2);
      }
    }
    dim.range = query.slice();
  }
});
function ResolveFilter(params2) {
  Transform.call(this, null, params2);
}
ResolveFilter.Definition = {
  "type": "ResolveFilter",
  "metadata": {},
  "params": [{
    "name": "ignore",
    "type": "number",
    "required": true,
    "description": "A bit mask indicating which filters to ignore."
  }, {
    "name": "filter",
    "type": "object",
    "required": true,
    "description": "Per-tuple filter bitmaps from a CrossFilter transform."
  }]
};
inherits(ResolveFilter, Transform, {
  transform(_, pulse2) {
    const ignore = ~(_.ignore || 0), bitmap = _.filter, mask = bitmap.mask;
    if ((mask & ignore) === 0)
      return pulse2.StopPropagation;
    const output3 = pulse2.fork(pulse2.ALL), data3 = bitmap.data(), curr = bitmap.curr(), prev = bitmap.prev(), pass = (k2) => !(curr[k2] & ignore) ? data3[k2] : null;
    output3.filter(output3.MOD, pass);
    if (!(mask & mask - 1)) {
      output3.filter(output3.ADD, pass);
      output3.filter(output3.REM, (k2) => (curr[k2] & ignore) === mask ? data3[k2] : null);
    } else {
      output3.filter(output3.ADD, (k2) => {
        const c = curr[k2] & ignore, f = !c && c ^ prev[k2] & ignore;
        return f ? data3[k2] : null;
      });
      output3.filter(output3.REM, (k2) => {
        const c = curr[k2] & ignore, f = c && !(c ^ (c ^ prev[k2] & ignore));
        return f ? data3[k2] : null;
      });
    }
    return output3.filter(output3.SOURCE, (t) => pass(t._index));
  }
});

// node_modules/vega-expression/build/vega-expression.module.js
var RawCode = "RawCode";
var Literal = "Literal";
var Property = "Property";
var Identifier2 = "Identifier";
var ArrayExpression = "ArrayExpression";
var BinaryExpression = "BinaryExpression";
var CallExpression = "CallExpression";
var ConditionalExpression = "ConditionalExpression";
var LogicalExpression = "LogicalExpression";
var MemberExpression = "MemberExpression";
var ObjectExpression = "ObjectExpression";
var UnaryExpression = "UnaryExpression";
function ASTNode(type2) {
  this.type = type2;
}
ASTNode.prototype.visit = function(visitor) {
  let c, i, n;
  if (visitor(this))
    return 1;
  for (c = children2(this), i = 0, n = c.length; i < n; ++i) {
    if (c[i].visit(visitor))
      return 1;
  }
};
function children2(node) {
  switch (node.type) {
    case ArrayExpression:
      return node.elements;
    case BinaryExpression:
    case LogicalExpression:
      return [node.left, node.right];
    case CallExpression:
      return [node.callee].concat(node.arguments);
    case ConditionalExpression:
      return [node.test, node.consequent, node.alternate];
    case MemberExpression:
      return [node.object, node.property];
    case ObjectExpression:
      return node.properties;
    case Property:
      return [node.key, node.value];
    case UnaryExpression:
      return [node.argument];
    case Identifier2:
    case Literal:
    case RawCode:
    default:
      return [];
  }
}
var TokenName;
var source2;
var index;
var length;
var lookahead;
var TokenBooleanLiteral = 1;
var TokenEOF = 2;
var TokenIdentifier = 3;
var TokenKeyword = 4;
var TokenNullLiteral = 5;
var TokenNumericLiteral = 6;
var TokenPunctuator = 7;
var TokenStringLiteral = 8;
var TokenRegularExpression = 9;
TokenName = {};
TokenName[TokenBooleanLiteral] = "Boolean";
TokenName[TokenEOF] = "<end>";
TokenName[TokenIdentifier] = "Identifier";
TokenName[TokenKeyword] = "Keyword";
TokenName[TokenNullLiteral] = "Null";
TokenName[TokenNumericLiteral] = "Numeric";
TokenName[TokenPunctuator] = "Punctuator";
TokenName[TokenStringLiteral] = "String";
TokenName[TokenRegularExpression] = "RegularExpression";
var SyntaxArrayExpression = "ArrayExpression";
var SyntaxBinaryExpression = "BinaryExpression";
var SyntaxCallExpression = "CallExpression";
var SyntaxConditionalExpression = "ConditionalExpression";
var SyntaxIdentifier = "Identifier";
var SyntaxLiteral = "Literal";
var SyntaxLogicalExpression = "LogicalExpression";
var SyntaxMemberExpression = "MemberExpression";
var SyntaxObjectExpression = "ObjectExpression";
var SyntaxProperty = "Property";
var SyntaxUnaryExpression = "UnaryExpression";
var MessageUnexpectedToken = "Unexpected token %0";
var MessageUnexpectedNumber = "Unexpected number";
var MessageUnexpectedString = "Unexpected string";
var MessageUnexpectedIdentifier = "Unexpected identifier";
var MessageUnexpectedReserved = "Unexpected reserved word";
var MessageUnexpectedEOS = "Unexpected end of input";
var MessageInvalidRegExp = "Invalid regular expression";
var MessageUnterminatedRegExp = "Invalid regular expression: missing /";
var MessageStrictOctalLiteral = "Octal literals are not allowed in strict mode.";
var MessageStrictDuplicateProperty = "Duplicate data property in object literal not allowed in strict mode";
var ILLEGAL = "ILLEGAL";
var DISABLED = "Disabled.";
var RegexNonAsciiIdentifierStart = new RegExp("[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B2\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]");
var RegexNonAsciiIdentifierPart = new RegExp("[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B2\\u08E4-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA69D\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2D\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]");
function assert(condition, message) {
  if (!condition) {
    throw new Error("ASSERT: " + message);
  }
}
function isDecimalDigit(ch2) {
  return ch2 >= 48 && ch2 <= 57;
}
function isHexDigit(ch2) {
  return "0123456789abcdefABCDEF".indexOf(ch2) >= 0;
}
function isOctalDigit(ch2) {
  return "01234567".indexOf(ch2) >= 0;
}
function isWhiteSpace(ch2) {
  return ch2 === 32 || ch2 === 9 || ch2 === 11 || ch2 === 12 || ch2 === 160 || ch2 >= 5760 && [5760, 6158, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279].indexOf(ch2) >= 0;
}
function isLineTerminator(ch2) {
  return ch2 === 10 || ch2 === 13 || ch2 === 8232 || ch2 === 8233;
}
function isIdentifierStart(ch2) {
  return ch2 === 36 || ch2 === 95 || // $ (dollar) and _ (underscore)
  ch2 >= 65 && ch2 <= 90 || // A..Z
  ch2 >= 97 && ch2 <= 122 || // a..z
  ch2 === 92 || // \ (backslash)
  ch2 >= 128 && RegexNonAsciiIdentifierStart.test(String.fromCharCode(ch2));
}
function isIdentifierPart(ch2) {
  return ch2 === 36 || ch2 === 95 || // $ (dollar) and _ (underscore)
  ch2 >= 65 && ch2 <= 90 || // A..Z
  ch2 >= 97 && ch2 <= 122 || // a..z
  ch2 >= 48 && ch2 <= 57 || // 0..9
  ch2 === 92 || // \ (backslash)
  ch2 >= 128 && RegexNonAsciiIdentifierPart.test(String.fromCharCode(ch2));
}
var keywords = {
  "if": 1,
  "in": 1,
  "do": 1,
  "var": 1,
  "for": 1,
  "new": 1,
  "try": 1,
  "let": 1,
  "this": 1,
  "else": 1,
  "case": 1,
  "void": 1,
  "with": 1,
  "enum": 1,
  "while": 1,
  "break": 1,
  "catch": 1,
  "throw": 1,
  "const": 1,
  "yield": 1,
  "class": 1,
  "super": 1,
  "return": 1,
  "typeof": 1,
  "delete": 1,
  "switch": 1,
  "export": 1,
  "import": 1,
  "public": 1,
  "static": 1,
  "default": 1,
  "finally": 1,
  "extends": 1,
  "package": 1,
  "private": 1,
  "function": 1,
  "continue": 1,
  "debugger": 1,
  "interface": 1,
  "protected": 1,
  "instanceof": 1,
  "implements": 1
};
function skipComment() {
  while (index < length) {
    const ch2 = source2.charCodeAt(index);
    if (isWhiteSpace(ch2) || isLineTerminator(ch2)) {
      ++index;
    } else {
      break;
    }
  }
}
function scanHexEscape(prefix) {
  var i, len, ch2, code = 0;
  len = prefix === "u" ? 4 : 2;
  for (i = 0; i < len; ++i) {
    if (index < length && isHexDigit(source2[index])) {
      ch2 = source2[index++];
      code = code * 16 + "0123456789abcdef".indexOf(ch2.toLowerCase());
    } else {
      throwError({}, MessageUnexpectedToken, ILLEGAL);
    }
  }
  return String.fromCharCode(code);
}
function scanUnicodeCodePointEscape() {
  var ch2, code, cu1, cu2;
  ch2 = source2[index];
  code = 0;
  if (ch2 === "}") {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }
  while (index < length) {
    ch2 = source2[index++];
    if (!isHexDigit(ch2)) {
      break;
    }
    code = code * 16 + "0123456789abcdef".indexOf(ch2.toLowerCase());
  }
  if (code > 1114111 || ch2 !== "}") {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }
  if (code <= 65535) {
    return String.fromCharCode(code);
  }
  cu1 = (code - 65536 >> 10) + 55296;
  cu2 = (code - 65536 & 1023) + 56320;
  return String.fromCharCode(cu1, cu2);
}
function getEscapedIdentifier() {
  var ch2, id2;
  ch2 = source2.charCodeAt(index++);
  id2 = String.fromCharCode(ch2);
  if (ch2 === 92) {
    if (source2.charCodeAt(index) !== 117) {
      throwError({}, MessageUnexpectedToken, ILLEGAL);
    }
    ++index;
    ch2 = scanHexEscape("u");
    if (!ch2 || ch2 === "\\" || !isIdentifierStart(ch2.charCodeAt(0))) {
      throwError({}, MessageUnexpectedToken, ILLEGAL);
    }
    id2 = ch2;
  }
  while (index < length) {
    ch2 = source2.charCodeAt(index);
    if (!isIdentifierPart(ch2)) {
      break;
    }
    ++index;
    id2 += String.fromCharCode(ch2);
    if (ch2 === 92) {
      id2 = id2.substr(0, id2.length - 1);
      if (source2.charCodeAt(index) !== 117) {
        throwError({}, MessageUnexpectedToken, ILLEGAL);
      }
      ++index;
      ch2 = scanHexEscape("u");
      if (!ch2 || ch2 === "\\" || !isIdentifierPart(ch2.charCodeAt(0))) {
        throwError({}, MessageUnexpectedToken, ILLEGAL);
      }
      id2 += ch2;
    }
  }
  return id2;
}
function getIdentifier() {
  var start, ch2;
  start = index++;
  while (index < length) {
    ch2 = source2.charCodeAt(index);
    if (ch2 === 92) {
      index = start;
      return getEscapedIdentifier();
    }
    if (isIdentifierPart(ch2)) {
      ++index;
    } else {
      break;
    }
  }
  return source2.slice(start, index);
}
function scanIdentifier() {
  var start, id2, type2;
  start = index;
  id2 = source2.charCodeAt(index) === 92 ? getEscapedIdentifier() : getIdentifier();
  if (id2.length === 1) {
    type2 = TokenIdentifier;
  } else if (keywords.hasOwnProperty(id2)) {
    type2 = TokenKeyword;
  } else if (id2 === "null") {
    type2 = TokenNullLiteral;
  } else if (id2 === "true" || id2 === "false") {
    type2 = TokenBooleanLiteral;
  } else {
    type2 = TokenIdentifier;
  }
  return {
    type: type2,
    value: id2,
    start,
    end: index
  };
}
function scanPunctuator() {
  var start = index, code = source2.charCodeAt(index), code2, ch1 = source2[index], ch2, ch3, ch4;
  switch (code) {
    case 46:
    case 40:
    case 41:
    case 59:
    case 44:
    case 123:
    case 125:
    case 91:
    case 93:
    case 58:
    case 63:
    case 126:
      ++index;
      return {
        type: TokenPunctuator,
        value: String.fromCharCode(code),
        start,
        end: index
      };
    default:
      code2 = source2.charCodeAt(index + 1);
      if (code2 === 61) {
        switch (code) {
          case 43:
          case 45:
          case 47:
          case 60:
          case 62:
          case 94:
          case 124:
          case 37:
          case 38:
          case 42:
            index += 2;
            return {
              type: TokenPunctuator,
              value: String.fromCharCode(code) + String.fromCharCode(code2),
              start,
              end: index
            };
          case 33:
          case 61:
            index += 2;
            if (source2.charCodeAt(index) === 61) {
              ++index;
            }
            return {
              type: TokenPunctuator,
              value: source2.slice(start, index),
              start,
              end: index
            };
        }
      }
  }
  ch4 = source2.substr(index, 4);
  if (ch4 === ">>>=") {
    index += 4;
    return {
      type: TokenPunctuator,
      value: ch4,
      start,
      end: index
    };
  }
  ch3 = ch4.substr(0, 3);
  if (ch3 === ">>>" || ch3 === "<<=" || ch3 === ">>=") {
    index += 3;
    return {
      type: TokenPunctuator,
      value: ch3,
      start,
      end: index
    };
  }
  ch2 = ch3.substr(0, 2);
  if (ch1 === ch2[1] && "+-<>&|".indexOf(ch1) >= 0 || ch2 === "=>") {
    index += 2;
    return {
      type: TokenPunctuator,
      value: ch2,
      start,
      end: index
    };
  }
  if (ch2 === "//") {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }
  if ("<>=!+-*%&|^/".indexOf(ch1) >= 0) {
    ++index;
    return {
      type: TokenPunctuator,
      value: ch1,
      start,
      end: index
    };
  }
  throwError({}, MessageUnexpectedToken, ILLEGAL);
}
function scanHexLiteral(start) {
  let number5 = "";
  while (index < length) {
    if (!isHexDigit(source2[index])) {
      break;
    }
    number5 += source2[index++];
  }
  if (number5.length === 0) {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }
  if (isIdentifierStart(source2.charCodeAt(index))) {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }
  return {
    type: TokenNumericLiteral,
    value: parseInt("0x" + number5, 16),
    start,
    end: index
  };
}
function scanOctalLiteral(start) {
  let number5 = "0" + source2[index++];
  while (index < length) {
    if (!isOctalDigit(source2[index])) {
      break;
    }
    number5 += source2[index++];
  }
  if (isIdentifierStart(source2.charCodeAt(index)) || isDecimalDigit(source2.charCodeAt(index))) {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }
  return {
    type: TokenNumericLiteral,
    value: parseInt(number5, 8),
    octal: true,
    start,
    end: index
  };
}
function scanNumericLiteral() {
  var number5, start, ch2;
  ch2 = source2[index];
  assert(isDecimalDigit(ch2.charCodeAt(0)) || ch2 === ".", "Numeric literal must start with a decimal digit or a decimal point");
  start = index;
  number5 = "";
  if (ch2 !== ".") {
    number5 = source2[index++];
    ch2 = source2[index];
    if (number5 === "0") {
      if (ch2 === "x" || ch2 === "X") {
        ++index;
        return scanHexLiteral(start);
      }
      if (isOctalDigit(ch2)) {
        return scanOctalLiteral(start);
      }
      if (ch2 && isDecimalDigit(ch2.charCodeAt(0))) {
        throwError({}, MessageUnexpectedToken, ILLEGAL);
      }
    }
    while (isDecimalDigit(source2.charCodeAt(index))) {
      number5 += source2[index++];
    }
    ch2 = source2[index];
  }
  if (ch2 === ".") {
    number5 += source2[index++];
    while (isDecimalDigit(source2.charCodeAt(index))) {
      number5 += source2[index++];
    }
    ch2 = source2[index];
  }
  if (ch2 === "e" || ch2 === "E") {
    number5 += source2[index++];
    ch2 = source2[index];
    if (ch2 === "+" || ch2 === "-") {
      number5 += source2[index++];
    }
    if (isDecimalDigit(source2.charCodeAt(index))) {
      while (isDecimalDigit(source2.charCodeAt(index))) {
        number5 += source2[index++];
      }
    } else {
      throwError({}, MessageUnexpectedToken, ILLEGAL);
    }
  }
  if (isIdentifierStart(source2.charCodeAt(index))) {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }
  return {
    type: TokenNumericLiteral,
    value: parseFloat(number5),
    start,
    end: index
  };
}
function scanStringLiteral() {
  var str = "", quote, start, ch2, code, octal = false;
  quote = source2[index];
  assert(quote === "'" || quote === '"', "String literal must starts with a quote");
  start = index;
  ++index;
  while (index < length) {
    ch2 = source2[index++];
    if (ch2 === quote) {
      quote = "";
      break;
    } else if (ch2 === "\\") {
      ch2 = source2[index++];
      if (!ch2 || !isLineTerminator(ch2.charCodeAt(0))) {
        switch (ch2) {
          case "u":
          case "x":
            if (source2[index] === "{") {
              ++index;
              str += scanUnicodeCodePointEscape();
            } else {
              str += scanHexEscape(ch2);
            }
            break;
          case "n":
            str += "\n";
            break;
          case "r":
            str += "\r";
            break;
          case "t":
            str += "	";
            break;
          case "b":
            str += "\b";
            break;
          case "f":
            str += "\f";
            break;
          case "v":
            str += "\v";
            break;
          default:
            if (isOctalDigit(ch2)) {
              code = "01234567".indexOf(ch2);
              if (code !== 0) {
                octal = true;
              }
              if (index < length && isOctalDigit(source2[index])) {
                octal = true;
                code = code * 8 + "01234567".indexOf(source2[index++]);
                if ("0123".indexOf(ch2) >= 0 && index < length && isOctalDigit(source2[index])) {
                  code = code * 8 + "01234567".indexOf(source2[index++]);
                }
              }
              str += String.fromCharCode(code);
            } else {
              str += ch2;
            }
            break;
        }
      } else {
        if (ch2 === "\r" && source2[index] === "\n") {
          ++index;
        }
      }
    } else if (isLineTerminator(ch2.charCodeAt(0))) {
      break;
    } else {
      str += ch2;
    }
  }
  if (quote !== "") {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }
  return {
    type: TokenStringLiteral,
    value: str,
    octal,
    start,
    end: index
  };
}
function testRegExp(pattern, flags) {
  let tmp = pattern;
  if (flags.indexOf("u") >= 0) {
    tmp = tmp.replace(/\\u\{([0-9a-fA-F]+)\}/g, ($0, $1) => {
      if (parseInt($1, 16) <= 1114111) {
        return "x";
      }
      throwError({}, MessageInvalidRegExp);
    }).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "x");
  }
  try {
    new RegExp(tmp);
  } catch (e) {
    throwError({}, MessageInvalidRegExp);
  }
  try {
    return new RegExp(pattern, flags);
  } catch (exception) {
    return null;
  }
}
function scanRegExpBody() {
  var ch2, str, classMarker, terminated, body;
  ch2 = source2[index];
  assert(ch2 === "/", "Regular expression literal must start with a slash");
  str = source2[index++];
  classMarker = false;
  terminated = false;
  while (index < length) {
    ch2 = source2[index++];
    str += ch2;
    if (ch2 === "\\") {
      ch2 = source2[index++];
      if (isLineTerminator(ch2.charCodeAt(0))) {
        throwError({}, MessageUnterminatedRegExp);
      }
      str += ch2;
    } else if (isLineTerminator(ch2.charCodeAt(0))) {
      throwError({}, MessageUnterminatedRegExp);
    } else if (classMarker) {
      if (ch2 === "]") {
        classMarker = false;
      }
    } else {
      if (ch2 === "/") {
        terminated = true;
        break;
      } else if (ch2 === "[") {
        classMarker = true;
      }
    }
  }
  if (!terminated) {
    throwError({}, MessageUnterminatedRegExp);
  }
  body = str.substr(1, str.length - 2);
  return {
    value: body,
    literal: str
  };
}
function scanRegExpFlags() {
  var ch2, str, flags;
  str = "";
  flags = "";
  while (index < length) {
    ch2 = source2[index];
    if (!isIdentifierPart(ch2.charCodeAt(0))) {
      break;
    }
    ++index;
    if (ch2 === "\\" && index < length) {
      throwError({}, MessageUnexpectedToken, ILLEGAL);
    } else {
      flags += ch2;
      str += ch2;
    }
  }
  if (flags.search(/[^gimuy]/g) >= 0) {
    throwError({}, MessageInvalidRegExp, flags);
  }
  return {
    value: flags,
    literal: str
  };
}
function scanRegExp() {
  var start, body, flags, value3;
  lookahead = null;
  skipComment();
  start = index;
  body = scanRegExpBody();
  flags = scanRegExpFlags();
  value3 = testRegExp(body.value, flags.value);
  return {
    literal: body.literal + flags.literal,
    value: value3,
    regex: {
      pattern: body.value,
      flags: flags.value
    },
    start,
    end: index
  };
}
function isIdentifierName(token) {
  return token.type === TokenIdentifier || token.type === TokenKeyword || token.type === TokenBooleanLiteral || token.type === TokenNullLiteral;
}
function advance() {
  skipComment();
  if (index >= length) {
    return {
      type: TokenEOF,
      start: index,
      end: index
    };
  }
  const ch2 = source2.charCodeAt(index);
  if (isIdentifierStart(ch2)) {
    return scanIdentifier();
  }
  if (ch2 === 40 || ch2 === 41 || ch2 === 59) {
    return scanPunctuator();
  }
  if (ch2 === 39 || ch2 === 34) {
    return scanStringLiteral();
  }
  if (ch2 === 46) {
    if (isDecimalDigit(source2.charCodeAt(index + 1))) {
      return scanNumericLiteral();
    }
    return scanPunctuator();
  }
  if (isDecimalDigit(ch2)) {
    return scanNumericLiteral();
  }
  return scanPunctuator();
}
function lex() {
  const token = lookahead;
  index = token.end;
  lookahead = advance();
  index = token.end;
  return token;
}
function peek2() {
  const pos = index;
  lookahead = advance();
  index = pos;
}
function finishArrayExpression(elements) {
  const node = new ASTNode(SyntaxArrayExpression);
  node.elements = elements;
  return node;
}
function finishBinaryExpression(operator2, left, right) {
  const node = new ASTNode(operator2 === "||" || operator2 === "&&" ? SyntaxLogicalExpression : SyntaxBinaryExpression);
  node.operator = operator2;
  node.left = left;
  node.right = right;
  return node;
}
function finishCallExpression(callee, args) {
  const node = new ASTNode(SyntaxCallExpression);
  node.callee = callee;
  node.arguments = args;
  return node;
}
function finishConditionalExpression(test2, consequent, alternate) {
  const node = new ASTNode(SyntaxConditionalExpression);
  node.test = test2;
  node.consequent = consequent;
  node.alternate = alternate;
  return node;
}
function finishIdentifier(name) {
  const node = new ASTNode(SyntaxIdentifier);
  node.name = name;
  return node;
}
function finishLiteral(token) {
  const node = new ASTNode(SyntaxLiteral);
  node.value = token.value;
  node.raw = source2.slice(token.start, token.end);
  if (token.regex) {
    if (node.raw === "//") {
      node.raw = "/(?:)/";
    }
    node.regex = token.regex;
  }
  return node;
}
function finishMemberExpression(accessor2, object2, property2) {
  const node = new ASTNode(SyntaxMemberExpression);
  node.computed = accessor2 === "[";
  node.object = object2;
  node.property = property2;
  if (!node.computed)
    property2.member = true;
  return node;
}
function finishObjectExpression(properties) {
  const node = new ASTNode(SyntaxObjectExpression);
  node.properties = properties;
  return node;
}
function finishProperty(kind, key2, value3) {
  const node = new ASTNode(SyntaxProperty);
  node.key = key2;
  node.value = value3;
  node.kind = kind;
  return node;
}
function finishUnaryExpression(operator2, argument) {
  const node = new ASTNode(SyntaxUnaryExpression);
  node.operator = operator2;
  node.argument = argument;
  node.prefix = true;
  return node;
}
function throwError(token, messageFormat) {
  var error2, args = Array.prototype.slice.call(arguments, 2), msg = messageFormat.replace(/%(\d)/g, (whole, index2) => {
    assert(index2 < args.length, "Message reference must be in range");
    return args[index2];
  });
  error2 = new Error(msg);
  error2.index = index;
  error2.description = msg;
  throw error2;
}
function throwUnexpected(token) {
  if (token.type === TokenEOF) {
    throwError(token, MessageUnexpectedEOS);
  }
  if (token.type === TokenNumericLiteral) {
    throwError(token, MessageUnexpectedNumber);
  }
  if (token.type === TokenStringLiteral) {
    throwError(token, MessageUnexpectedString);
  }
  if (token.type === TokenIdentifier) {
    throwError(token, MessageUnexpectedIdentifier);
  }
  if (token.type === TokenKeyword) {
    throwError(token, MessageUnexpectedReserved);
  }
  throwError(token, MessageUnexpectedToken, token.value);
}
function expect(value3) {
  const token = lex();
  if (token.type !== TokenPunctuator || token.value !== value3) {
    throwUnexpected(token);
  }
}
function match(value3) {
  return lookahead.type === TokenPunctuator && lookahead.value === value3;
}
function matchKeyword(keyword) {
  return lookahead.type === TokenKeyword && lookahead.value === keyword;
}
function parseArrayInitialiser() {
  const elements = [];
  index = lookahead.start;
  expect("[");
  while (!match("]")) {
    if (match(",")) {
      lex();
      elements.push(null);
    } else {
      elements.push(parseConditionalExpression());
      if (!match("]")) {
        expect(",");
      }
    }
  }
  lex();
  return finishArrayExpression(elements);
}
function parseObjectPropertyKey() {
  index = lookahead.start;
  const token = lex();
  if (token.type === TokenStringLiteral || token.type === TokenNumericLiteral) {
    if (token.octal) {
      throwError(token, MessageStrictOctalLiteral);
    }
    return finishLiteral(token);
  }
  return finishIdentifier(token.value);
}
function parseObjectProperty() {
  var token, key2, id2, value3;
  index = lookahead.start;
  token = lookahead;
  if (token.type === TokenIdentifier) {
    id2 = parseObjectPropertyKey();
    expect(":");
    value3 = parseConditionalExpression();
    return finishProperty("init", id2, value3);
  }
  if (token.type === TokenEOF || token.type === TokenPunctuator) {
    throwUnexpected(token);
  } else {
    key2 = parseObjectPropertyKey();
    expect(":");
    value3 = parseConditionalExpression();
    return finishProperty("init", key2, value3);
  }
}
function parseObjectInitialiser() {
  var properties = [], property2, name, key2, map2 = {}, toString2 = String;
  index = lookahead.start;
  expect("{");
  while (!match("}")) {
    property2 = parseObjectProperty();
    if (property2.key.type === SyntaxIdentifier) {
      name = property2.key.name;
    } else {
      name = toString2(property2.key.value);
    }
    key2 = "$" + name;
    if (Object.prototype.hasOwnProperty.call(map2, key2)) {
      throwError({}, MessageStrictDuplicateProperty);
    } else {
      map2[key2] = true;
    }
    properties.push(property2);
    if (!match("}")) {
      expect(",");
    }
  }
  expect("}");
  return finishObjectExpression(properties);
}
function parseGroupExpression() {
  expect("(");
  const expr2 = parseExpression();
  expect(")");
  return expr2;
}
var legalKeywords = {
  "if": 1
};
function parsePrimaryExpression() {
  var type2, token, expr2;
  if (match("(")) {
    return parseGroupExpression();
  }
  if (match("[")) {
    return parseArrayInitialiser();
  }
  if (match("{")) {
    return parseObjectInitialiser();
  }
  type2 = lookahead.type;
  index = lookahead.start;
  if (type2 === TokenIdentifier || legalKeywords[lookahead.value]) {
    expr2 = finishIdentifier(lex().value);
  } else if (type2 === TokenStringLiteral || type2 === TokenNumericLiteral) {
    if (lookahead.octal) {
      throwError(lookahead, MessageStrictOctalLiteral);
    }
    expr2 = finishLiteral(lex());
  } else if (type2 === TokenKeyword) {
    throw new Error(DISABLED);
  } else if (type2 === TokenBooleanLiteral) {
    token = lex();
    token.value = token.value === "true";
    expr2 = finishLiteral(token);
  } else if (type2 === TokenNullLiteral) {
    token = lex();
    token.value = null;
    expr2 = finishLiteral(token);
  } else if (match("/") || match("/=")) {
    expr2 = finishLiteral(scanRegExp());
    peek2();
  } else {
    throwUnexpected(lex());
  }
  return expr2;
}
function parseArguments() {
  const args = [];
  expect("(");
  if (!match(")")) {
    while (index < length) {
      args.push(parseConditionalExpression());
      if (match(")")) {
        break;
      }
      expect(",");
    }
  }
  expect(")");
  return args;
}
function parseNonComputedProperty() {
  index = lookahead.start;
  const token = lex();
  if (!isIdentifierName(token)) {
    throwUnexpected(token);
  }
  return finishIdentifier(token.value);
}
function parseNonComputedMember() {
  expect(".");
  return parseNonComputedProperty();
}
function parseComputedMember() {
  expect("[");
  const expr2 = parseExpression();
  expect("]");
  return expr2;
}
function parseLeftHandSideExpressionAllowCall() {
  var expr2, args, property2;
  expr2 = parsePrimaryExpression();
  for (; ; ) {
    if (match(".")) {
      property2 = parseNonComputedMember();
      expr2 = finishMemberExpression(".", expr2, property2);
    } else if (match("(")) {
      args = parseArguments();
      expr2 = finishCallExpression(expr2, args);
    } else if (match("[")) {
      property2 = parseComputedMember();
      expr2 = finishMemberExpression("[", expr2, property2);
    } else {
      break;
    }
  }
  return expr2;
}
function parsePostfixExpression() {
  const expr2 = parseLeftHandSideExpressionAllowCall();
  if (lookahead.type === TokenPunctuator) {
    if (match("++") || match("--")) {
      throw new Error(DISABLED);
    }
  }
  return expr2;
}
function parseUnaryExpression() {
  var token, expr2;
  if (lookahead.type !== TokenPunctuator && lookahead.type !== TokenKeyword) {
    expr2 = parsePostfixExpression();
  } else if (match("++") || match("--")) {
    throw new Error(DISABLED);
  } else if (match("+") || match("-") || match("~") || match("!")) {
    token = lex();
    expr2 = parseUnaryExpression();
    expr2 = finishUnaryExpression(token.value, expr2);
  } else if (matchKeyword("delete") || matchKeyword("void") || matchKeyword("typeof")) {
    throw new Error(DISABLED);
  } else {
    expr2 = parsePostfixExpression();
  }
  return expr2;
}
function binaryPrecedence(token) {
  let prec = 0;
  if (token.type !== TokenPunctuator && token.type !== TokenKeyword) {
    return 0;
  }
  switch (token.value) {
    case "||":
      prec = 1;
      break;
    case "&&":
      prec = 2;
      break;
    case "|":
      prec = 3;
      break;
    case "^":
      prec = 4;
      break;
    case "&":
      prec = 5;
      break;
    case "==":
    case "!=":
    case "===":
    case "!==":
      prec = 6;
      break;
    case "<":
    case ">":
    case "<=":
    case ">=":
    case "instanceof":
    case "in":
      prec = 7;
      break;
    case "<<":
    case ">>":
    case ">>>":
      prec = 8;
      break;
    case "+":
    case "-":
      prec = 9;
      break;
    case "*":
    case "/":
    case "%":
      prec = 11;
      break;
  }
  return prec;
}
function parseBinaryExpression() {
  var marker, markers, expr2, token, prec, stack, right, operator2, left, i;
  marker = lookahead;
  left = parseUnaryExpression();
  token = lookahead;
  prec = binaryPrecedence(token);
  if (prec === 0) {
    return left;
  }
  token.prec = prec;
  lex();
  markers = [marker, lookahead];
  right = parseUnaryExpression();
  stack = [left, token, right];
  while ((prec = binaryPrecedence(lookahead)) > 0) {
    while (stack.length > 2 && prec <= stack[stack.length - 2].prec) {
      right = stack.pop();
      operator2 = stack.pop().value;
      left = stack.pop();
      markers.pop();
      expr2 = finishBinaryExpression(operator2, left, right);
      stack.push(expr2);
    }
    token = lex();
    token.prec = prec;
    stack.push(token);
    markers.push(lookahead);
    expr2 = parseUnaryExpression();
    stack.push(expr2);
  }
  i = stack.length - 1;
  expr2 = stack[i];
  markers.pop();
  while (i > 1) {
    markers.pop();
    expr2 = finishBinaryExpression(stack[i - 1].value, stack[i - 2], expr2);
    i -= 2;
  }
  return expr2;
}
function parseConditionalExpression() {
  var expr2, consequent, alternate;
  expr2 = parseBinaryExpression();
  if (match("?")) {
    lex();
    consequent = parseConditionalExpression();
    expect(":");
    alternate = parseConditionalExpression();
    expr2 = finishConditionalExpression(expr2, consequent, alternate);
  }
  return expr2;
}
function parseExpression() {
  const expr2 = parseConditionalExpression();
  if (match(",")) {
    throw new Error(DISABLED);
  }
  return expr2;
}
function parser(code) {
  source2 = code;
  index = 0;
  length = source2.length;
  lookahead = null;
  peek2();
  const expr2 = parseExpression();
  if (lookahead.type !== TokenEOF) {
    throw new Error("Unexpect token after expression.");
  }
  return expr2;
}
var Constants = {
  NaN: "NaN",
  E: "Math.E",
  LN2: "Math.LN2",
  LN10: "Math.LN10",
  LOG2E: "Math.LOG2E",
  LOG10E: "Math.LOG10E",
  PI: "Math.PI",
  SQRT1_2: "Math.SQRT1_2",
  SQRT2: "Math.SQRT2",
  MIN_VALUE: "Number.MIN_VALUE",
  MAX_VALUE: "Number.MAX_VALUE"
};
function Functions(codegen2) {
  function fncall(name, args, cast, type2) {
    let obj = codegen2(args[0]);
    if (cast) {
      obj = cast + "(" + obj + ")";
      if (cast.lastIndexOf("new ", 0) === 0)
        obj = "(" + obj + ")";
    }
    return obj + "." + name + (type2 < 0 ? "" : type2 === 0 ? "()" : "(" + args.slice(1).map(codegen2).join(",") + ")");
  }
  function fn(name, cast, type2) {
    return (args) => fncall(name, args, cast, type2);
  }
  const DATE2 = "new Date", STRING = "String", REGEXP = "RegExp";
  return {
    // MATH functions
    isNaN: "Number.isNaN",
    isFinite: "Number.isFinite",
    abs: "Math.abs",
    acos: "Math.acos",
    asin: "Math.asin",
    atan: "Math.atan",
    atan2: "Math.atan2",
    ceil: "Math.ceil",
    cos: "Math.cos",
    exp: "Math.exp",
    floor: "Math.floor",
    hypot: "Math.hypot",
    log: "Math.log",
    max: "Math.max",
    min: "Math.min",
    pow: "Math.pow",
    random: "Math.random",
    round: "Math.round",
    sin: "Math.sin",
    sqrt: "Math.sqrt",
    tan: "Math.tan",
    clamp: function(args) {
      if (args.length < 3)
        error("Missing arguments to clamp function.");
      if (args.length > 3)
        error("Too many arguments to clamp function.");
      const a = args.map(codegen2);
      return "Math.max(" + a[1] + ", Math.min(" + a[2] + "," + a[0] + "))";
    },
    // DATE functions
    now: "Date.now",
    utc: "Date.UTC",
    datetime: DATE2,
    date: fn("getDate", DATE2, 0),
    day: fn("getDay", DATE2, 0),
    year: fn("getFullYear", DATE2, 0),
    month: fn("getMonth", DATE2, 0),
    hours: fn("getHours", DATE2, 0),
    minutes: fn("getMinutes", DATE2, 0),
    seconds: fn("getSeconds", DATE2, 0),
    milliseconds: fn("getMilliseconds", DATE2, 0),
    time: fn("getTime", DATE2, 0),
    timezoneoffset: fn("getTimezoneOffset", DATE2, 0),
    utcdate: fn("getUTCDate", DATE2, 0),
    utcday: fn("getUTCDay", DATE2, 0),
    utcyear: fn("getUTCFullYear", DATE2, 0),
    utcmonth: fn("getUTCMonth", DATE2, 0),
    utchours: fn("getUTCHours", DATE2, 0),
    utcminutes: fn("getUTCMinutes", DATE2, 0),
    utcseconds: fn("getUTCSeconds", DATE2, 0),
    utcmilliseconds: fn("getUTCMilliseconds", DATE2, 0),
    // sequence functions
    length: fn("length", null, -1),
    // STRING functions
    parseFloat: "parseFloat",
    parseInt: "parseInt",
    upper: fn("toUpperCase", STRING, 0),
    lower: fn("toLowerCase", STRING, 0),
    substring: fn("substring", STRING),
    split: fn("split", STRING),
    trim: fn("trim", STRING, 0),
    // REGEXP functions
    regexp: REGEXP,
    test: fn("test", REGEXP),
    // Control Flow functions
    if: function(args) {
      if (args.length < 3)
        error("Missing arguments to if function.");
      if (args.length > 3)
        error("Too many arguments to if function.");
      const a = args.map(codegen2);
      return "(" + a[0] + "?" + a[1] + ":" + a[2] + ")";
    }
  };
}
function stripQuotes(s) {
  const n = s && s.length - 1;
  return n && (s[0] === '"' && s[n] === '"' || s[0] === "'" && s[n] === "'") ? s.slice(1, -1) : s;
}
function codegen(opt) {
  opt = opt || {};
  const allowed = opt.allowed ? toSet(opt.allowed) : {}, forbidden = opt.forbidden ? toSet(opt.forbidden) : {}, constants = opt.constants || Constants, functions = (opt.functions || Functions)(visit2), globalvar = opt.globalvar, fieldvar = opt.fieldvar, outputGlobal = isFunction(globalvar) ? globalvar : (id2) => `${globalvar}["${id2}"]`;
  let globals = {}, fields = {}, memberDepth = 0;
  function visit2(ast) {
    if (isString(ast))
      return ast;
    const generator = Generators[ast.type];
    if (generator == null)
      error("Unsupported type: " + ast.type);
    return generator(ast);
  }
  const Generators = {
    Literal: (n) => n.raw,
    Identifier: (n) => {
      const id2 = n.name;
      if (memberDepth > 0) {
        return id2;
      } else if (has(forbidden, id2)) {
        return error("Illegal identifier: " + id2);
      } else if (has(constants, id2)) {
        return constants[id2];
      } else if (has(allowed, id2)) {
        return id2;
      } else {
        globals[id2] = 1;
        return outputGlobal(id2);
      }
    },
    MemberExpression: (n) => {
      const d = !n.computed, o = visit2(n.object);
      if (d)
        memberDepth += 1;
      const p = visit2(n.property);
      if (o === fieldvar) {
        fields[stripQuotes(p)] = 1;
      }
      if (d)
        memberDepth -= 1;
      return o + (d ? "." + p : "[" + p + "]");
    },
    CallExpression: (n) => {
      if (n.callee.type !== "Identifier") {
        error("Illegal callee type: " + n.callee.type);
      }
      const callee = n.callee.name, args = n.arguments, fn = has(functions, callee) && functions[callee];
      if (!fn)
        error("Unrecognized function: " + callee);
      return isFunction(fn) ? fn(args) : fn + "(" + args.map(visit2).join(",") + ")";
    },
    ArrayExpression: (n) => "[" + n.elements.map(visit2).join(",") + "]",
    BinaryExpression: (n) => "(" + visit2(n.left) + " " + n.operator + " " + visit2(n.right) + ")",
    UnaryExpression: (n) => "(" + n.operator + visit2(n.argument) + ")",
    ConditionalExpression: (n) => "(" + visit2(n.test) + "?" + visit2(n.consequent) + ":" + visit2(n.alternate) + ")",
    LogicalExpression: (n) => "(" + visit2(n.left) + n.operator + visit2(n.right) + ")",
    ObjectExpression: (n) => "{" + n.properties.map(visit2).join(",") + "}",
    Property: (n) => {
      memberDepth += 1;
      const k2 = visit2(n.key);
      memberDepth -= 1;
      return k2 + ":" + visit2(n.value);
    }
  };
  function codegen2(ast) {
    const result = {
      code: visit2(ast),
      globals: Object.keys(globals),
      fields: Object.keys(fields)
    };
    globals = {};
    fields = {};
    return result;
  }
  codegen2.functions = functions;
  codegen2.constants = constants;
  return codegen2;
}

// node_modules/vega-selections/build/vega-selection.module.js
var SELECTION_GETTER = Symbol("vega_selection_getter");
function getter2(f) {
  if (!f.getter || !f.getter[SELECTION_GETTER]) {
    f.getter = field(f.field);
    f.getter[SELECTION_GETTER] = true;
  }
  return f.getter;
}
var Intersect = "intersect";
var Union = "union";
var VlMulti = "vlMulti";
var VlPoint = "vlPoint";
var Or = "or";
var And = "and";
var SelectionId = "_vgsid_";
var $selectionId = field(SelectionId);
var TYPE_ENUM = "E";
var TYPE_RANGE_INC = "R";
var TYPE_RANGE_EXC = "R-E";
var TYPE_RANGE_LE = "R-LE";
var TYPE_RANGE_RE = "R-RE";
var UNIT_INDEX = "index:unit";
function testPoint(datum2, entry2) {
  var fields = entry2.fields, values2 = entry2.values, n = fields.length, i = 0, dval, f;
  for (; i < n; ++i) {
    f = fields[i];
    dval = getter2(f)(datum2);
    if (isDate(dval))
      dval = toNumber(dval);
    if (isDate(values2[i]))
      values2[i] = toNumber(values2[i]);
    if (isArray(values2[i]) && isDate(values2[i][0]))
      values2[i] = values2[i].map(toNumber);
    if (f.type === TYPE_ENUM) {
      if (isArray(values2[i]) ? values2[i].indexOf(dval) < 0 : dval !== values2[i]) {
        return false;
      }
    } else {
      if (f.type === TYPE_RANGE_INC) {
        if (!inrange(dval, values2[i]))
          return false;
      } else if (f.type === TYPE_RANGE_RE) {
        if (!inrange(dval, values2[i], true, false))
          return false;
      } else if (f.type === TYPE_RANGE_EXC) {
        if (!inrange(dval, values2[i], false, false))
          return false;
      } else if (f.type === TYPE_RANGE_LE) {
        if (!inrange(dval, values2[i], false, true))
          return false;
      }
    }
  }
  return true;
}
function selectionTest(name, datum2, op) {
  var data3 = this.context.data[name], entries = data3 ? data3.values.value : [], unitIdx = data3 ? data3[UNIT_INDEX] && data3[UNIT_INDEX].value : void 0, intersect4 = op === Intersect, n = entries.length, i = 0, entry2, miss, count, unit, b2;
  for (; i < n; ++i) {
    entry2 = entries[i];
    if (unitIdx && intersect4) {
      miss = miss || {};
      count = miss[unit = entry2.unit] || 0;
      if (count === -1)
        continue;
      b2 = testPoint(datum2, entry2);
      miss[unit] = b2 ? -1 : ++count;
      if (b2 && unitIdx.size === 1)
        return true;
      if (!b2 && count === unitIdx.get(unit).count)
        return false;
    } else {
      b2 = testPoint(datum2, entry2);
      if (intersect4 ^ b2)
        return b2;
    }
  }
  return n && intersect4;
}
var bisect = bisector($selectionId);
var bisectLeft2 = bisect.left;
var bisectRight2 = bisect.right;
function selectionIdTest(name, datum2, op) {
  const data3 = this.context.data[name], entries = data3 ? data3.values.value : [], unitIdx = data3 ? data3[UNIT_INDEX] && data3[UNIT_INDEX].value : void 0, intersect4 = op === Intersect, value3 = $selectionId(datum2), index2 = bisectLeft2(entries, value3);
  if (index2 === entries.length)
    return false;
  if ($selectionId(entries[index2]) !== value3)
    return false;
  if (unitIdx && intersect4) {
    if (unitIdx.size === 1)
      return true;
    if (bisectRight2(entries, value3) - index2 < unitIdx.size)
      return false;
  }
  return true;
}
function selectionTuples(array4, base2) {
  return array4.map((x2) => extend(base2.fields ? {
    values: base2.fields.map((f) => getter2(f)(x2.datum))
  } : {
    [SelectionId]: $selectionId(x2.datum)
  }, base2));
}
function selectionResolve(name, op, isMulti, vl5) {
  var data3 = this.context.data[name], entries = data3 ? data3.values.value : [], resolved = {}, multiRes = {}, types = {}, entry2, fields, values2, unit, field3, value3, res, resUnit, type2, union2, n = entries.length, i = 0, j, m;
  for (; i < n; ++i) {
    entry2 = entries[i];
    unit = entry2.unit;
    fields = entry2.fields;
    values2 = entry2.values;
    if (fields && values2) {
      for (j = 0, m = fields.length; j < m; ++j) {
        field3 = fields[j];
        res = resolved[field3.field] || (resolved[field3.field] = {});
        resUnit = res[unit] || (res[unit] = []);
        types[field3.field] = type2 = field3.type.charAt(0);
        union2 = ops[`${type2}_union`];
        res[unit] = union2(resUnit, array(values2[j]));
      }
      if (isMulti) {
        resUnit = multiRes[unit] || (multiRes[unit] = []);
        resUnit.push(array(values2).reduce((obj, curr, j2) => (obj[fields[j2].field] = curr, obj), {}));
      }
    } else {
      field3 = SelectionId;
      value3 = $selectionId(entry2);
      res = resolved[field3] || (resolved[field3] = {});
      resUnit = res[unit] || (res[unit] = []);
      resUnit.push(value3);
      if (isMulti) {
        resUnit = multiRes[unit] || (multiRes[unit] = []);
        resUnit.push({
          [SelectionId]: value3
        });
      }
    }
  }
  op = op || Union;
  if (resolved[SelectionId]) {
    resolved[SelectionId] = ops[`${SelectionId}_${op}`](...Object.values(resolved[SelectionId]));
  } else {
    Object.keys(resolved).forEach((field4) => {
      resolved[field4] = Object.keys(resolved[field4]).map((unit2) => resolved[field4][unit2]).reduce((acc, curr) => acc === void 0 ? curr : ops[`${types[field4]}_${op}`](acc, curr));
    });
  }
  entries = Object.keys(multiRes);
  if (isMulti && entries.length) {
    const key2 = vl5 ? VlPoint : VlMulti;
    resolved[key2] = op === Union ? {
      [Or]: entries.reduce((acc, k2) => (acc.push(...multiRes[k2]), acc), [])
    } : {
      [And]: entries.map((k2) => ({
        [Or]: multiRes[k2]
      }))
    };
  }
  return resolved;
}
var ops = {
  [`${SelectionId}_union`]: union,
  [`${SelectionId}_intersect`]: intersection,
  E_union: function(base2, value3) {
    if (!base2.length)
      return value3;
    var i = 0, n = value3.length;
    for (; i < n; ++i)
      if (base2.indexOf(value3[i]) < 0)
        base2.push(value3[i]);
    return base2;
  },
  E_intersect: function(base2, value3) {
    return !base2.length ? value3 : base2.filter((v) => value3.indexOf(v) >= 0);
  },
  R_union: function(base2, value3) {
    var lo = toNumber(value3[0]), hi = toNumber(value3[1]);
    if (lo > hi) {
      lo = value3[1];
      hi = value3[0];
    }
    if (!base2.length)
      return [lo, hi];
    if (base2[0] > lo)
      base2[0] = lo;
    if (base2[1] < hi)
      base2[1] = hi;
    return base2;
  },
  R_intersect: function(base2, value3) {
    var lo = toNumber(value3[0]), hi = toNumber(value3[1]);
    if (lo > hi) {
      lo = value3[1];
      hi = value3[0];
    }
    if (!base2.length)
      return [lo, hi];
    if (hi < base2[0] || base2[1] < lo) {
      return [];
    } else {
      if (base2[0] < lo)
        base2[0] = lo;
      if (base2[1] > hi)
        base2[1] = hi;
    }
    return base2;
  }
};
var DataPrefix = ":";
var IndexPrefix = "@";
function selectionVisitor(name, args, scope, params2) {
  if (args[0].type !== Literal)
    error("First argument to selection functions must be a string literal.");
  const data3 = args[0].value, op = args.length >= 2 && peek(args).value, field3 = "unit", indexName = IndexPrefix + field3, dataName = DataPrefix + data3;
  if (op === Intersect && !has(params2, indexName)) {
    params2[indexName] = scope.getData(data3).indataRef(scope, field3);
  }
  if (!has(params2, dataName)) {
    params2[dataName] = scope.getData(data3).tuplesRef();
  }
}

// node_modules/vega-functions/build/vega-functions.module.js
function data(name) {
  const data3 = this.context.data[name];
  return data3 ? data3.values.value : [];
}
function indata(name, field3, value3) {
  const index2 = this.context.data[name]["index:" + field3], entry2 = index2 ? index2.value.get(value3) : void 0;
  return entry2 ? entry2.count : entry2;
}
function setdata(name, tuples) {
  const df = this.context.dataflow, data3 = this.context.data[name], input = data3.input;
  df.pulse(input, df.changeset().remove(truthy).insert(tuples));
  return 1;
}
function encode(item, name, retval) {
  if (item) {
    const df = this.context.dataflow, target2 = item.mark.source;
    df.pulse(target2, df.changeset().encode(item, name));
  }
  return retval !== void 0 ? retval : item;
}
var wrap = (method2) => function(value3, spec) {
  const locale2 = this.context.dataflow.locale();
  return locale2[method2](spec)(value3);
};
var format4 = wrap("format");
var timeFormat2 = wrap("timeFormat");
var utcFormat2 = wrap("utcFormat");
var timeParse2 = wrap("timeParse");
var utcParse2 = wrap("utcParse");
var dateObj = new Date(2e3, 0, 1);
function time2(month, day, specifier) {
  if (!Number.isInteger(month) || !Number.isInteger(day))
    return "";
  dateObj.setYear(2e3);
  dateObj.setMonth(month);
  dateObj.setDate(day);
  return timeFormat2.call(this, dateObj, specifier);
}
function monthFormat(month) {
  return time2.call(this, month, 1, "%B");
}
function monthAbbrevFormat(month) {
  return time2.call(this, month, 1, "%b");
}
function dayFormat(day) {
  return time2.call(this, 0, 2 + day, "%A");
}
function dayAbbrevFormat(day) {
  return time2.call(this, 0, 2 + day, "%a");
}
var DataPrefix2 = ":";
var IndexPrefix2 = "@";
var ScalePrefix = "%";
var SignalPrefix = "$";
function dataVisitor(name, args, scope, params2) {
  if (args[0].type !== Literal) {
    error("First argument to data functions must be a string literal.");
  }
  const data3 = args[0].value, dataName = DataPrefix2 + data3;
  if (!has(dataName, params2)) {
    try {
      params2[dataName] = scope.getData(data3).tuplesRef();
    } catch (err) {
    }
  }
}
function indataVisitor(name, args, scope, params2) {
  if (args[0].type !== Literal)
    error("First argument to indata must be a string literal.");
  if (args[1].type !== Literal)
    error("Second argument to indata must be a string literal.");
  const data3 = args[0].value, field3 = args[1].value, indexName = IndexPrefix2 + field3;
  if (!has(indexName, params2)) {
    params2[indexName] = scope.getData(data3).indataRef(scope, field3);
  }
}
function scaleVisitor(name, args, scope, params2) {
  if (args[0].type === Literal) {
    addScaleDependency(scope, params2, args[0].value);
  } else {
    for (name in scope.scales) {
      addScaleDependency(scope, params2, name);
    }
  }
}
function addScaleDependency(scope, params2, name) {
  const scaleName = ScalePrefix + name;
  if (!has(params2, scaleName)) {
    try {
      params2[scaleName] = scope.scaleRef(name);
    } catch (err) {
    }
  }
}
function getScale(nameOrFunction, ctx) {
  if (isFunction(nameOrFunction)) {
    return nameOrFunction;
  }
  if (isString(nameOrFunction)) {
    const maybeScale = ctx.scales[nameOrFunction];
    return maybeScale && isRegisteredScale(maybeScale.value) ? maybeScale.value : void 0;
  }
  return void 0;
}
function internalScaleFunctions(codegen2, fnctx, visitors) {
  fnctx.__bandwidth = (s) => s && s.bandwidth ? s.bandwidth() : 0;
  visitors._bandwidth = scaleVisitor;
  visitors._range = scaleVisitor;
  visitors._scale = scaleVisitor;
  const ref2 = (arg) => "_[" + (arg.type === Literal ? $(ScalePrefix + arg.value) : $(ScalePrefix) + "+" + codegen2(arg)) + "]";
  return {
    _bandwidth: (args) => `this.__bandwidth(${ref2(args[0])})`,
    _range: (args) => `${ref2(args[0])}.range()`,
    _scale: (args) => `${ref2(args[0])}(${codegen2(args[1])})`
  };
}
function geoMethod(methodName, globalMethod) {
  return function(projection3, geojson, group2) {
    if (projection3) {
      const p = getScale(projection3, (group2 || this).context);
      return p && p.path[methodName](geojson);
    } else {
      return globalMethod(geojson);
    }
  };
}
var geoArea = geoMethod("area", area_default2);
var geoBounds = geoMethod("bounds", bounds_default);
var geoCentroid = geoMethod("centroid", centroid_default);
function geoScale(projection3, group2) {
  const p = getScale(projection3, (group2 || this).context);
  return p && p.scale();
}
function inScope(item) {
  const group2 = this.context.group;
  let value3 = false;
  if (group2)
    while (item) {
      if (item === group2) {
        value3 = true;
        break;
      }
      item = item.mark.group;
    }
  return value3;
}
function log5(df, method2, args) {
  try {
    df[method2].apply(df, ["EXPRESSION"].concat([].slice.call(args)));
  } catch (err) {
    df.warn(err);
  }
  return args[args.length - 1];
}
function warn() {
  return log5(this.context.dataflow, "warn", arguments);
}
function info() {
  return log5(this.context.dataflow, "info", arguments);
}
function debug() {
  return log5(this.context.dataflow, "debug", arguments);
}
function channel_luminance_value(channelValue) {
  const val = channelValue / 255;
  if (val <= 0.03928) {
    return val / 12.92;
  }
  return Math.pow((val + 0.055) / 1.055, 2.4);
}
function luminance(color3) {
  const c = rgb(color3), r = channel_luminance_value(c.r), g = channel_luminance_value(c.g), b2 = channel_luminance_value(c.b);
  return 0.2126 * r + 0.7152 * g + 0.0722 * b2;
}
function contrast(color1, color22) {
  const lum1 = luminance(color1), lum2 = luminance(color22), lumL = Math.max(lum1, lum2), lumD = Math.min(lum1, lum2);
  return (lumL + 0.05) / (lumD + 0.05);
}
function merge4() {
  const args = [].slice.call(arguments);
  args.unshift({});
  return extend(...args);
}
function equal(a, b2) {
  return a === b2 || a !== a && b2 !== b2 ? true : isArray(a) ? isArray(b2) && a.length === b2.length ? equalArray(a, b2) : false : isObject(a) && isObject(b2) ? equalObject(a, b2) : false;
}
function equalArray(a, b2) {
  for (let i = 0, n = a.length; i < n; ++i) {
    if (!equal(a[i], b2[i]))
      return false;
  }
  return true;
}
function equalObject(a, b2) {
  for (const key2 in a) {
    if (!equal(a[key2], b2[key2]))
      return false;
  }
  return true;
}
function removePredicate(props) {
  return (_) => equalObject(props, _);
}
function modify(name, insert2, remove2, toggle, modify2, values2) {
  const df = this.context.dataflow, data3 = this.context.data[name], input = data3.input, stamp = df.stamp();
  let changes = data3.changes, predicate, key2;
  if (df._trigger === false || !(input.value.length || insert2 || toggle)) {
    return 0;
  }
  if (!changes || changes.stamp < stamp) {
    data3.changes = changes = df.changeset();
    changes.stamp = stamp;
    df.runAfter(() => {
      data3.modified = true;
      df.pulse(input, changes).run();
    }, true, 1);
  }
  if (remove2) {
    predicate = remove2 === true ? truthy : isArray(remove2) || isTuple(remove2) ? remove2 : removePredicate(remove2);
    changes.remove(predicate);
  }
  if (insert2) {
    changes.insert(insert2);
  }
  if (toggle) {
    predicate = removePredicate(toggle);
    if (input.value.some(predicate)) {
      changes.remove(predicate);
    } else {
      changes.insert(toggle);
    }
  }
  if (modify2) {
    for (key2 in values2) {
      changes.modify(modify2, key2, values2[key2]);
    }
  }
  return 1;
}
function pinchDistance(event2) {
  const t = event2.touches, dx = t[0].clientX - t[1].clientX, dy = t[0].clientY - t[1].clientY;
  return Math.hypot(dx, dy);
}
function pinchAngle(event2) {
  const t = event2.touches;
  return Math.atan2(t[0].clientY - t[1].clientY, t[0].clientX - t[1].clientX);
}
var accessors = {};
function pluck(data3, name) {
  const accessor2 = accessors[name] || (accessors[name] = field(name));
  return isArray(data3) ? data3.map(accessor2) : accessor2(data3);
}
function array3(seq) {
  return isArray(seq) || ArrayBuffer.isView(seq) ? seq : null;
}
function sequence2(seq) {
  return array3(seq) || (isString(seq) ? seq : null);
}
function join2(seq) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  return array3(seq).join(...args);
}
function indexof(seq) {
  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }
  return sequence2(seq).indexOf(...args);
}
function lastindexof(seq) {
  for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    args[_key3 - 1] = arguments[_key3];
  }
  return sequence2(seq).lastIndexOf(...args);
}
function slice2(seq) {
  for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
    args[_key4 - 1] = arguments[_key4];
  }
  return sequence2(seq).slice(...args);
}
function replace2(str, pattern, repl) {
  if (isFunction(repl))
    error("Function argument passed to replace.");
  return String(str).replace(pattern, repl);
}
function reverse(seq) {
  return array3(seq).slice().reverse();
}
function bandspace(count, paddingInner, paddingOuter) {
  return bandSpace(count || 0, paddingInner || 0, paddingOuter || 0);
}
function bandwidth(name, group2) {
  const s = getScale(name, (group2 || this).context);
  return s && s.bandwidth ? s.bandwidth() : 0;
}
function copy(name, group2) {
  const s = getScale(name, (group2 || this).context);
  return s ? s.copy() : void 0;
}
function domain(name, group2) {
  const s = getScale(name, (group2 || this).context);
  return s ? s.domain() : [];
}
function invert(name, range4, group2) {
  const s = getScale(name, (group2 || this).context);
  return !s ? void 0 : isArray(range4) ? (s.invertRange || s.invert)(range4) : (s.invert || s.invertExtent)(range4);
}
function range2(name, group2) {
  const s = getScale(name, (group2 || this).context);
  return s && s.range ? s.range() : [];
}
function scale3(name, value3, group2) {
  const s = getScale(name, (group2 || this).context);
  return s ? s(value3) : void 0;
}
function scaleGradient(scale6, p0, p1, count, group2) {
  scale6 = getScale(scale6, (group2 || this).context);
  const gradient3 = Gradient(p0, p1);
  let stops = scale6.domain(), min4 = stops[0], max4 = peek(stops), fraction = identity2;
  if (!(max4 - min4)) {
    scale6 = (scale6.interpolator ? scale("sequential")().interpolator(scale6.interpolator()) : scale("linear")().interpolate(scale6.interpolate()).range(scale6.range())).domain([min4 = 0, max4 = 1]);
  } else {
    fraction = scaleFraction(scale6, min4, max4);
  }
  if (scale6.ticks) {
    stops = scale6.ticks(+count || 15);
    if (min4 !== stops[0])
      stops.unshift(min4);
    if (max4 !== peek(stops))
      stops.push(max4);
  }
  stops.forEach((_) => gradient3.stop(fraction(_), scale6(_)));
  return gradient3;
}
function geoShape(projection3, geojson, group2) {
  const p = getScale(projection3, (group2 || this).context);
  return function(context3) {
    return p ? p.path.context(context3)(geojson) : "";
  };
}
function pathShape(path3) {
  let p = null;
  return function(context3) {
    return context3 ? pathRender(context3, p = p || parse4(path3)) : path3;
  };
}
var datum = (d) => d.data;
function treeNodes(name, context3) {
  const tree = data.call(context3, name);
  return tree.root && tree.root.lookup || {};
}
function treePath(name, source3, target2) {
  const nodes = treeNodes(name, this), s = nodes[source3], t = nodes[target2];
  return s && t ? s.path(t).map(datum) : void 0;
}
function treeAncestors(name, node) {
  const n = treeNodes(name, this)[node];
  return n ? n.ancestors().map(datum) : void 0;
}
var _window = () => typeof window !== "undefined" && window || null;
function screen() {
  const w3 = _window();
  return w3 ? w3.screen : {};
}
function windowSize() {
  const w3 = _window();
  return w3 ? [w3.innerWidth, w3.innerHeight] : [void 0, void 0];
}
function containerSize() {
  const view = this.context.dataflow, el = view.container && view.container();
  return el ? [el.clientWidth, el.clientHeight] : [void 0, void 0];
}
function intersect3(b2, opt, group2) {
  if (!b2)
    return [];
  const [u, v] = b2, box = new Bounds().set(u[0], u[1], v[0], v[1]), scene = group2 || this.context.dataflow.scenegraph().root;
  return intersect(scene, box, filter2(opt));
}
function filter2(opt) {
  let p = null;
  if (opt) {
    const types = array(opt.marktype), names = array(opt.markname);
    p = (_) => (!types.length || types.some((t) => _.marktype === t)) && (!names.length || names.some((s) => _.name === s));
  }
  return p;
}
function lassoAppend(lasso, x2, y2) {
  let minDist = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 5;
  lasso = array(lasso);
  const last = lasso[lasso.length - 1];
  return last === void 0 || Math.hypot(last[0] - x2, last[1] - y2) > minDist ? [...lasso, [x2, y2]] : lasso;
}
function lassoPath(lasso) {
  return array(lasso).reduce((svg, _ref, i) => {
    let [x2, y2] = _ref;
    return svg += i == 0 ? `M ${x2},${y2} ` : i === lasso.length - 1 ? " Z" : `L ${x2},${y2} `;
  }, "");
}
function intersectLasso(markname, pixelLasso, unit) {
  const {
    x: x2,
    y: y2,
    mark
  } = unit;
  const bb = new Bounds().set(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER, Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER);
  for (const [px2, py2] of pixelLasso) {
    if (px2 < bb.x1)
      bb.x1 = px2;
    if (px2 > bb.x2)
      bb.x2 = px2;
    if (py2 < bb.y1)
      bb.y1 = py2;
    if (py2 > bb.y2)
      bb.y2 = py2;
  }
  bb.translate(x2, y2);
  const intersection2 = intersect3([[bb.x1, bb.y1], [bb.x2, bb.y2]], markname, mark);
  return intersection2.filter((tuple) => pointInPolygon(tuple.x, tuple.y, pixelLasso));
}
function pointInPolygon(testx, testy, polygon) {
  let intersections = 0;
  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const [prevX, prevY] = polygon[j];
    const [x2, y2] = polygon[i];
    if (y2 > testy != prevY > testy && testx < (prevX - x2) * (testy - y2) / (prevY - y2) + x2) {
      intersections++;
    }
  }
  return intersections & 1;
}
var functionContext = {
  random() {
    return random();
  },
  // override default
  cumulativeNormal,
  cumulativeLogNormal,
  cumulativeUniform,
  densityNormal,
  densityLogNormal,
  densityUniform,
  quantileNormal,
  quantileLogNormal,
  quantileUniform,
  sampleNormal,
  sampleLogNormal,
  sampleUniform,
  isArray,
  isBoolean,
  isDate,
  isDefined(_) {
    return _ !== void 0;
  },
  isNumber,
  isObject,
  isRegExp,
  isString,
  isTuple,
  isValid(_) {
    return _ != null && _ === _;
  },
  toBoolean,
  toDate(_) {
    return toDate(_);
  },
  // suppress extra arguments
  toNumber,
  toString,
  indexof,
  join: join2,
  lastindexof,
  replace: replace2,
  reverse,
  slice: slice2,
  flush,
  lerp,
  merge: merge4,
  pad,
  peek,
  pluck,
  span,
  inrange,
  truncate,
  rgb,
  lab,
  hcl,
  hsl,
  luminance,
  contrast,
  sequence: range,
  format: format4,
  utcFormat: utcFormat2,
  utcParse: utcParse2,
  utcOffset,
  utcSequence,
  timeFormat: timeFormat2,
  timeParse: timeParse2,
  timeOffset,
  timeSequence,
  timeUnitSpecifier,
  monthFormat,
  monthAbbrevFormat,
  dayFormat,
  dayAbbrevFormat,
  quarter,
  utcquarter,
  week,
  utcweek,
  dayofyear,
  utcdayofyear,
  warn,
  info,
  debug,
  extent(_) {
    return extent(_);
  },
  // suppress extra arguments
  inScope,
  intersect: intersect3,
  clampRange,
  pinchDistance,
  pinchAngle,
  screen,
  containerSize,
  windowSize,
  bandspace,
  setdata,
  pathShape,
  panLinear,
  panLog,
  panPow,
  panSymlog,
  zoomLinear,
  zoomLog,
  zoomPow,
  zoomSymlog,
  encode,
  modify,
  lassoAppend,
  lassoPath,
  intersectLasso
};
var eventFunctions = ["view", "item", "group", "xy", "x", "y"];
var eventPrefix = "event.vega.";
var thisPrefix = "this.";
var astVisitors = {};
var codegenParams = {
  forbidden: ["_"],
  allowed: ["datum", "event", "item"],
  fieldvar: "datum",
  globalvar: (id2) => `_[${$(SignalPrefix + id2)}]`,
  functions: buildFunctions,
  constants: Constants,
  visitors: astVisitors
};
var codeGenerator = codegen(codegenParams);
function buildFunctions(codegen2) {
  const fn = Functions(codegen2);
  eventFunctions.forEach((name) => fn[name] = eventPrefix + name);
  for (const name in functionContext) {
    fn[name] = thisPrefix + name;
  }
  extend(fn, internalScaleFunctions(codegen2, functionContext, astVisitors));
  return fn;
}
function expressionFunction(name, fn, visitor) {
  if (arguments.length === 1) {
    return functionContext[name];
  }
  functionContext[name] = fn;
  if (visitor)
    astVisitors[name] = visitor;
  if (codeGenerator)
    codeGenerator.functions[name] = thisPrefix + name;
  return this;
}
expressionFunction("bandwidth", bandwidth, scaleVisitor);
expressionFunction("copy", copy, scaleVisitor);
expressionFunction("domain", domain, scaleVisitor);
expressionFunction("range", range2, scaleVisitor);
expressionFunction("invert", invert, scaleVisitor);
expressionFunction("scale", scale3, scaleVisitor);
expressionFunction("gradient", scaleGradient, scaleVisitor);
expressionFunction("geoArea", geoArea, scaleVisitor);
expressionFunction("geoBounds", geoBounds, scaleVisitor);
expressionFunction("geoCentroid", geoCentroid, scaleVisitor);
expressionFunction("geoShape", geoShape, scaleVisitor);
expressionFunction("geoScale", geoScale, scaleVisitor);
expressionFunction("indata", indata, indataVisitor);
expressionFunction("data", data, dataVisitor);
expressionFunction("treePath", treePath, dataVisitor);
expressionFunction("treeAncestors", treeAncestors, dataVisitor);
expressionFunction("vlSelectionTest", selectionTest, selectionVisitor);
expressionFunction("vlSelectionIdTest", selectionIdTest, selectionVisitor);
expressionFunction("vlSelectionResolve", selectionResolve, selectionVisitor);
expressionFunction("vlSelectionTuples", selectionTuples);
function parser2(expr2, scope) {
  const params2 = {};
  let ast;
  try {
    expr2 = isString(expr2) ? expr2 : $(expr2) + "";
    ast = parser(expr2);
  } catch (err) {
    error("Expression parse error: " + expr2);
  }
  ast.visit((node) => {
    if (node.type !== CallExpression)
      return;
    const name = node.callee.name, visit2 = codegenParams.visitors[name];
    if (visit2)
      visit2(name, node.arguments, scope, params2);
  });
  const gen = codeGenerator(ast);
  gen.globals.forEach((name) => {
    const signalName = SignalPrefix + name;
    if (!has(params2, signalName) && scope.getSignal(name)) {
      params2[signalName] = scope.signalRef(name);
    }
  });
  return {
    $expr: extend({
      code: gen.code
    }, scope.options.ast ? {
      ast
    } : null),
    $fields: gen.fields,
    $params: params2
  };
}

// node_modules/vega-runtime/build/vega-runtime.module.js
function parse5(spec) {
  const ctx = this, operators = spec.operators || [];
  if (spec.background) {
    ctx.background = spec.background;
  }
  if (spec.eventConfig) {
    ctx.eventConfig = spec.eventConfig;
  }
  if (spec.locale) {
    ctx.locale = spec.locale;
  }
  operators.forEach((entry2) => ctx.parseOperator(entry2));
  operators.forEach((entry2) => ctx.parseOperatorParameters(entry2));
  (spec.streams || []).forEach((entry2) => ctx.parseStream(entry2));
  (spec.updates || []).forEach((entry2) => ctx.parseUpdate(entry2));
  return ctx.resolve();
}
var Skip = toSet(["rule"]);
var Swap = toSet(["group", "image", "rect"]);
function adjustSpatial(encode2, marktype) {
  let code = "";
  if (Skip[marktype])
    return code;
  if (encode2.x2) {
    if (encode2.x) {
      if (Swap[marktype]) {
        code += "if(o.x>o.x2)$=o.x,o.x=o.x2,o.x2=$;";
      }
      code += "o.width=o.x2-o.x;";
    } else {
      code += "o.x=o.x2-(o.width||0);";
    }
  }
  if (encode2.xc) {
    code += "o.x=o.xc-(o.width||0)/2;";
  }
  if (encode2.y2) {
    if (encode2.y) {
      if (Swap[marktype]) {
        code += "if(o.y>o.y2)$=o.y,o.y=o.y2,o.y2=$;";
      }
      code += "o.height=o.y2-o.y;";
    } else {
      code += "o.y=o.y2-(o.height||0);";
    }
  }
  if (encode2.yc) {
    code += "o.y=o.yc-(o.height||0)/2;";
  }
  return code;
}
function canonicalType(type2) {
  return (type2 + "").toLowerCase();
}
function isOperator(type2) {
  return canonicalType(type2) === "operator";
}
function isCollect(type2) {
  return canonicalType(type2) === "collect";
}
function expression(ctx, args, code) {
  if (!code.endsWith(";")) {
    code = "return(" + code + ");";
  }
  const fn = Function(...args.concat(code));
  return ctx && ctx.functions ? fn.bind(ctx.functions) : fn;
}
function _compare(u, v, lt, gt) {
  return `((u = ${u}) < (v = ${v}) || u == null) && v != null ? ${lt}
  : (u > v || v == null) && u != null ? ${gt}
  : ((v = v instanceof Date ? +v : v), (u = u instanceof Date ? +u : u)) !== u && v === v ? ${lt}
  : v !== v && u === u ? ${gt} : `;
}
var expressionCodegen = {
  /**
   * Parse an expression used to update an operator value.
   */
  operator: (ctx, expr2) => expression(ctx, ["_"], expr2.code),
  /**
   * Parse an expression provided as an operator parameter value.
   */
  parameter: (ctx, expr2) => expression(ctx, ["datum", "_"], expr2.code),
  /**
   * Parse an expression applied to an event stream.
   */
  event: (ctx, expr2) => expression(ctx, ["event"], expr2.code),
  /**
   * Parse an expression used to handle an event-driven operator update.
   */
  handler: (ctx, expr2) => {
    const code = `var datum=event.item&&event.item.datum;return ${expr2.code};`;
    return expression(ctx, ["_", "event"], code);
  },
  /**
   * Parse an expression that performs visual encoding.
   */
  encode: (ctx, encode2) => {
    const {
      marktype,
      channels
    } = encode2;
    let code = "var o=item,datum=o.datum,m=0,$;";
    for (const name in channels) {
      const o = "o[" + $(name) + "]";
      code += `$=${channels[name].code};if(${o}!==$)${o}=$,m=1;`;
    }
    code += adjustSpatial(channels, marktype);
    code += "return m;";
    return expression(ctx, ["item", "_"], code);
  },
  /**
   * Optimized code generators for access and comparison.
   */
  codegen: {
    get(path3) {
      const ref2 = `[${path3.map($).join("][")}]`;
      const get5 = Function("_", `return _${ref2};`);
      get5.path = ref2;
      return get5;
    },
    comparator(fields, orders) {
      let t;
      const map2 = (f, i) => {
        const o = orders[i];
        let u, v;
        if (f.path) {
          u = `a${f.path}`;
          v = `b${f.path}`;
        } else {
          (t = t || {})["f" + i] = f;
          u = `this.f${i}(a)`;
          v = `this.f${i}(b)`;
        }
        return _compare(u, v, -o, o);
      };
      const fn = Function("a", "b", "var u, v; return " + fields.map(map2).join("") + "0;");
      return t ? fn.bind(t) : fn;
    }
  }
};
function parseOperator(spec) {
  const ctx = this;
  if (isOperator(spec.type) || !spec.type) {
    ctx.operator(spec, spec.update ? ctx.operatorExpression(spec.update) : null);
  } else {
    ctx.transform(spec, spec.type);
  }
}
function parseOperatorParameters(spec) {
  const ctx = this;
  if (spec.params) {
    const op = ctx.get(spec.id);
    if (!op)
      error("Invalid operator id: " + spec.id);
    ctx.dataflow.connect(op, op.parameters(ctx.parseParameters(spec.params), spec.react, spec.initonly));
  }
}
function parseParameters(spec, params2) {
  params2 = params2 || {};
  const ctx = this;
  for (const key2 in spec) {
    const value3 = spec[key2];
    params2[key2] = isArray(value3) ? value3.map((v) => parseParameter(v, ctx, params2)) : parseParameter(value3, ctx, params2);
  }
  return params2;
}
function parseParameter(spec, ctx, params2) {
  if (!spec || !isObject(spec))
    return spec;
  for (let i = 0, n = PARSERS.length, p; i < n; ++i) {
    p = PARSERS[i];
    if (has(spec, p.key)) {
      return p.parse(spec, ctx, params2);
    }
  }
  return spec;
}
var PARSERS = [{
  key: "$ref",
  parse: getOperator
}, {
  key: "$key",
  parse: getKey
}, {
  key: "$expr",
  parse: getExpression
}, {
  key: "$field",
  parse: getField2
}, {
  key: "$encode",
  parse: getEncode
}, {
  key: "$compare",
  parse: getCompare
}, {
  key: "$context",
  parse: getContext
}, {
  key: "$subflow",
  parse: getSubflow
}, {
  key: "$tupleid",
  parse: getTupleId
}];
function getOperator(_, ctx) {
  return ctx.get(_.$ref) || error("Operator not defined: " + _.$ref);
}
function getExpression(_, ctx, params2) {
  if (_.$params) {
    ctx.parseParameters(_.$params, params2);
  }
  const k2 = "e:" + _.$expr.code;
  return ctx.fn[k2] || (ctx.fn[k2] = accessor(ctx.parameterExpression(_.$expr), _.$fields));
}
function getKey(_, ctx) {
  const k2 = "k:" + _.$key + "_" + !!_.$flat;
  return ctx.fn[k2] || (ctx.fn[k2] = key(_.$key, _.$flat, ctx.expr.codegen));
}
function getField2(_, ctx) {
  if (!_.$field)
    return null;
  const k2 = "f:" + _.$field + "_" + _.$name;
  return ctx.fn[k2] || (ctx.fn[k2] = field(_.$field, _.$name, ctx.expr.codegen));
}
function getCompare(_, ctx) {
  const k2 = "c:" + _.$compare + "_" + _.$order, c = array(_.$compare).map((_2) => _2 && _2.$tupleid ? tupleid : _2);
  return ctx.fn[k2] || (ctx.fn[k2] = compare(c, _.$order, ctx.expr.codegen));
}
function getEncode(_, ctx) {
  const spec = _.$encode, encode2 = {};
  for (const name in spec) {
    const enc = spec[name];
    encode2[name] = accessor(ctx.encodeExpression(enc.$expr), enc.$fields);
    encode2[name].output = enc.$output;
  }
  return encode2;
}
function getContext(_, ctx) {
  return ctx;
}
function getSubflow(_, ctx) {
  const spec = _.$subflow;
  return function(dataflow, key2, parent) {
    const subctx = ctx.fork().parse(spec), op = subctx.get(spec.operators[0].id), p = subctx.signals.parent;
    if (p)
      p.set(parent);
    op.detachSubflow = () => ctx.detach(subctx);
    return op;
  };
}
function getTupleId() {
  return tupleid;
}
function parseStream(spec) {
  var ctx = this, filter3 = spec.filter != null ? ctx.eventExpression(spec.filter) : void 0, stream2 = spec.stream != null ? ctx.get(spec.stream) : void 0, args;
  if (spec.source) {
    stream2 = ctx.events(spec.source, spec.type, filter3);
  } else if (spec.merge) {
    args = spec.merge.map((_) => ctx.get(_));
    stream2 = args[0].merge.apply(args[0], args.slice(1));
  }
  if (spec.between) {
    args = spec.between.map((_) => ctx.get(_));
    stream2 = stream2.between(args[0], args[1]);
  }
  if (spec.filter) {
    stream2 = stream2.filter(filter3);
  }
  if (spec.throttle != null) {
    stream2 = stream2.throttle(+spec.throttle);
  }
  if (spec.debounce != null) {
    stream2 = stream2.debounce(+spec.debounce);
  }
  if (stream2 == null) {
    error("Invalid stream definition: " + JSON.stringify(spec));
  }
  if (spec.consume)
    stream2.consume(true);
  ctx.stream(spec, stream2);
}
function parseUpdate(spec) {
  var ctx = this, srcid = isObject(srcid = spec.source) ? srcid.$ref : srcid, source3 = ctx.get(srcid), target2 = null, update3 = spec.update, params2 = void 0;
  if (!source3)
    error("Source not defined: " + spec.source);
  target2 = spec.target && spec.target.$expr ? ctx.eventExpression(spec.target.$expr) : ctx.get(spec.target);
  if (update3 && update3.$expr) {
    if (update3.$params) {
      params2 = ctx.parseParameters(update3.$params);
    }
    update3 = ctx.handlerExpression(update3.$expr);
  }
  ctx.update(spec, source3, target2, update3, params2);
}
var SKIP3 = {
  skip: true
};
function getState(options) {
  var ctx = this, state = {};
  if (options.signals) {
    var signals = state.signals = {};
    Object.keys(ctx.signals).forEach((key2) => {
      const op = ctx.signals[key2];
      if (options.signals(key2, op)) {
        signals[key2] = op.value;
      }
    });
  }
  if (options.data) {
    var data3 = state.data = {};
    Object.keys(ctx.data).forEach((key2) => {
      const dataset = ctx.data[key2];
      if (options.data(key2, dataset)) {
        data3[key2] = dataset.input.value;
      }
    });
  }
  if (ctx.subcontext && options.recurse !== false) {
    state.subcontext = ctx.subcontext.map((ctx2) => ctx2.getState(options));
  }
  return state;
}
function setState(state) {
  var ctx = this, df = ctx.dataflow, data3 = state.data, signals = state.signals;
  Object.keys(signals || {}).forEach((key2) => {
    df.update(ctx.signals[key2], signals[key2], SKIP3);
  });
  Object.keys(data3 || {}).forEach((key2) => {
    df.pulse(ctx.data[key2].input, df.changeset().remove(truthy).insert(data3[key2]));
  });
  (state.subcontext || []).forEach((substate, i) => {
    const subctx = ctx.subcontext[i];
    if (subctx)
      subctx.setState(substate);
  });
}
function context2(df, transforms2, functions, expr2) {
  return new Context(df, transforms2, functions, expr2);
}
function Context(df, transforms2, functions, expr2) {
  this.dataflow = df;
  this.transforms = transforms2;
  this.events = df.events.bind(df);
  this.expr = expr2 || expressionCodegen, this.signals = {};
  this.scales = {};
  this.nodes = {};
  this.data = {};
  this.fn = {};
  if (functions) {
    this.functions = Object.create(functions);
    this.functions.context = this;
  }
}
function Subcontext(ctx) {
  this.dataflow = ctx.dataflow;
  this.transforms = ctx.transforms;
  this.events = ctx.events;
  this.expr = ctx.expr;
  this.signals = Object.create(ctx.signals);
  this.scales = Object.create(ctx.scales);
  this.nodes = Object.create(ctx.nodes);
  this.data = Object.create(ctx.data);
  this.fn = Object.create(ctx.fn);
  if (ctx.functions) {
    this.functions = Object.create(ctx.functions);
    this.functions.context = this;
  }
}
Context.prototype = Subcontext.prototype = {
  fork() {
    const ctx = new Subcontext(this);
    (this.subcontext || (this.subcontext = [])).push(ctx);
    return ctx;
  },
  detach(ctx) {
    this.subcontext = this.subcontext.filter((c) => c !== ctx);
    const keys3 = Object.keys(ctx.nodes);
    for (const key2 of keys3)
      ctx.nodes[key2]._targets = null;
    for (const key2 of keys3)
      ctx.nodes[key2].detach();
    ctx.nodes = null;
  },
  get(id2) {
    return this.nodes[id2];
  },
  set(id2, node) {
    return this.nodes[id2] = node;
  },
  add(spec, op) {
    const ctx = this, df = ctx.dataflow, data3 = spec.value;
    ctx.set(spec.id, op);
    if (isCollect(spec.type) && data3) {
      if (data3.$ingest) {
        df.ingest(op, data3.$ingest, data3.$format);
      } else if (data3.$request) {
        df.preload(op, data3.$request, data3.$format);
      } else {
        df.pulse(op, df.changeset().insert(data3));
      }
    }
    if (spec.root) {
      ctx.root = op;
    }
    if (spec.parent) {
      let p = ctx.get(spec.parent.$ref);
      if (p) {
        df.connect(p, [op]);
        op.targets().add(p);
      } else {
        (ctx.unresolved = ctx.unresolved || []).push(() => {
          p = ctx.get(spec.parent.$ref);
          df.connect(p, [op]);
          op.targets().add(p);
        });
      }
    }
    if (spec.signal) {
      ctx.signals[spec.signal] = op;
    }
    if (spec.scale) {
      ctx.scales[spec.scale] = op;
    }
    if (spec.data) {
      for (const name in spec.data) {
        const data4 = ctx.data[name] || (ctx.data[name] = {});
        spec.data[name].forEach((role) => data4[role] = op);
      }
    }
  },
  resolve() {
    (this.unresolved || []).forEach((fn) => fn());
    delete this.unresolved;
    return this;
  },
  operator(spec, update3) {
    this.add(spec, this.dataflow.add(spec.value, update3));
  },
  transform(spec, type2) {
    this.add(spec, this.dataflow.add(this.transforms[canonicalType(type2)]));
  },
  stream(spec, stream2) {
    this.set(spec.id, stream2);
  },
  update(spec, stream2, target2, update3, params2) {
    this.dataflow.on(stream2, target2, update3, params2, spec.options);
  },
  // expression parsing
  operatorExpression(expr2) {
    return this.expr.operator(this, expr2);
  },
  parameterExpression(expr2) {
    return this.expr.parameter(this, expr2);
  },
  eventExpression(expr2) {
    return this.expr.event(this, expr2);
  },
  handlerExpression(expr2) {
    return this.expr.handler(this, expr2);
  },
  encodeExpression(encode2) {
    return this.expr.encode(this, encode2);
  },
  // parse methods
  parse: parse5,
  parseOperator,
  parseOperatorParameters,
  parseParameters,
  parseStream,
  parseUpdate,
  // state methods
  getState,
  setState
};

// node_modules/vega-view/build/vega-view.module.js
function initializeAria(view) {
  const el = view.container();
  if (el) {
    el.setAttribute("role", "graphics-document");
    el.setAttribute("aria-roleDescription", "visualization");
    ariaLabel(el, view.description());
  }
}
function ariaLabel(el, desc) {
  if (el)
    desc == null ? el.removeAttribute("aria-label") : el.setAttribute("aria-label", desc);
}
function background2(view) {
  view.add(null, (_) => {
    view._background = _.bg;
    view._resize = 1;
    return _.bg;
  }, {
    bg: view._signals.background
  });
}
var Default = "default";
function cursor(view) {
  const cursor2 = view._signals.cursor || (view._signals.cursor = view.add({
    user: Default,
    item: null
  }));
  view.on(view.events("view", "pointermove"), cursor2, (_, event2) => {
    const value3 = cursor2.value, user = value3 ? isString(value3) ? value3 : value3.user : Default, item = event2.item && event2.item.cursor || null;
    return value3 && user === value3.user && item == value3.item ? value3 : {
      user,
      item
    };
  });
  view.add(null, function(_) {
    let user = _.cursor, item = this.value;
    if (!isString(user)) {
      item = user.item;
      user = user.user;
    }
    setCursor(view, user && user !== Default ? user : item || user);
    return item;
  }, {
    cursor: cursor2
  });
}
function setCursor(view, cursor2) {
  const el = view.globalCursor() ? typeof document !== "undefined" && document.body : view.container();
  if (el) {
    return cursor2 == null ? el.style.removeProperty("cursor") : el.style.cursor = cursor2;
  }
}
function dataref(view, name) {
  var data3 = view._runtime.data;
  if (!has(data3, name)) {
    error("Unrecognized data set: " + name);
  }
  return data3[name];
}
function data2(name, values2) {
  return arguments.length < 2 ? dataref(this, name).values.value : change.call(this, name, changeset().remove(truthy).insert(values2));
}
function change(name, changes) {
  if (!isChangeSet(changes)) {
    error("Second argument to changes must be a changeset.");
  }
  const dataset = dataref(this, name);
  dataset.modified = true;
  return this.pulse(dataset.input, changes);
}
function insert(name, _) {
  return change.call(this, name, changeset().insert(_));
}
function remove(name, _) {
  return change.call(this, name, changeset().remove(_));
}
function width(view) {
  var padding2 = view.padding();
  return Math.max(0, view._viewWidth + padding2.left + padding2.right);
}
function height(view) {
  var padding2 = view.padding();
  return Math.max(0, view._viewHeight + padding2.top + padding2.bottom);
}
function offset3(view) {
  var padding2 = view.padding(), origin = view._origin;
  return [padding2.left + origin[0], padding2.top + origin[1]];
}
function resizeRenderer(view) {
  var origin = offset3(view), w3 = width(view), h2 = height(view);
  view._renderer.background(view.background());
  view._renderer.resize(w3, h2, origin);
  view._handler.origin(origin);
  view._resizeListeners.forEach((handler) => {
    try {
      handler(w3, h2);
    } catch (error2) {
      view.error(error2);
    }
  });
}
function eventExtend(view, event2, item) {
  var r = view._renderer, el = r && r.canvas(), p, e, translate3;
  if (el) {
    translate3 = offset3(view);
    e = event2.changedTouches ? event2.changedTouches[0] : event2;
    p = point2(e, el);
    p[0] -= translate3[0];
    p[1] -= translate3[1];
  }
  event2.dataflow = view;
  event2.item = item;
  event2.vega = extension(view, item, p);
  return event2;
}
function extension(view, item, point3) {
  const itemGroup = item ? item.mark.marktype === "group" ? item : item.mark.group : null;
  function group2(name) {
    var g = itemGroup, i;
    if (name)
      for (i = item; i; i = i.mark.group) {
        if (i.mark.name === name) {
          g = i;
          break;
        }
      }
    return g && g.mark && g.mark.interactive ? g : {};
  }
  function xy(item2) {
    if (!item2)
      return point3;
    if (isString(item2))
      item2 = group2(item2);
    const p = point3.slice();
    while (item2) {
      p[0] -= item2.x || 0;
      p[1] -= item2.y || 0;
      item2 = item2.mark && item2.mark.group;
    }
    return p;
  }
  return {
    view: constant(view),
    item: constant(item || {}),
    group: group2,
    xy,
    x: (item2) => xy(item2)[0],
    y: (item2) => xy(item2)[1]
  };
}
var VIEW = "view";
var TIMER = "timer";
var WINDOW = "window";
var NO_TRAP = {
  trap: false
};
function initializeEventConfig(config) {
  const events3 = extend({
    defaults: {}
  }, config);
  const unpack = (obj, keys3) => {
    keys3.forEach((k2) => {
      if (isArray(obj[k2]))
        obj[k2] = toSet(obj[k2]);
    });
  };
  unpack(events3.defaults, ["prevent", "allow"]);
  unpack(events3, ["view", "window", "selector"]);
  return events3;
}
function trackEventListener(view, sources, type2, handler) {
  view._eventListeners.push({
    type: type2,
    sources: array(sources),
    handler
  });
}
function prevent(view, type2) {
  var def2 = view._eventConfig.defaults, prevent2 = def2.prevent, allow = def2.allow;
  return prevent2 === false || allow === true ? false : prevent2 === true || allow === false ? true : prevent2 ? prevent2[type2] : allow ? !allow[type2] : view.preventDefault();
}
function permit(view, key2, type2) {
  const rule3 = view._eventConfig && view._eventConfig[key2];
  if (rule3 === false || isObject(rule3) && !rule3[type2]) {
    view.warn(`Blocked ${key2} ${type2} event listener.`);
    return false;
  }
  return true;
}
function events2(source3, type2, filter3) {
  var view = this, s = new EventStream(filter3), send = function(e, item) {
    view.runAsync(null, () => {
      if (source3 === VIEW && prevent(view, type2)) {
        e.preventDefault();
      }
      s.receive(eventExtend(view, e, item));
    });
  }, sources;
  if (source3 === TIMER) {
    if (permit(view, "timer", type2)) {
      view.timer(send, type2);
    }
  } else if (source3 === VIEW) {
    if (permit(view, "view", type2)) {
      view.addEventListener(type2, send, NO_TRAP);
    }
  } else {
    if (source3 === WINDOW) {
      if (permit(view, "window", type2) && typeof window !== "undefined") {
        sources = [window];
      }
    } else if (typeof document !== "undefined") {
      if (permit(view, "selector", type2)) {
        sources = Array.from(document.querySelectorAll(source3));
      }
    }
    if (!sources) {
      view.warn("Can not resolve event source: " + source3);
    } else {
      for (var i = 0, n = sources.length; i < n; ++i) {
        sources[i].addEventListener(type2, send);
      }
      trackEventListener(view, sources, type2, send);
    }
  }
  return s;
}
function itemFilter(event2) {
  return event2.item;
}
function markTarget(event2) {
  return event2.item.mark.source;
}
function invoke(name) {
  return function(_, event2) {
    return event2.vega.view().changeset().encode(event2.item, name);
  };
}
function hover(hoverSet, leaveSet) {
  hoverSet = [hoverSet || "hover"];
  leaveSet = [leaveSet || "update", hoverSet[0]];
  this.on(this.events("view", "pointerover", itemFilter), markTarget, invoke(hoverSet));
  this.on(this.events("view", "pointerout", itemFilter), markTarget, invoke(leaveSet));
  return this;
}
function finalize() {
  var tooltip = this._tooltip, timers = this._timers, listeners = this._eventListeners, n, m, e;
  n = timers.length;
  while (--n >= 0) {
    timers[n].stop();
  }
  n = listeners.length;
  while (--n >= 0) {
    e = listeners[n];
    m = e.sources.length;
    while (--m >= 0) {
      e.sources[m].removeEventListener(e.type, e.handler);
    }
  }
  if (tooltip) {
    tooltip.call(this, this._handler, null, null, null);
  }
  return this;
}
function element2(tag, attr2, text2) {
  const el = document.createElement(tag);
  for (const key2 in attr2)
    el.setAttribute(key2, attr2[key2]);
  if (text2 != null)
    el.textContent = text2;
  return el;
}
var BindClass = "vega-bind";
var NameClass = "vega-bind-name";
var RadioClass = "vega-bind-radio";
function bind2(view, el, binding) {
  if (!el)
    return;
  const param2 = binding.param;
  let bind3 = binding.state;
  if (!bind3) {
    bind3 = binding.state = {
      elements: null,
      active: false,
      set: null,
      update: (value3) => {
        if (value3 != view.signal(param2.signal)) {
          view.runAsync(null, () => {
            bind3.source = true;
            view.signal(param2.signal, value3);
          });
        }
      }
    };
    if (param2.debounce) {
      bind3.update = debounce(param2.debounce, bind3.update);
    }
  }
  const create4 = param2.input == null && param2.element ? target : generate;
  create4(bind3, el, param2, view);
  if (!bind3.active) {
    view.on(view._signals[param2.signal], null, () => {
      bind3.source ? bind3.source = false : bind3.set(view.signal(param2.signal));
    });
    bind3.active = true;
  }
  return bind3;
}
function target(bind3, node, param2, view) {
  const type2 = param2.event || "input";
  const handler = () => bind3.update(node.value);
  view.signal(param2.signal, node.value);
  node.addEventListener(type2, handler);
  trackEventListener(view, node, type2, handler);
  bind3.set = (value3) => {
    node.value = value3;
    node.dispatchEvent(event(type2));
  };
}
function event(type2) {
  return typeof Event !== "undefined" ? new Event(type2) : {
    type: type2
  };
}
function generate(bind3, el, param2, view) {
  const value3 = view.signal(param2.signal);
  const div = element2("div", {
    "class": BindClass
  });
  const wrapper = param2.input === "radio" ? div : div.appendChild(element2("label"));
  wrapper.appendChild(element2("span", {
    "class": NameClass
  }, param2.name || param2.signal));
  el.appendChild(div);
  let input = form;
  switch (param2.input) {
    case "checkbox":
      input = checkbox;
      break;
    case "select":
      input = select;
      break;
    case "radio":
      input = radio;
      break;
    case "range":
      input = range3;
      break;
  }
  input(bind3, wrapper, param2, value3);
}
function form(bind3, el, param2, value3) {
  const node = element2("input");
  for (const key2 in param2) {
    if (key2 !== "signal" && key2 !== "element") {
      node.setAttribute(key2 === "input" ? "type" : key2, param2[key2]);
    }
  }
  node.setAttribute("name", param2.signal);
  node.value = value3;
  el.appendChild(node);
  node.addEventListener("input", () => bind3.update(node.value));
  bind3.elements = [node];
  bind3.set = (value4) => node.value = value4;
}
function checkbox(bind3, el, param2, value3) {
  const attr2 = {
    type: "checkbox",
    name: param2.signal
  };
  if (value3)
    attr2.checked = true;
  const node = element2("input", attr2);
  el.appendChild(node);
  node.addEventListener("change", () => bind3.update(node.checked));
  bind3.elements = [node];
  bind3.set = (value4) => node.checked = !!value4 || null;
}
function select(bind3, el, param2, value3) {
  const node = element2("select", {
    name: param2.signal
  }), labels = param2.labels || [];
  param2.options.forEach((option, i) => {
    const attr2 = {
      value: option
    };
    if (valuesEqual(option, value3))
      attr2.selected = true;
    node.appendChild(element2("option", attr2, (labels[i] || option) + ""));
  });
  el.appendChild(node);
  node.addEventListener("change", () => {
    bind3.update(param2.options[node.selectedIndex]);
  });
  bind3.elements = [node];
  bind3.set = (value4) => {
    for (let i = 0, n = param2.options.length; i < n; ++i) {
      if (valuesEqual(param2.options[i], value4)) {
        node.selectedIndex = i;
        return;
      }
    }
  };
}
function radio(bind3, el, param2, value3) {
  const group2 = element2("span", {
    "class": RadioClass
  }), labels = param2.labels || [];
  el.appendChild(group2);
  bind3.elements = param2.options.map((option, i) => {
    const attr2 = {
      type: "radio",
      name: param2.signal,
      value: option
    };
    if (valuesEqual(option, value3))
      attr2.checked = true;
    const input = element2("input", attr2);
    input.addEventListener("change", () => bind3.update(option));
    const label = element2("label", {}, (labels[i] || option) + "");
    label.prepend(input);
    group2.appendChild(label);
    return input;
  });
  bind3.set = (value4) => {
    const nodes = bind3.elements, n = nodes.length;
    for (let i = 0; i < n; ++i) {
      if (valuesEqual(nodes[i].value, value4))
        nodes[i].checked = true;
    }
  };
}
function range3(bind3, el, param2, value3) {
  value3 = value3 !== void 0 ? value3 : (+param2.max + +param2.min) / 2;
  const max4 = param2.max != null ? param2.max : Math.max(100, +value3) || 100, min4 = param2.min || Math.min(0, max4, +value3) || 0, step = param2.step || tickStep(min4, max4, 100);
  const node = element2("input", {
    type: "range",
    name: param2.signal,
    min: min4,
    max: max4,
    step
  });
  node.value = value3;
  const span2 = element2("span", {}, +value3);
  el.appendChild(node);
  el.appendChild(span2);
  const update3 = () => {
    span2.textContent = node.value;
    bind3.update(+node.value);
  };
  node.addEventListener("input", update3);
  node.addEventListener("change", update3);
  bind3.elements = [node];
  bind3.set = (value4) => {
    node.value = value4;
    span2.textContent = value4;
  };
}
function valuesEqual(a, b2) {
  return a === b2 || a + "" === b2 + "";
}
function initializeRenderer(view, r, el, constructor, scaleFactor, opt) {
  r = r || new constructor(view.loader());
  return r.initialize(el, width(view), height(view), offset3(view), scaleFactor, opt).background(view.background());
}
function trap(view, fn) {
  return !fn ? null : function() {
    try {
      fn.apply(this, arguments);
    } catch (error2) {
      view.error(error2);
    }
  };
}
function initializeHandler(view, prevHandler, el, constructor) {
  const handler = new constructor(view.loader(), trap(view, view.tooltip())).scene(view.scenegraph().root).initialize(el, offset3(view), view);
  if (prevHandler) {
    prevHandler.handlers().forEach((h2) => {
      handler.on(h2.type, h2.handler);
    });
  }
  return handler;
}
function initialize2(el, elBind) {
  const view = this, type2 = view._renderType, config = view._eventConfig.bind, module = renderModule(type2);
  el = view._el = el ? lookup4(view, el, true) : null;
  initializeAria(view);
  if (!module)
    view.error("Unrecognized renderer type: " + type2);
  const Handler2 = module.handler || CanvasHandler, Renderer2 = el ? module.renderer : module.headless;
  view._renderer = !Renderer2 ? null : initializeRenderer(view, view._renderer, el, Renderer2);
  view._handler = initializeHandler(view, view._handler, el, Handler2);
  view._redraw = true;
  if (el && config !== "none") {
    elBind = elBind ? view._elBind = lookup4(view, elBind, true) : el.appendChild(element2("form", {
      "class": "vega-bindings"
    }));
    view._bind.forEach((_) => {
      if (_.param.element && config !== "container") {
        _.element = lookup4(view, _.param.element, !!_.param.input);
      }
    });
    view._bind.forEach((_) => {
      bind2(view, _.element || elBind, _);
    });
  }
  return view;
}
function lookup4(view, el, clear) {
  if (typeof el === "string") {
    if (typeof document !== "undefined") {
      el = document.querySelector(el);
      if (!el) {
        view.error("Signal bind element not found: " + el);
        return null;
      }
    } else {
      view.error("DOM document instance not found.");
      return null;
    }
  }
  if (el && clear) {
    try {
      el.textContent = "";
    } catch (e) {
      el = null;
      view.error(e);
    }
  }
  return el;
}
var number3 = (_) => +_ || 0;
var paddingObject = (_) => ({
  top: _,
  bottom: _,
  left: _,
  right: _
});
function padding(_) {
  return isObject(_) ? {
    top: number3(_.top),
    bottom: number3(_.bottom),
    left: number3(_.left),
    right: number3(_.right)
  } : paddingObject(number3(_));
}
async function renderHeadless(view, type2, scaleFactor, opt) {
  const module = renderModule(type2), ctr = module && module.headless;
  if (!ctr)
    error("Unrecognized renderer type: " + type2);
  await view.runAsync();
  return initializeRenderer(view, null, null, ctr, scaleFactor, opt).renderAsync(view._scenegraph.root);
}
async function renderToImageURL(type2, scaleFactor) {
  if (type2 !== RenderType.Canvas && type2 !== RenderType.SVG && type2 !== RenderType.PNG) {
    error("Unrecognized image type: " + type2);
  }
  const r = await renderHeadless(this, type2, scaleFactor);
  return type2 === RenderType.SVG ? toBlobURL(r.svg(), "image/svg+xml") : r.canvas().toDataURL("image/png");
}
function toBlobURL(data3, mime) {
  const blob = new Blob([data3], {
    type: mime
  });
  return window.URL.createObjectURL(blob);
}
async function renderToCanvas(scaleFactor, opt) {
  const r = await renderHeadless(this, RenderType.Canvas, scaleFactor, opt);
  return r.canvas();
}
async function renderToSVG(scaleFactor) {
  const r = await renderHeadless(this, RenderType.SVG, scaleFactor);
  return r.svg();
}
function runtime(view, spec, expr2) {
  return context2(view, transforms, functionContext, expr2).parse(spec);
}
function scale4(name) {
  var scales2 = this._runtime.scales;
  if (!has(scales2, name)) {
    error("Unrecognized scale or projection: " + name);
  }
  return scales2[name].value;
}
var Width = "width";
var Height = "height";
var Padding2 = "padding";
var Skip2 = {
  skip: true
};
function viewWidth(view, width2) {
  var a = view.autosize(), p = view.padding();
  return width2 - (a && a.contains === Padding2 ? p.left + p.right : 0);
}
function viewHeight(view, height2) {
  var a = view.autosize(), p = view.padding();
  return height2 - (a && a.contains === Padding2 ? p.top + p.bottom : 0);
}
function initializeResize(view) {
  var s = view._signals, w3 = s[Width], h2 = s[Height], p = s[Padding2];
  function resetSize() {
    view._autosize = view._resize = 1;
  }
  view._resizeWidth = view.add(null, (_) => {
    view._width = _.size;
    view._viewWidth = viewWidth(view, _.size);
    resetSize();
  }, {
    size: w3
  });
  view._resizeHeight = view.add(null, (_) => {
    view._height = _.size;
    view._viewHeight = viewHeight(view, _.size);
    resetSize();
  }, {
    size: h2
  });
  const resizePadding = view.add(null, resetSize, {
    pad: p
  });
  view._resizeWidth.rank = w3.rank + 1;
  view._resizeHeight.rank = h2.rank + 1;
  resizePadding.rank = p.rank + 1;
}
function resizeView(viewWidth2, viewHeight2, width2, height2, origin, auto) {
  this.runAfter((view) => {
    let rerun2 = 0;
    view._autosize = 0;
    if (view.width() !== width2) {
      rerun2 = 1;
      view.signal(Width, width2, Skip2);
      view._resizeWidth.skip(true);
    }
    if (view.height() !== height2) {
      rerun2 = 1;
      view.signal(Height, height2, Skip2);
      view._resizeHeight.skip(true);
    }
    if (view._viewWidth !== viewWidth2) {
      view._resize = 1;
      view._viewWidth = viewWidth2;
    }
    if (view._viewHeight !== viewHeight2) {
      view._resize = 1;
      view._viewHeight = viewHeight2;
    }
    if (view._origin[0] !== origin[0] || view._origin[1] !== origin[1]) {
      view._resize = 1;
      view._origin = origin;
    }
    if (rerun2)
      view.run("enter");
    if (auto)
      view.runAfter((v) => v.resize());
  }, false, 1);
}
function getState2(options) {
  return this._runtime.getState(options || {
    data: dataTest,
    signals: signalTest,
    recurse: true
  });
}
function dataTest(name, data3) {
  return data3.modified && isArray(data3.input.value) && !name.startsWith("_:vega:_");
}
function signalTest(name, op) {
  return !(name === "parent" || op instanceof transforms.proxy);
}
function setState2(state) {
  this.runAsync(null, (v) => {
    v._trigger = false;
    v._runtime.setState(state);
  }, (v) => {
    v._trigger = true;
  });
  return this;
}
function timer(callback, delay) {
  function tick(elapsed) {
    callback({
      timestamp: Date.now(),
      elapsed
    });
  }
  this._timers.push(interval_default(tick, delay));
}
function defaultTooltip2(handler, event2, item, value3) {
  const el = handler.element();
  if (el)
    el.setAttribute("title", formatTooltip(value3));
}
function formatTooltip(value3) {
  return value3 == null ? "" : isArray(value3) ? formatArray(value3) : isObject(value3) && !isDate(value3) ? formatObject(value3) : value3 + "";
}
function formatObject(obj) {
  return Object.keys(obj).map((key2) => {
    const v = obj[key2];
    return key2 + ": " + (isArray(v) ? formatArray(v) : formatValue2(v));
  }).join("\n");
}
function formatArray(value3) {
  return "[" + value3.map(formatValue2).join(", ") + "]";
}
function formatValue2(value3) {
  return isArray(value3) ? "[…]" : isObject(value3) && !isDate(value3) ? "{…}" : value3;
}
function watchPixelRatio() {
  if (this.renderer() === "canvas" && this._renderer._canvas) {
    let remove2 = null;
    const updatePixelRatio = () => {
      if (remove2 != null) {
        remove2();
      }
      const media = matchMedia(`(resolution: ${window.devicePixelRatio}dppx)`);
      media.addEventListener("change", updatePixelRatio);
      remove2 = () => {
        media.removeEventListener("change", updatePixelRatio);
      };
      this._renderer._canvas.getContext("2d").pixelRatio = window.devicePixelRatio || 1;
      this._redraw = true;
      this._resize = 1;
      this.resize().runAsync();
    };
    updatePixelRatio();
  }
}
function View(spec, options) {
  const view = this;
  options = options || {};
  Dataflow.call(view);
  if (options.loader)
    view.loader(options.loader);
  if (options.logger)
    view.logger(options.logger);
  if (options.logLevel != null)
    view.logLevel(options.logLevel);
  if (options.locale || spec.locale) {
    const loc = extend({}, spec.locale, options.locale);
    view.locale(locale(loc.number, loc.time));
  }
  view._el = null;
  view._elBind = null;
  view._renderType = options.renderer || RenderType.Canvas;
  view._scenegraph = new Scenegraph();
  const root = view._scenegraph.root;
  view._renderer = null;
  view._tooltip = options.tooltip || defaultTooltip2, view._redraw = true;
  view._handler = new CanvasHandler().scene(root);
  view._globalCursor = false;
  view._preventDefault = false;
  view._timers = [];
  view._eventListeners = [];
  view._resizeListeners = [];
  view._eventConfig = initializeEventConfig(spec.eventConfig);
  view.globalCursor(view._eventConfig.globalCursor);
  const ctx = runtime(view, spec, options.expr);
  view._runtime = ctx;
  view._signals = ctx.signals;
  view._bind = (spec.bindings || []).map((_) => ({
    state: null,
    param: extend({}, _)
  }));
  if (ctx.root)
    ctx.root.set(root);
  root.source = ctx.data.root.input;
  view.pulse(ctx.data.root.input, view.changeset().insert(root.items));
  view._width = view.width();
  view._height = view.height();
  view._viewWidth = viewWidth(view, view._width);
  view._viewHeight = viewHeight(view, view._height);
  view._origin = [0, 0];
  view._resize = 0;
  view._autosize = 1;
  initializeResize(view);
  background2(view);
  cursor(view);
  view.description(spec.description);
  if (options.hover)
    view.hover();
  if (options.container)
    view.initialize(options.container, options.bind);
  if (options.watchPixelRatio)
    view._watchPixelRatio();
}
function lookupSignal(view, name) {
  return has(view._signals, name) ? view._signals[name] : error("Unrecognized signal name: " + $(name));
}
function findOperatorHandler(op, handler) {
  const h2 = (op._targets || []).filter((op2) => op2._update && op2._update.handler === handler);
  return h2.length ? h2[0] : null;
}
function addOperatorListener(view, name, op, handler) {
  let h2 = findOperatorHandler(op, handler);
  if (!h2) {
    h2 = trap(view, () => handler(name, op.value));
    h2.handler = handler;
    view.on(op, null, h2);
  }
  return view;
}
function removeOperatorListener(view, op, handler) {
  const h2 = findOperatorHandler(op, handler);
  if (h2)
    op._targets.remove(h2);
  return view;
}
inherits(View, Dataflow, {
  // -- DATAFLOW / RENDERING ----
  async evaluate(encode2, prerun, postrun) {
    await Dataflow.prototype.evaluate.call(this, encode2, prerun);
    if (this._redraw || this._resize) {
      try {
        if (this._renderer) {
          if (this._resize) {
            this._resize = 0;
            resizeRenderer(this);
          }
          await this._renderer.renderAsync(this._scenegraph.root);
        }
        this._redraw = false;
      } catch (e) {
        this.error(e);
      }
    }
    if (postrun)
      asyncCallback(this, postrun);
    return this;
  },
  dirty(item) {
    this._redraw = true;
    this._renderer && this._renderer.dirty(item);
  },
  // -- GET / SET ----
  description(text2) {
    if (arguments.length) {
      const desc = text2 != null ? text2 + "" : null;
      if (desc !== this._desc)
        ariaLabel(this._el, this._desc = desc);
      return this;
    }
    return this._desc;
  },
  container() {
    return this._el;
  },
  scenegraph() {
    return this._scenegraph;
  },
  origin() {
    return this._origin.slice();
  },
  signal(name, value3, options) {
    const op = lookupSignal(this, name);
    return arguments.length === 1 ? op.value : this.update(op, value3, options);
  },
  width(_) {
    return arguments.length ? this.signal("width", _) : this.signal("width");
  },
  height(_) {
    return arguments.length ? this.signal("height", _) : this.signal("height");
  },
  padding(_) {
    return arguments.length ? this.signal("padding", padding(_)) : padding(this.signal("padding"));
  },
  autosize(_) {
    return arguments.length ? this.signal("autosize", _) : this.signal("autosize");
  },
  background(_) {
    return arguments.length ? this.signal("background", _) : this.signal("background");
  },
  renderer(type2) {
    if (!arguments.length)
      return this._renderType;
    if (!renderModule(type2))
      error("Unrecognized renderer type: " + type2);
    if (type2 !== this._renderType) {
      this._renderType = type2;
      this._resetRenderer();
    }
    return this;
  },
  tooltip(handler) {
    if (!arguments.length)
      return this._tooltip;
    if (handler !== this._tooltip) {
      this._tooltip = handler;
      this._resetRenderer();
    }
    return this;
  },
  loader(loader2) {
    if (!arguments.length)
      return this._loader;
    if (loader2 !== this._loader) {
      Dataflow.prototype.loader.call(this, loader2);
      this._resetRenderer();
    }
    return this;
  },
  resize() {
    this._autosize = 1;
    return this.touch(lookupSignal(this, "autosize"));
  },
  _resetRenderer() {
    if (this._renderer) {
      this._renderer = null;
      this.initialize(this._el, this._elBind);
    }
  },
  // -- SIZING ----
  _resizeView: resizeView,
  // -- EVENT HANDLING ----
  addEventListener(type2, handler, options) {
    let callback = handler;
    if (!(options && options.trap === false)) {
      callback = trap(this, handler);
      callback.raw = handler;
    }
    this._handler.on(type2, callback);
    return this;
  },
  removeEventListener(type2, handler) {
    var handlers = this._handler.handlers(type2), i = handlers.length, h2, t;
    while (--i >= 0) {
      t = handlers[i].type;
      h2 = handlers[i].handler;
      if (type2 === t && (handler === h2 || handler === h2.raw)) {
        this._handler.off(t, h2);
        break;
      }
    }
    return this;
  },
  addResizeListener(handler) {
    const l = this._resizeListeners;
    if (!l.includes(handler)) {
      l.push(handler);
    }
    return this;
  },
  removeResizeListener(handler) {
    var l = this._resizeListeners, i = l.indexOf(handler);
    if (i >= 0) {
      l.splice(i, 1);
    }
    return this;
  },
  addSignalListener(name, handler) {
    return addOperatorListener(this, name, lookupSignal(this, name), handler);
  },
  removeSignalListener(name, handler) {
    return removeOperatorListener(this, lookupSignal(this, name), handler);
  },
  addDataListener(name, handler) {
    return addOperatorListener(this, name, dataref(this, name).values, handler);
  },
  removeDataListener(name, handler) {
    return removeOperatorListener(this, dataref(this, name).values, handler);
  },
  globalCursor(_) {
    if (arguments.length) {
      if (this._globalCursor !== !!_) {
        const prev = setCursor(this, null);
        this._globalCursor = !!_;
        if (prev)
          setCursor(this, prev);
      }
      return this;
    } else {
      return this._globalCursor;
    }
  },
  preventDefault(_) {
    if (arguments.length) {
      this._preventDefault = _;
      return this;
    } else {
      return this._preventDefault;
    }
  },
  timer,
  events: events2,
  finalize,
  hover,
  // -- DATA ----
  data: data2,
  change,
  insert,
  remove,
  // -- SCALES --
  scale: scale4,
  // -- INITIALIZATION ----
  initialize: initialize2,
  // -- HEADLESS RENDERING ----
  toImageURL: renderToImageURL,
  toCanvas: renderToCanvas,
  toSVG: renderToSVG,
  // -- SAVE / RESTORE STATE ----
  getState: getState2,
  setState: setState2,
  // RE-RENDER ON ZOOM
  _watchPixelRatio: watchPixelRatio
});

// node_modules/vega-event-selector/build/vega-event-selector.module.js
var VIEW2 = "view";
var LBRACK = "[";
var RBRACK = "]";
var LBRACE = "{";
var RBRACE = "}";
var COLON = ":";
var COMMA = ",";
var NAME = "@";
var GT = ">";
var ILLEGAL2 = /[[\]{}]/;
var DEFAULT_MARKS = {
  "*": 1,
  arc: 1,
  area: 1,
  group: 1,
  image: 1,
  line: 1,
  path: 1,
  rect: 1,
  rule: 1,
  shape: 1,
  symbol: 1,
  text: 1,
  trail: 1
};
var DEFAULT_SOURCE;
var MARKS;
function eventSelector(selector, source3, marks) {
  DEFAULT_SOURCE = source3 || VIEW2;
  MARKS = marks || DEFAULT_MARKS;
  return parseMerge(selector.trim()).map(parseSelector);
}
function isMarkType(type2) {
  return MARKS[type2];
}
function find2(s, i, endChar, pushChar, popChar) {
  const n = s.length;
  let count = 0, c;
  for (; i < n; ++i) {
    c = s[i];
    if (!count && c === endChar)
      return i;
    else if (popChar && popChar.indexOf(c) >= 0)
      --count;
    else if (pushChar && pushChar.indexOf(c) >= 0)
      ++count;
  }
  return i;
}
function parseMerge(s) {
  const output3 = [], n = s.length;
  let start = 0, i = 0;
  while (i < n) {
    i = find2(s, i, COMMA, LBRACK + LBRACE, RBRACK + RBRACE);
    output3.push(s.substring(start, i).trim());
    start = ++i;
  }
  if (output3.length === 0) {
    throw "Empty event selector: " + s;
  }
  return output3;
}
function parseSelector(s) {
  return s[0] === "[" ? parseBetween(s) : parseStream2(s);
}
function parseBetween(s) {
  const n = s.length;
  let i = 1, b2;
  i = find2(s, i, RBRACK, LBRACK, RBRACK);
  if (i === n) {
    throw "Empty between selector: " + s;
  }
  b2 = parseMerge(s.substring(1, i));
  if (b2.length !== 2) {
    throw "Between selector must have two elements: " + s;
  }
  s = s.slice(i + 1).trim();
  if (s[0] !== GT) {
    throw "Expected '>' after between selector: " + s;
  }
  b2 = b2.map(parseSelector);
  const stream2 = parseSelector(s.slice(1).trim());
  if (stream2.between) {
    return {
      between: b2,
      stream: stream2
    };
  } else {
    stream2.between = b2;
  }
  return stream2;
}
function parseStream2(s) {
  const stream2 = {
    source: DEFAULT_SOURCE
  }, source3 = [];
  let throttle = [0, 0], markname = 0, start = 0, n = s.length, i = 0, j, filter3;
  if (s[n - 1] === RBRACE) {
    i = s.lastIndexOf(LBRACE);
    if (i >= 0) {
      try {
        throttle = parseThrottle(s.substring(i + 1, n - 1));
      } catch (e) {
        throw "Invalid throttle specification: " + s;
      }
      s = s.slice(0, i).trim();
      n = s.length;
    } else
      throw "Unmatched right brace: " + s;
    i = 0;
  }
  if (!n)
    throw s;
  if (s[0] === NAME)
    markname = ++i;
  j = find2(s, i, COLON);
  if (j < n) {
    source3.push(s.substring(start, j).trim());
    start = i = ++j;
  }
  i = find2(s, i, LBRACK);
  if (i === n) {
    source3.push(s.substring(start, n).trim());
  } else {
    source3.push(s.substring(start, i).trim());
    filter3 = [];
    start = ++i;
    if (start === n)
      throw "Unmatched left bracket: " + s;
  }
  while (i < n) {
    i = find2(s, i, RBRACK);
    if (i === n)
      throw "Unmatched left bracket: " + s;
    filter3.push(s.substring(start, i).trim());
    if (i < n - 1 && s[++i] !== LBRACK)
      throw "Expected left bracket: " + s;
    start = ++i;
  }
  if (!(n = source3.length) || ILLEGAL2.test(source3[n - 1])) {
    throw "Invalid event selector: " + s;
  }
  if (n > 1) {
    stream2.type = source3[1];
    if (markname) {
      stream2.markname = source3[0].slice(1);
    } else if (isMarkType(source3[0])) {
      stream2.marktype = source3[0];
    } else {
      stream2.source = source3[0];
    }
  } else {
    stream2.type = source3[0];
  }
  if (stream2.type.slice(-1) === "!") {
    stream2.consume = true;
    stream2.type = stream2.type.slice(0, -1);
  }
  if (filter3 != null)
    stream2.filter = filter3;
  if (throttle[0])
    stream2.throttle = throttle[0];
  if (throttle[1])
    stream2.debounce = throttle[1];
  return stream2;
}
function parseThrottle(s) {
  const a = s.split(COMMA);
  if (!s.length || a.length > 2)
    throw s;
  return a.map((_) => {
    const x2 = +_;
    if (x2 !== x2)
      throw s;
    return x2;
  });
}

// node_modules/vega-parser/build/vega-parser.module.js
function parseAutosize(spec) {
  return isObject(spec) ? spec : {
    type: spec || "pad"
  };
}
var number4 = (_) => +_ || 0;
var paddingObject2 = (_) => ({
  top: _,
  bottom: _,
  left: _,
  right: _
});
function parsePadding(spec) {
  return !isObject(spec) ? paddingObject2(number4(spec)) : spec.signal ? spec : {
    top: number4(spec.top),
    bottom: number4(spec.bottom),
    left: number4(spec.left),
    right: number4(spec.right)
  };
}
var encoder = (_) => isObject(_) && !isArray(_) ? extend({}, _) : {
  value: _
};
function addEncode(object2, name, value3, set4) {
  if (value3 != null) {
    const isEncoder = isObject(value3) && !isArray(value3) || isArray(value3) && value3.length && isObject(value3[0]);
    if (isEncoder) {
      object2.update[name] = value3;
    } else {
      object2[set4 || "enter"][name] = {
        value: value3
      };
    }
    return 1;
  } else {
    return 0;
  }
}
function addEncoders(object2, enter, update3) {
  for (const name in enter) {
    addEncode(object2, name, enter[name]);
  }
  for (const name in update3) {
    addEncode(object2, name, update3[name], "update");
  }
}
function extendEncode(encode2, extra, skip) {
  for (const name in extra) {
    if (skip && has(skip, name))
      continue;
    encode2[name] = extend(encode2[name] || {}, extra[name]);
  }
  return encode2;
}
function has2(key2, encode2) {
  return encode2 && (encode2.enter && encode2.enter[key2] || encode2.update && encode2.update[key2]);
}
var MarkRole = "mark";
var FrameRole2 = "frame";
var ScopeRole2 = "scope";
var AxisRole2 = "axis";
var AxisDomainRole = "axis-domain";
var AxisGridRole = "axis-grid";
var AxisLabelRole = "axis-label";
var AxisTickRole = "axis-tick";
var AxisTitleRole = "axis-title";
var LegendRole2 = "legend";
var LegendBandRole = "legend-band";
var LegendEntryRole = "legend-entry";
var LegendGradientRole = "legend-gradient";
var LegendLabelRole = "legend-label";
var LegendSymbolRole = "legend-symbol";
var LegendTitleRole = "legend-title";
var TitleRole2 = "title";
var TitleTextRole = "title-text";
var TitleSubtitleRole = "title-subtitle";
function applyDefaults(encode2, type2, role, style2, config) {
  const defaults2 = {}, enter = {};
  let update3, key2, skip, props;
  key2 = "lineBreak";
  if (type2 === "text" && config[key2] != null && !has2(key2, encode2)) {
    applyDefault(defaults2, key2, config[key2]);
  }
  if (role == "legend" || String(role).startsWith("axis")) {
    role = null;
  }
  props = role === FrameRole2 ? config.group : role === MarkRole ? extend({}, config.mark, config[type2]) : null;
  for (key2 in props) {
    skip = has2(key2, encode2) || (key2 === "fill" || key2 === "stroke") && (has2("fill", encode2) || has2("stroke", encode2));
    if (!skip)
      applyDefault(defaults2, key2, props[key2]);
  }
  array(style2).forEach((name) => {
    const props2 = config.style && config.style[name];
    for (const key3 in props2) {
      if (!has2(key3, encode2)) {
        applyDefault(defaults2, key3, props2[key3]);
      }
    }
  });
  encode2 = extend({}, encode2);
  for (key2 in defaults2) {
    props = defaults2[key2];
    if (props.signal) {
      (update3 = update3 || {})[key2] = props;
    } else {
      enter[key2] = props;
    }
  }
  encode2.enter = extend(enter, encode2.enter);
  if (update3)
    encode2.update = extend(update3, encode2.update);
  return encode2;
}
function applyDefault(defaults2, key2, value3) {
  defaults2[key2] = value3 && value3.signal ? {
    signal: value3.signal
  } : {
    value: value3
  };
}
var scaleRef = (scale6) => isString(scale6) ? $(scale6) : scale6.signal ? `(${scale6.signal})` : field2(scale6);
function entry$1(enc) {
  if (enc.gradient != null) {
    return gradient2(enc);
  }
  let value3 = enc.signal ? `(${enc.signal})` : enc.color ? color2(enc.color) : enc.field != null ? field2(enc.field) : enc.value !== void 0 ? $(enc.value) : void 0;
  if (enc.scale != null) {
    value3 = scale5(enc, value3);
  }
  if (value3 === void 0) {
    value3 = null;
  }
  if (enc.exponent != null) {
    value3 = `pow(${value3},${property(enc.exponent)})`;
  }
  if (enc.mult != null) {
    value3 += `*${property(enc.mult)}`;
  }
  if (enc.offset != null) {
    value3 += `+${property(enc.offset)}`;
  }
  if (enc.round) {
    value3 = `round(${value3})`;
  }
  return value3;
}
var _color = (type2, x2, y2, z) => `(${type2}(${[x2, y2, z].map(entry$1).join(",")})+'')`;
function color2(enc) {
  return enc.c ? _color("hcl", enc.h, enc.c, enc.l) : enc.h || enc.s ? _color("hsl", enc.h, enc.s, enc.l) : enc.l || enc.a ? _color("lab", enc.l, enc.a, enc.b) : enc.r || enc.g || enc.b ? _color("rgb", enc.r, enc.g, enc.b) : null;
}
function gradient2(enc) {
  const args = [enc.start, enc.stop, enc.count].map((_) => _ == null ? null : $(_));
  while (args.length && peek(args) == null)
    args.pop();
  args.unshift(scaleRef(enc.gradient));
  return `gradient(${args.join(",")})`;
}
function property(property2) {
  return isObject(property2) ? "(" + entry$1(property2) + ")" : property2;
}
function field2(ref2) {
  return resolveField(isObject(ref2) ? ref2 : {
    datum: ref2
  });
}
function resolveField(ref2) {
  let object2, level, field3;
  if (ref2.signal) {
    object2 = "datum";
    field3 = ref2.signal;
  } else if (ref2.group || ref2.parent) {
    level = Math.max(1, ref2.level || 1);
    object2 = "item";
    while (level-- > 0) {
      object2 += ".mark.group";
    }
    if (ref2.parent) {
      field3 = ref2.parent;
      object2 += ".datum";
    } else {
      field3 = ref2.group;
    }
  } else if (ref2.datum) {
    object2 = "datum";
    field3 = ref2.datum;
  } else {
    error("Invalid field reference: " + $(ref2));
  }
  if (!ref2.signal) {
    field3 = isString(field3) ? splitAccessPath(field3).map($).join("][") : resolveField(field3);
  }
  return object2 + "[" + field3 + "]";
}
function scale5(enc, value3) {
  const scale6 = scaleRef(enc.scale);
  if (enc.range != null) {
    value3 = `lerp(_range(${scale6}), ${+enc.range})`;
  } else {
    if (value3 !== void 0)
      value3 = `_scale(${scale6}, ${value3})`;
    if (enc.band) {
      value3 = (value3 ? value3 + "+" : "") + `_bandwidth(${scale6})` + (+enc.band === 1 ? "" : "*" + property(enc.band));
      if (enc.extra) {
        value3 = `(datum.extra ? _scale(${scale6}, datum.extra.value) : ${value3})`;
      }
    }
    if (value3 == null)
      value3 = "0";
  }
  return value3;
}
function rule2(enc) {
  let code = "";
  enc.forEach((rule3) => {
    const value3 = entry$1(rule3);
    code += rule3.test ? `(${rule3.test})?${value3}:` : value3;
  });
  if (peek(code) === ":") {
    code += "null";
  }
  return code;
}
function parseEncode(encode2, type2, role, style2, scope, params2) {
  const enc = {};
  params2 = params2 || {};
  params2.encoders = {
    $encode: enc
  };
  encode2 = applyDefaults(encode2, type2, role, style2, scope.config);
  for (const key2 in encode2) {
    enc[key2] = parseBlock(encode2[key2], type2, params2, scope);
  }
  return params2;
}
function parseBlock(block, marktype, params2, scope) {
  const channels = {}, fields = {};
  for (const name in block) {
    if (block[name] != null) {
      channels[name] = parse$1(expr(block[name]), scope, params2, fields);
    }
  }
  return {
    $expr: {
      marktype,
      channels
    },
    $fields: Object.keys(fields),
    $output: Object.keys(block)
  };
}
function expr(enc) {
  return isArray(enc) ? rule2(enc) : entry$1(enc);
}
function parse$1(code, scope, params2, fields) {
  const expr2 = parser2(code, scope);
  expr2.$fields.forEach((name) => fields[name] = 1);
  extend(params2, expr2.$params);
  return expr2.$expr;
}
var OUTER = "outer";
var OUTER_INVALID = ["value", "update", "init", "react", "bind"];
function outerError(prefix, name) {
  error(prefix + ' for "outer" push: ' + $(name));
}
function parseSignal(signal, scope) {
  const name = signal.name;
  if (signal.push === OUTER) {
    if (!scope.signals[name])
      outerError("No prior signal definition", name);
    OUTER_INVALID.forEach((prop) => {
      if (signal[prop] !== void 0)
        outerError("Invalid property ", prop);
    });
  } else {
    const op = scope.addSignal(name, signal.value);
    if (signal.react === false)
      op.react = false;
    if (signal.bind)
      scope.addBinding(name, signal.bind);
  }
}
function Entry(type2, value3, params2, parent) {
  this.id = -1;
  this.type = type2;
  this.value = value3;
  this.params = params2;
  if (parent)
    this.parent = parent;
}
function entry(type2, value3, params2, parent) {
  return new Entry(type2, value3, params2, parent);
}
function operator(value3, params2) {
  return entry("operator", value3, params2);
}
function ref(op) {
  const ref2 = {
    $ref: op.id
  };
  if (op.id < 0)
    (op.refs = op.refs || []).push(ref2);
  return ref2;
}
function fieldRef$1(field3, name) {
  return name ? {
    $field: field3,
    $name: name
  } : {
    $field: field3
  };
}
var keyFieldRef = fieldRef$1("key");
function compareRef(fields, orders) {
  return {
    $compare: fields,
    $order: orders
  };
}
function keyRef(fields, flat) {
  const ref2 = {
    $key: fields
  };
  if (flat)
    ref2.$flat = true;
  return ref2;
}
var Ascending = "ascending";
var Descending = "descending";
function sortKey(sort2) {
  return !isObject(sort2) ? "" : (sort2.order === Descending ? "-" : "+") + aggrField(sort2.op, sort2.field);
}
function aggrField(op, field3) {
  return (op && op.signal ? "$" + op.signal : op || "") + (op && field3 ? "_" : "") + (field3 && field3.signal ? "$" + field3.signal : field3 || "");
}
var Scope$1 = "scope";
var View2 = "view";
function isSignal(_) {
  return _ && _.signal;
}
function isExpr$1(_) {
  return _ && _.expr;
}
function hasSignal(_) {
  if (isSignal(_))
    return true;
  if (isObject(_))
    for (const key2 in _) {
      if (hasSignal(_[key2]))
        return true;
    }
  return false;
}
function value2(specValue, defaultValue) {
  return specValue != null ? specValue : defaultValue;
}
function deref(v) {
  return v && v.signal || v;
}
var Timer = "timer";
function parseStream3(stream2, scope) {
  const method2 = stream2.merge ? mergeStream : stream2.stream ? nestedStream : stream2.type ? eventStream : error("Invalid stream specification: " + $(stream2));
  return method2(stream2, scope);
}
function eventSource(source3) {
  return source3 === Scope$1 ? View2 : source3 || View2;
}
function mergeStream(stream2, scope) {
  const list = stream2.merge.map((s) => parseStream3(s, scope)), entry2 = streamParameters({
    merge: list
  }, stream2, scope);
  return scope.addStream(entry2).id;
}
function nestedStream(stream2, scope) {
  const id2 = parseStream3(stream2.stream, scope), entry2 = streamParameters({
    stream: id2
  }, stream2, scope);
  return scope.addStream(entry2).id;
}
function eventStream(stream2, scope) {
  let id2;
  if (stream2.type === Timer) {
    id2 = scope.event(Timer, stream2.throttle);
    stream2 = {
      between: stream2.between,
      filter: stream2.filter
    };
  } else {
    id2 = scope.event(eventSource(stream2.source), stream2.type);
  }
  const entry2 = streamParameters({
    stream: id2
  }, stream2, scope);
  return Object.keys(entry2).length === 1 ? id2 : scope.addStream(entry2).id;
}
function streamParameters(entry2, stream2, scope) {
  let param2 = stream2.between;
  if (param2) {
    if (param2.length !== 2) {
      error('Stream "between" parameter must have 2 entries: ' + $(stream2));
    }
    entry2.between = [parseStream3(param2[0], scope), parseStream3(param2[1], scope)];
  }
  param2 = stream2.filter ? [].concat(stream2.filter) : [];
  if (stream2.marktype || stream2.markname || stream2.markrole) {
    param2.push(filterMark(stream2.marktype, stream2.markname, stream2.markrole));
  }
  if (stream2.source === Scope$1) {
    param2.push("inScope(event.item)");
  }
  if (param2.length) {
    entry2.filter = parser2("(" + param2.join(")&&(") + ")", scope).$expr;
  }
  if ((param2 = stream2.throttle) != null) {
    entry2.throttle = +param2;
  }
  if ((param2 = stream2.debounce) != null) {
    entry2.debounce = +param2;
  }
  if (stream2.consume) {
    entry2.consume = true;
  }
  return entry2;
}
function filterMark(type2, name, role) {
  const item = "event.item";
  return item + (type2 && type2 !== "*" ? "&&" + item + ".mark.marktype==='" + type2 + "'" : "") + (role ? "&&" + item + ".mark.role==='" + role + "'" : "") + (name ? "&&" + item + ".mark.name==='" + name + "'" : "");
}
var OP_VALUE_EXPR = {
  code: "_.$value",
  ast: {
    type: "Identifier",
    value: "value"
  }
};
function parseUpdate2(spec, scope, target2) {
  const encode2 = spec.encode, entry2 = {
    target: target2
  };
  let events3 = spec.events, update3 = spec.update, sources = [];
  if (!events3) {
    error("Signal update missing events specification.");
  }
  if (isString(events3)) {
    events3 = eventSelector(events3, scope.isSubscope() ? Scope$1 : View2);
  }
  events3 = array(events3).filter((s) => s.signal || s.scale ? (sources.push(s), 0) : 1);
  if (sources.length > 1) {
    sources = [mergeSources(sources)];
  }
  if (events3.length) {
    sources.push(events3.length > 1 ? {
      merge: events3
    } : events3[0]);
  }
  if (encode2 != null) {
    if (update3)
      error("Signal encode and update are mutually exclusive.");
    update3 = "encode(item()," + $(encode2) + ")";
  }
  entry2.update = isString(update3) ? parser2(update3, scope) : update3.expr != null ? parser2(update3.expr, scope) : update3.value != null ? update3.value : update3.signal != null ? {
    $expr: OP_VALUE_EXPR,
    $params: {
      $value: scope.signalRef(update3.signal)
    }
  } : error("Invalid signal update specification.");
  if (spec.force) {
    entry2.options = {
      force: true
    };
  }
  sources.forEach((source3) => scope.addUpdate(extend(streamSource(source3, scope), entry2)));
}
function streamSource(stream2, scope) {
  return {
    source: stream2.signal ? scope.signalRef(stream2.signal) : stream2.scale ? scope.scaleRef(stream2.scale) : parseStream3(stream2, scope)
  };
}
function mergeSources(sources) {
  return {
    signal: "[" + sources.map((s) => s.scale ? 'scale("' + s.scale + '")' : s.signal) + "]"
  };
}
function parseSignalUpdates(signal, scope) {
  const op = scope.getSignal(signal.name);
  let expr2 = signal.update;
  if (signal.init) {
    if (expr2) {
      error("Signals can not include both init and update expressions.");
    } else {
      expr2 = signal.init;
      op.initonly = true;
    }
  }
  if (expr2) {
    expr2 = parser2(expr2, scope);
    op.update = expr2.$expr;
    op.params = expr2.$params;
  }
  if (signal.on) {
    signal.on.forEach((_) => parseUpdate2(_, scope, op.id));
  }
}
var transform3 = (name) => (params2, value3, parent) => entry(name, value3, params2 || void 0, parent);
var Aggregate2 = transform3("aggregate");
var AxisTicks2 = transform3("axisticks");
var Bound2 = transform3("bound");
var Collect2 = transform3("collect");
var Compare2 = transform3("compare");
var DataJoin2 = transform3("datajoin");
var Encode2 = transform3("encode");
var Expression2 = transform3("expression");
var Facet2 = transform3("facet");
var Field2 = transform3("field");
var Key2 = transform3("key");
var LegendEntries2 = transform3("legendentries");
var Load2 = transform3("load");
var Mark2 = transform3("mark");
var MultiExtent2 = transform3("multiextent");
var MultiValues2 = transform3("multivalues");
var Overlap2 = transform3("overlap");
var Params3 = transform3("params");
var PreFacet2 = transform3("prefacet");
var Projection2 = transform3("projection");
var Proxy2 = transform3("proxy");
var Relay2 = transform3("relay");
var Render2 = transform3("render");
var Scale2 = transform3("scale");
var Sieve2 = transform3("sieve");
var SortItems2 = transform3("sortitems");
var ViewLayout2 = transform3("viewlayout");
var Values2 = transform3("values");
var FIELD_REF_ID = 0;
var MULTIDOMAIN_SORT_OPS = {
  min: "min",
  max: "max",
  count: "sum"
};
function initScale(spec, scope) {
  const type2 = spec.type || "linear";
  if (!isValidScaleType(type2)) {
    error("Unrecognized scale type: " + $(type2));
  }
  scope.addScale(spec.name, {
    type: type2,
    domain: void 0
  });
}
function parseScale(spec, scope) {
  const params2 = scope.getScale(spec.name).params;
  let key2;
  params2.domain = parseScaleDomain(spec.domain, spec, scope);
  if (spec.range != null) {
    params2.range = parseScaleRange(spec, scope, params2);
  }
  if (spec.interpolate != null) {
    parseScaleInterpolate(spec.interpolate, params2);
  }
  if (spec.nice != null) {
    params2.nice = parseScaleNice(spec.nice, scope);
  }
  if (spec.bins != null) {
    params2.bins = parseScaleBins(spec.bins, scope);
  }
  for (key2 in spec) {
    if (has(params2, key2) || key2 === "name")
      continue;
    params2[key2] = parseLiteral(spec[key2], scope);
  }
}
function parseLiteral(v, scope) {
  return !isObject(v) ? v : v.signal ? scope.signalRef(v.signal) : error("Unsupported object: " + $(v));
}
function parseArray(v, scope) {
  return v.signal ? scope.signalRef(v.signal) : v.map((v2) => parseLiteral(v2, scope));
}
function dataLookupError(name) {
  error("Can not find data set: " + $(name));
}
function parseScaleDomain(domain2, spec, scope) {
  if (!domain2) {
    if (spec.domainMin != null || spec.domainMax != null) {
      error("No scale domain defined for domainMin/domainMax to override.");
    }
    return;
  }
  return domain2.signal ? scope.signalRef(domain2.signal) : (isArray(domain2) ? explicitDomain : domain2.fields ? multipleDomain : singularDomain)(domain2, spec, scope);
}
function explicitDomain(domain2, spec, scope) {
  return domain2.map((v) => parseLiteral(v, scope));
}
function singularDomain(domain2, spec, scope) {
  const data3 = scope.getData(domain2.data);
  if (!data3)
    dataLookupError(domain2.data);
  return isDiscrete(spec.type) ? data3.valuesRef(scope, domain2.field, parseSort(domain2.sort, false)) : isQuantile(spec.type) ? data3.domainRef(scope, domain2.field) : data3.extentRef(scope, domain2.field);
}
function multipleDomain(domain2, spec, scope) {
  const data3 = domain2.data, fields = domain2.fields.reduce((dom, d) => {
    d = isString(d) ? {
      data: data3,
      field: d
    } : isArray(d) || d.signal ? fieldRef(d, scope) : d;
    dom.push(d);
    return dom;
  }, []);
  return (isDiscrete(spec.type) ? ordinalMultipleDomain : isQuantile(spec.type) ? quantileMultipleDomain : numericMultipleDomain)(domain2, scope, fields);
}
function fieldRef(data3, scope) {
  const name = "_:vega:_" + FIELD_REF_ID++, coll = Collect2({});
  if (isArray(data3)) {
    coll.value = {
      $ingest: data3
    };
  } else if (data3.signal) {
    const code = "setdata(" + $(name) + "," + data3.signal + ")";
    coll.params.input = scope.signalRef(code);
  }
  scope.addDataPipeline(name, [coll, Sieve2({})]);
  return {
    data: name,
    field: "data"
  };
}
function ordinalMultipleDomain(domain2, scope, fields) {
  const sort2 = parseSort(domain2.sort, true);
  let a, v;
  const counts = fields.map((f) => {
    const data3 = scope.getData(f.data);
    if (!data3)
      dataLookupError(f.data);
    return data3.countsRef(scope, f.field, sort2);
  });
  const p = {
    groupby: keyFieldRef,
    pulse: counts
  };
  if (sort2) {
    a = sort2.op || "count";
    v = sort2.field ? aggrField(a, sort2.field) : "count";
    p.ops = [MULTIDOMAIN_SORT_OPS[a]];
    p.fields = [scope.fieldRef(v)];
    p.as = [v];
  }
  a = scope.add(Aggregate2(p));
  const c = scope.add(Collect2({
    pulse: ref(a)
  }));
  v = scope.add(Values2({
    field: keyFieldRef,
    sort: scope.sortRef(sort2),
    pulse: ref(c)
  }));
  return ref(v);
}
function parseSort(sort2, multidomain) {
  if (sort2) {
    if (!sort2.field && !sort2.op) {
      if (isObject(sort2))
        sort2.field = "key";
      else
        sort2 = {
          field: "key"
        };
    } else if (!sort2.field && sort2.op !== "count") {
      error("No field provided for sort aggregate op: " + sort2.op);
    } else if (multidomain && sort2.field) {
      if (sort2.op && !MULTIDOMAIN_SORT_OPS[sort2.op]) {
        error("Multiple domain scales can not be sorted using " + sort2.op);
      }
    }
  }
  return sort2;
}
function quantileMultipleDomain(domain2, scope, fields) {
  const values2 = fields.map((f) => {
    const data3 = scope.getData(f.data);
    if (!data3)
      dataLookupError(f.data);
    return data3.domainRef(scope, f.field);
  });
  return ref(scope.add(MultiValues2({
    values: values2
  })));
}
function numericMultipleDomain(domain2, scope, fields) {
  const extents = fields.map((f) => {
    const data3 = scope.getData(f.data);
    if (!data3)
      dataLookupError(f.data);
    return data3.extentRef(scope, f.field);
  });
  return ref(scope.add(MultiExtent2({
    extents
  })));
}
function parseScaleBins(v, scope) {
  return v.signal || isArray(v) ? parseArray(v, scope) : scope.objectProperty(v);
}
function parseScaleNice(nice, scope) {
  return nice.signal ? scope.signalRef(nice.signal) : isObject(nice) ? {
    interval: parseLiteral(nice.interval),
    step: parseLiteral(nice.step)
  } : parseLiteral(nice);
}
function parseScaleInterpolate(interpolate2, params2) {
  params2.interpolate = parseLiteral(interpolate2.type || interpolate2);
  if (interpolate2.gamma != null) {
    params2.interpolateGamma = parseLiteral(interpolate2.gamma);
  }
}
function parseScaleRange(spec, scope, params2) {
  const config = scope.config.range;
  let range4 = spec.range;
  if (range4.signal) {
    return scope.signalRef(range4.signal);
  } else if (isString(range4)) {
    if (config && has(config, range4)) {
      spec = extend({}, spec, {
        range: config[range4]
      });
      return parseScaleRange(spec, scope, params2);
    } else if (range4 === "width") {
      range4 = [0, {
        signal: "width"
      }];
    } else if (range4 === "height") {
      range4 = isDiscrete(spec.type) ? [0, {
        signal: "height"
      }] : [{
        signal: "height"
      }, 0];
    } else {
      error("Unrecognized scale range value: " + $(range4));
    }
  } else if (range4.scheme) {
    params2.scheme = isArray(range4.scheme) ? parseArray(range4.scheme, scope) : parseLiteral(range4.scheme, scope);
    if (range4.extent)
      params2.schemeExtent = parseArray(range4.extent, scope);
    if (range4.count)
      params2.schemeCount = parseLiteral(range4.count, scope);
    return;
  } else if (range4.step) {
    params2.rangeStep = parseLiteral(range4.step, scope);
    return;
  } else if (isDiscrete(spec.type) && !isArray(range4)) {
    return parseScaleDomain(range4, spec, scope);
  } else if (!isArray(range4)) {
    error("Unsupported range type: " + $(range4));
  }
  return range4.map((v) => (isArray(v) ? parseArray : parseLiteral)(v, scope));
}
function parseProjection(proj, scope) {
  const config = scope.config.projection || {}, params2 = {};
  for (const name in proj) {
    if (name === "name")
      continue;
    params2[name] = parseParameter$1(proj[name], name, scope);
  }
  for (const name in config) {
    if (params2[name] == null) {
      params2[name] = parseParameter$1(config[name], name, scope);
    }
  }
  scope.addProjection(proj.name, params2);
}
function parseParameter$1(_, name, scope) {
  return isArray(_) ? _.map((_2) => parseParameter$1(_2, name, scope)) : !isObject(_) ? _ : _.signal ? scope.signalRef(_.signal) : name === "fit" ? _ : error("Unsupported parameter object: " + $(_));
}
var Top2 = "top";
var Left2 = "left";
var Right2 = "right";
var Bottom2 = "bottom";
var Center2 = "center";
var Vertical = "vertical";
var Start2 = "start";
var Middle2 = "middle";
var End2 = "end";
var Index = "index";
var Label2 = "label";
var Offset = "offset";
var Perc = "perc";
var Perc2 = "perc2";
var Value = "value";
var GuideLabelStyle = "guide-label";
var GuideTitleStyle = "guide-title";
var GroupTitleStyle = "group-title";
var GroupSubtitleStyle = "group-subtitle";
var Symbols2 = "symbol";
var Gradient2 = "gradient";
var Discrete2 = "discrete";
var Size = "size";
var Shape = "shape";
var Fill = "fill";
var Stroke = "stroke";
var StrokeWidth = "strokeWidth";
var StrokeDash = "strokeDash";
var Opacity = "opacity";
var LegendScales = [Size, Shape, Fill, Stroke, StrokeWidth, StrokeDash, Opacity];
var Skip3 = {
  name: 1,
  style: 1,
  interactive: 1
};
var zero2 = {
  value: 0
};
var one2 = {
  value: 1
};
var GroupMark = "group";
var RectMark = "rect";
var RuleMark = "rule";
var SymbolMark = "symbol";
var TextMark = "text";
function guideGroup(mark) {
  mark.type = GroupMark;
  mark.interactive = mark.interactive || false;
  return mark;
}
function lookup5(spec, config) {
  const _ = (name, dflt) => value2(spec[name], value2(config[name], dflt));
  _.isVertical = (s) => Vertical === value2(spec.direction, config.direction || (s ? config.symbolDirection : config.gradientDirection));
  _.gradientLength = () => value2(spec.gradientLength, config.gradientLength || config.gradientWidth);
  _.gradientThickness = () => value2(spec.gradientThickness, config.gradientThickness || config.gradientHeight);
  _.entryColumns = () => value2(spec.columns, value2(config.columns, +_.isVertical(true)));
  return _;
}
function getEncoding(name, encode2) {
  const v = encode2 && (encode2.update && encode2.update[name] || encode2.enter && encode2.enter[name]);
  return v && v.signal ? v : v ? v.value : null;
}
function getStyle(name, scope, style2) {
  const s = scope.config.style[style2];
  return s && s[name];
}
function anchorExpr(s, e, m) {
  return `item.anchor === '${Start2}' ? ${s} : item.anchor === '${End2}' ? ${e} : ${m}`;
}
var alignExpr$1 = anchorExpr($(Left2), $(Right2), $(Center2));
function tickBand(_) {
  const v = _("tickBand");
  let offset4 = _("tickOffset"), band2, extra;
  if (!v) {
    band2 = _("bandPosition");
    extra = _("tickExtra");
  } else if (v.signal) {
    band2 = {
      signal: `(${v.signal}) === 'extent' ? 1 : 0.5`
    };
    extra = {
      signal: `(${v.signal}) === 'extent'`
    };
    if (!isObject(offset4)) {
      offset4 = {
        signal: `(${v.signal}) === 'extent' ? 0 : ${offset4}`
      };
    }
  } else if (v === "extent") {
    band2 = 1;
    extra = true;
    offset4 = 0;
  } else {
    band2 = 0.5;
    extra = false;
  }
  return {
    extra,
    band: band2,
    offset: offset4
  };
}
function extendOffset(value3, offset4) {
  return !offset4 ? value3 : !value3 ? offset4 : !isObject(value3) ? {
    value: value3,
    offset: offset4
  } : Object.assign({}, value3, {
    offset: extendOffset(value3.offset, offset4)
  });
}
function guideMark(mark, extras) {
  if (extras) {
    mark.name = extras.name;
    mark.style = extras.style || mark.style;
    mark.interactive = !!extras.interactive;
    mark.encode = extendEncode(mark.encode, extras, Skip3);
  } else {
    mark.interactive = false;
  }
  return mark;
}
function legendGradient(spec, scale6, config, userEncode) {
  const _ = lookup5(spec, config), vertical = _.isVertical(), thickness = _.gradientThickness(), length2 = _.gradientLength();
  let enter, start, stop2, width2, height2;
  if (vertical) {
    start = [0, 1];
    stop2 = [0, 0];
    width2 = thickness;
    height2 = length2;
  } else {
    start = [0, 0];
    stop2 = [1, 0];
    width2 = length2;
    height2 = thickness;
  }
  const encode2 = {
    enter: enter = {
      opacity: zero2,
      x: zero2,
      y: zero2,
      width: encoder(width2),
      height: encoder(height2)
    },
    update: extend({}, enter, {
      opacity: one2,
      fill: {
        gradient: scale6,
        start,
        stop: stop2
      }
    }),
    exit: {
      opacity: zero2
    }
  };
  addEncoders(encode2, {
    stroke: _("gradientStrokeColor"),
    strokeWidth: _("gradientStrokeWidth")
  }, {
    // update
    opacity: _("gradientOpacity")
  });
  return guideMark({
    type: RectMark,
    role: LegendGradientRole,
    encode: encode2
  }, userEncode);
}
function legendGradientDiscrete(spec, scale6, config, userEncode, dataRef) {
  const _ = lookup5(spec, config), vertical = _.isVertical(), thickness = _.gradientThickness(), length2 = _.gradientLength();
  let u, v, uu, vv, adjust = "";
  vertical ? (u = "y", uu = "y2", v = "x", vv = "width", adjust = "1-") : (u = "x", uu = "x2", v = "y", vv = "height");
  const enter = {
    opacity: zero2,
    fill: {
      scale: scale6,
      field: Value
    }
  };
  enter[u] = {
    signal: adjust + "datum." + Perc,
    mult: length2
  };
  enter[v] = zero2;
  enter[uu] = {
    signal: adjust + "datum." + Perc2,
    mult: length2
  };
  enter[vv] = encoder(thickness);
  const encode2 = {
    enter,
    update: extend({}, enter, {
      opacity: one2
    }),
    exit: {
      opacity: zero2
    }
  };
  addEncoders(encode2, {
    stroke: _("gradientStrokeColor"),
    strokeWidth: _("gradientStrokeWidth")
  }, {
    // update
    opacity: _("gradientOpacity")
  });
  return guideMark({
    type: RectMark,
    role: LegendBandRole,
    key: Value,
    from: dataRef,
    encode: encode2
  }, userEncode);
}
var alignExpr = `datum.${Perc}<=0?"${Left2}":datum.${Perc}>=1?"${Right2}":"${Center2}"`;
var baselineExpr = `datum.${Perc}<=0?"${Bottom2}":datum.${Perc}>=1?"${Top2}":"${Middle2}"`;
function legendGradientLabels(spec, config, userEncode, dataRef) {
  const _ = lookup5(spec, config), vertical = _.isVertical(), thickness = encoder(_.gradientThickness()), length2 = _.gradientLength();
  let overlap = _("labelOverlap"), enter, update3, u, v, adjust = "";
  const encode2 = {
    enter: enter = {
      opacity: zero2
    },
    update: update3 = {
      opacity: one2,
      text: {
        field: Label2
      }
    },
    exit: {
      opacity: zero2
    }
  };
  addEncoders(encode2, {
    fill: _("labelColor"),
    fillOpacity: _("labelOpacity"),
    font: _("labelFont"),
    fontSize: _("labelFontSize"),
    fontStyle: _("labelFontStyle"),
    fontWeight: _("labelFontWeight"),
    limit: value2(spec.labelLimit, config.gradientLabelLimit)
  });
  if (vertical) {
    enter.align = {
      value: "left"
    };
    enter.baseline = update3.baseline = {
      signal: baselineExpr
    };
    u = "y";
    v = "x";
    adjust = "1-";
  } else {
    enter.align = update3.align = {
      signal: alignExpr
    };
    enter.baseline = {
      value: "top"
    };
    u = "x";
    v = "y";
  }
  enter[u] = update3[u] = {
    signal: adjust + "datum." + Perc,
    mult: length2
  };
  enter[v] = update3[v] = thickness;
  thickness.offset = value2(spec.labelOffset, config.gradientLabelOffset) || 0;
  overlap = overlap ? {
    separation: _("labelSeparation"),
    method: overlap,
    order: "datum." + Index
  } : void 0;
  return guideMark({
    type: TextMark,
    role: LegendLabelRole,
    style: GuideLabelStyle,
    key: Value,
    from: dataRef,
    encode: encode2,
    overlap
  }, userEncode);
}
function legendSymbolGroups(spec, config, userEncode, dataRef, columns) {
  const _ = lookup5(spec, config), entries = userEncode.entries, interactive2 = !!(entries && entries.interactive), name = entries ? entries.name : void 0, height2 = _("clipHeight"), symbolOffset = _("symbolOffset"), valueRef = {
    data: "value"
  }, xSignal = `(${columns}) ? datum.${Offset} : datum.${Size}`, yEncode = height2 ? encoder(height2) : {
    field: Size
  }, index2 = `datum.${Index}`, ncols = `max(1, ${columns})`;
  let encode2, enter, update3, nrows, sort2;
  yEncode.mult = 0.5;
  encode2 = {
    enter: enter = {
      opacity: zero2,
      x: {
        signal: xSignal,
        mult: 0.5,
        offset: symbolOffset
      },
      y: yEncode
    },
    update: update3 = {
      opacity: one2,
      x: enter.x,
      y: enter.y
    },
    exit: {
      opacity: zero2
    }
  };
  let baseFill = null, baseStroke = null;
  if (!spec.fill) {
    baseFill = config.symbolBaseFillColor;
    baseStroke = config.symbolBaseStrokeColor;
  }
  addEncoders(encode2, {
    fill: _("symbolFillColor", baseFill),
    shape: _("symbolType"),
    size: _("symbolSize"),
    stroke: _("symbolStrokeColor", baseStroke),
    strokeDash: _("symbolDash"),
    strokeDashOffset: _("symbolDashOffset"),
    strokeWidth: _("symbolStrokeWidth")
  }, {
    // update
    opacity: _("symbolOpacity")
  });
  LegendScales.forEach((scale6) => {
    if (spec[scale6]) {
      update3[scale6] = enter[scale6] = {
        scale: spec[scale6],
        field: Value
      };
    }
  });
  const symbols3 = guideMark({
    type: SymbolMark,
    role: LegendSymbolRole,
    key: Value,
    from: valueRef,
    clip: height2 ? true : void 0,
    encode: encode2
  }, userEncode.symbols);
  const labelOffset = encoder(symbolOffset);
  labelOffset.offset = _("labelOffset");
  encode2 = {
    enter: enter = {
      opacity: zero2,
      x: {
        signal: xSignal,
        offset: labelOffset
      },
      y: yEncode
    },
    update: update3 = {
      opacity: one2,
      text: {
        field: Label2
      },
      x: enter.x,
      y: enter.y
    },
    exit: {
      opacity: zero2
    }
  };
  addEncoders(encode2, {
    align: _("labelAlign"),
    baseline: _("labelBaseline"),
    fill: _("labelColor"),
    fillOpacity: _("labelOpacity"),
    font: _("labelFont"),
    fontSize: _("labelFontSize"),
    fontStyle: _("labelFontStyle"),
    fontWeight: _("labelFontWeight"),
    limit: _("labelLimit")
  });
  const labels = guideMark({
    type: TextMark,
    role: LegendLabelRole,
    style: GuideLabelStyle,
    key: Value,
    from: valueRef,
    encode: encode2
  }, userEncode.labels);
  encode2 = {
    enter: {
      noBound: {
        value: !height2
      },
      // ignore width/height in bounds calc
      width: zero2,
      height: height2 ? encoder(height2) : zero2,
      opacity: zero2
    },
    exit: {
      opacity: zero2
    },
    update: update3 = {
      opacity: one2,
      row: {
        signal: null
      },
      column: {
        signal: null
      }
    }
  };
  if (_.isVertical(true)) {
    nrows = `ceil(item.mark.items.length / ${ncols})`;
    update3.row.signal = `${index2}%${nrows}`;
    update3.column.signal = `floor(${index2} / ${nrows})`;
    sort2 = {
      field: ["row", index2]
    };
  } else {
    update3.row.signal = `floor(${index2} / ${ncols})`;
    update3.column.signal = `${index2} % ${ncols}`;
    sort2 = {
      field: index2
    };
  }
  update3.column.signal = `(${columns})?${update3.column.signal}:${index2}`;
  dataRef = {
    facet: {
      data: dataRef,
      name: "value",
      groupby: Index
    }
  };
  return guideGroup({
    role: ScopeRole2,
    from: dataRef,
    encode: extendEncode(encode2, entries, Skip3),
    marks: [symbols3, labels],
    name,
    interactive: interactive2,
    sort: sort2
  });
}
function legendSymbolLayout(spec, config) {
  const _ = lookup5(spec, config);
  return {
    align: _("gridAlign"),
    columns: _.entryColumns(),
    center: {
      row: true,
      column: false
    },
    padding: {
      row: _("rowPadding"),
      column: _("columnPadding")
    }
  };
}
var isL = 'item.orient === "left"';
var isR = 'item.orient === "right"';
var isLR = `(${isL} || ${isR})`;
var isVG = `datum.vgrad && ${isLR}`;
var baseline = anchorExpr('"top"', '"bottom"', '"middle"');
var alignFlip = anchorExpr('"right"', '"left"', '"center"');
var exprAlign = `datum.vgrad && ${isR} ? (${alignFlip}) : (${isLR} && !(datum.vgrad && ${isL})) ? "left" : ${alignExpr$1}`;
var exprAnchor = `item._anchor || (${isLR} ? "middle" : "start")`;
var exprAngle = `${isVG} ? (${isL} ? -90 : 90) : 0`;
var exprBaseline = `${isLR} ? (datum.vgrad ? (${isR} ? "bottom" : "top") : ${baseline}) : "top"`;
function legendTitle(spec, config, userEncode, dataRef) {
  const _ = lookup5(spec, config);
  const encode2 = {
    enter: {
      opacity: zero2
    },
    update: {
      opacity: one2,
      x: {
        field: {
          group: "padding"
        }
      },
      y: {
        field: {
          group: "padding"
        }
      }
    },
    exit: {
      opacity: zero2
    }
  };
  addEncoders(encode2, {
    orient: _("titleOrient"),
    _anchor: _("titleAnchor"),
    anchor: {
      signal: exprAnchor
    },
    angle: {
      signal: exprAngle
    },
    align: {
      signal: exprAlign
    },
    baseline: {
      signal: exprBaseline
    },
    text: spec.title,
    fill: _("titleColor"),
    fillOpacity: _("titleOpacity"),
    font: _("titleFont"),
    fontSize: _("titleFontSize"),
    fontStyle: _("titleFontStyle"),
    fontWeight: _("titleFontWeight"),
    limit: _("titleLimit"),
    lineHeight: _("titleLineHeight")
  }, {
    // require update
    align: _("titleAlign"),
    baseline: _("titleBaseline")
  });
  return guideMark({
    type: TextMark,
    role: LegendTitleRole,
    style: GuideTitleStyle,
    from: dataRef,
    encode: encode2
  }, userEncode);
}
function clip2(clip3, scope) {
  let expr2;
  if (isObject(clip3)) {
    if (clip3.signal) {
      expr2 = clip3.signal;
    } else if (clip3.path) {
      expr2 = "pathShape(" + param(clip3.path) + ")";
    } else if (clip3.sphere) {
      expr2 = "geoShape(" + param(clip3.sphere) + ', {type: "Sphere"})';
    }
  }
  return expr2 ? scope.signalRef(expr2) : !!clip3;
}
function param(value3) {
  return isObject(value3) && value3.signal ? value3.signal : $(value3);
}
function getRole(spec) {
  const role = spec.role || "";
  return role.startsWith("axis") || role.startsWith("legend") || role.startsWith("title") ? role : spec.type === GroupMark ? ScopeRole2 : role || MarkRole;
}
function definition2(spec) {
  return {
    marktype: spec.type,
    name: spec.name || void 0,
    role: spec.role || getRole(spec),
    zindex: +spec.zindex || void 0,
    aria: spec.aria,
    description: spec.description
  };
}
function interactive(spec, scope) {
  return spec && spec.signal ? scope.signalRef(spec.signal) : spec === false ? false : true;
}
function parseTransform(spec, scope) {
  const def2 = definition(spec.type);
  if (!def2)
    error("Unrecognized transform type: " + $(spec.type));
  const t = entry(def2.type.toLowerCase(), null, parseParameters2(def2, spec, scope));
  if (spec.signal)
    scope.addSignal(spec.signal, scope.proxy(t));
  t.metadata = def2.metadata || {};
  return t;
}
function parseParameters2(def2, spec, scope) {
  const params2 = {}, n = def2.params.length;
  for (let i = 0; i < n; ++i) {
    const pdef = def2.params[i];
    params2[pdef.name] = parseParameter2(pdef, spec, scope);
  }
  return params2;
}
function parseParameter2(def2, spec, scope) {
  const type2 = def2.type, value3 = spec[def2.name];
  if (type2 === "index") {
    return parseIndexParameter(def2, spec, scope);
  } else if (value3 === void 0) {
    if (def2.required) {
      error("Missing required " + $(spec.type) + " parameter: " + $(def2.name));
    }
    return;
  } else if (type2 === "param") {
    return parseSubParameters(def2, spec, scope);
  } else if (type2 === "projection") {
    return scope.projectionRef(spec[def2.name]);
  }
  return def2.array && !isSignal(value3) ? value3.map((v) => parameterValue(def2, v, scope)) : parameterValue(def2, value3, scope);
}
function parameterValue(def2, value3, scope) {
  const type2 = def2.type;
  if (isSignal(value3)) {
    return isExpr(type2) ? error("Expression references can not be signals.") : isField(type2) ? scope.fieldRef(value3) : isCompare(type2) ? scope.compareRef(value3) : scope.signalRef(value3.signal);
  } else {
    const expr2 = def2.expr || isField(type2);
    return expr2 && outerExpr(value3) ? scope.exprRef(value3.expr, value3.as) : expr2 && outerField(value3) ? fieldRef$1(value3.field, value3.as) : isExpr(type2) ? parser2(value3, scope) : isData(type2) ? ref(scope.getData(value3).values) : isField(type2) ? fieldRef$1(value3) : isCompare(type2) ? scope.compareRef(value3) : value3;
  }
}
function parseIndexParameter(def2, spec, scope) {
  if (!isString(spec.from)) {
    error('Lookup "from" parameter must be a string literal.');
  }
  return scope.getData(spec.from).lookupRef(scope, spec.key);
}
function parseSubParameters(def2, spec, scope) {
  const value3 = spec[def2.name];
  if (def2.array) {
    if (!isArray(value3)) {
      error("Expected an array of sub-parameters. Instead: " + $(value3));
    }
    return value3.map((v) => parseSubParameter(def2, v, scope));
  } else {
    return parseSubParameter(def2, value3, scope);
  }
}
function parseSubParameter(def2, value3, scope) {
  const n = def2.params.length;
  let pdef;
  for (let i = 0; i < n; ++i) {
    pdef = def2.params[i];
    for (const k2 in pdef.key) {
      if (pdef.key[k2] !== value3[k2]) {
        pdef = null;
        break;
      }
    }
    if (pdef)
      break;
  }
  if (!pdef)
    error("Unsupported parameter: " + $(value3));
  const params2 = extend(parseParameters2(pdef, value3, scope), pdef.key);
  return ref(scope.add(Params3(params2)));
}
var outerExpr = (_) => _ && _.expr;
var outerField = (_) => _ && _.field;
var isData = (_) => _ === "data";
var isExpr = (_) => _ === "expr";
var isField = (_) => _ === "field";
var isCompare = (_) => _ === "compare";
function parseData$1(from, group2, scope) {
  let facet, key2, op, dataRef, parent;
  if (!from) {
    dataRef = ref(scope.add(Collect2(null, [{}])));
  } else if (facet = from.facet) {
    if (!group2)
      error("Only group marks can be faceted.");
    if (facet.field != null) {
      dataRef = parent = getDataRef(facet, scope);
    } else {
      if (!from.data) {
        op = parseTransform(extend({
          type: "aggregate",
          groupby: array(facet.groupby)
        }, facet.aggregate), scope);
        op.params.key = scope.keyRef(facet.groupby);
        op.params.pulse = getDataRef(facet, scope);
        dataRef = parent = ref(scope.add(op));
      } else {
        parent = ref(scope.getData(from.data).aggregate);
      }
      key2 = scope.keyRef(facet.groupby, true);
    }
  }
  if (!dataRef) {
    dataRef = getDataRef(from, scope);
  }
  return {
    key: key2,
    pulse: dataRef,
    parent
  };
}
function getDataRef(from, scope) {
  return from.$ref ? from : from.data && from.data.$ref ? from.data : ref(scope.getData(from.data).output);
}
function DataScope(scope, input, output3, values2, aggr) {
  this.scope = scope;
  this.input = input;
  this.output = output3;
  this.values = values2;
  this.aggregate = aggr;
  this.index = {};
}
DataScope.fromEntries = function(scope, entries) {
  const n = entries.length, values2 = entries[n - 1], output3 = entries[n - 2];
  let input = entries[0], aggr = null, i = 1;
  if (input && input.type === "load") {
    input = entries[1];
  }
  scope.add(entries[0]);
  for (; i < n; ++i) {
    entries[i].params.pulse = ref(entries[i - 1]);
    scope.add(entries[i]);
    if (entries[i].type === "aggregate")
      aggr = entries[i];
  }
  return new DataScope(scope, input, output3, values2, aggr);
};
function fieldKey(field3) {
  return isString(field3) ? field3 : null;
}
function addSortField(scope, p, sort2) {
  const as = aggrField(sort2.op, sort2.field);
  let s;
  if (p.ops) {
    for (let i = 0, n = p.as.length; i < n; ++i) {
      if (p.as[i] === as)
        return;
    }
  } else {
    p.ops = ["count"];
    p.fields = [null];
    p.as = ["count"];
  }
  if (sort2.op) {
    p.ops.push((s = sort2.op.signal) ? scope.signalRef(s) : sort2.op);
    p.fields.push(scope.fieldRef(sort2.field));
    p.as.push(as);
  }
}
function cache(scope, ds, name, optype, field3, counts, index2) {
  const cache2 = ds[name] || (ds[name] = {}), sort2 = sortKey(counts);
  let k2 = fieldKey(field3), v, op;
  if (k2 != null) {
    scope = ds.scope;
    k2 = k2 + (sort2 ? "|" + sort2 : "");
    v = cache2[k2];
  }
  if (!v) {
    const params2 = counts ? {
      field: keyFieldRef,
      pulse: ds.countsRef(scope, field3, counts)
    } : {
      field: scope.fieldRef(field3),
      pulse: ref(ds.output)
    };
    if (sort2)
      params2.sort = scope.sortRef(counts);
    op = scope.add(entry(optype, void 0, params2));
    if (index2)
      ds.index[field3] = op;
    v = ref(op);
    if (k2 != null)
      cache2[k2] = v;
  }
  return v;
}
DataScope.prototype = {
  countsRef(scope, field3, sort2) {
    const ds = this, cache2 = ds.counts || (ds.counts = {}), k2 = fieldKey(field3);
    let v, a, p;
    if (k2 != null) {
      scope = ds.scope;
      v = cache2[k2];
    }
    if (!v) {
      p = {
        groupby: scope.fieldRef(field3, "key"),
        pulse: ref(ds.output)
      };
      if (sort2 && sort2.field)
        addSortField(scope, p, sort2);
      a = scope.add(Aggregate2(p));
      v = scope.add(Collect2({
        pulse: ref(a)
      }));
      v = {
        agg: a,
        ref: ref(v)
      };
      if (k2 != null)
        cache2[k2] = v;
    } else if (sort2 && sort2.field) {
      addSortField(scope, v.agg.params, sort2);
    }
    return v.ref;
  },
  tuplesRef() {
    return ref(this.values);
  },
  extentRef(scope, field3) {
    return cache(scope, this, "extent", "extent", field3, false);
  },
  domainRef(scope, field3) {
    return cache(scope, this, "domain", "values", field3, false);
  },
  valuesRef(scope, field3, sort2) {
    return cache(scope, this, "vals", "values", field3, sort2 || true);
  },
  lookupRef(scope, field3) {
    return cache(scope, this, "lookup", "tupleindex", field3, false);
  },
  indataRef(scope, field3) {
    return cache(scope, this, "indata", "tupleindex", field3, true, true);
  }
};
function parseFacet(spec, scope, group2) {
  const facet = spec.from.facet, name = facet.name, data3 = getDataRef(facet, scope);
  let op;
  if (!facet.name) {
    error("Facet must have a name: " + $(facet));
  }
  if (!facet.data) {
    error("Facet must reference a data set: " + $(facet));
  }
  if (facet.field) {
    op = scope.add(PreFacet2({
      field: scope.fieldRef(facet.field),
      pulse: data3
    }));
  } else if (facet.groupby) {
    op = scope.add(Facet2({
      key: scope.keyRef(facet.groupby),
      group: ref(scope.proxy(group2.parent)),
      pulse: data3
    }));
  } else {
    error("Facet must specify groupby or field: " + $(facet));
  }
  const subscope = scope.fork(), source3 = subscope.add(Collect2()), values2 = subscope.add(Sieve2({
    pulse: ref(source3)
  }));
  subscope.addData(name, new DataScope(subscope, source3, source3, values2));
  subscope.addSignal("parent", null);
  op.params.subflow = {
    $subflow: subscope.parse(spec).toRuntime()
  };
}
function parseSubflow(spec, scope, input) {
  const op = scope.add(PreFacet2({
    pulse: input.pulse
  })), subscope = scope.fork();
  subscope.add(Sieve2());
  subscope.addSignal("parent", null);
  op.params.subflow = {
    $subflow: subscope.parse(spec).toRuntime()
  };
}
function parseTrigger(spec, scope, name) {
  const remove2 = spec.remove, insert2 = spec.insert, toggle = spec.toggle, modify2 = spec.modify, values2 = spec.values, op = scope.add(operator());
  const update3 = "if(" + spec.trigger + ',modify("' + name + '",' + [insert2, remove2, toggle, modify2, values2].map((_) => _ == null ? "null" : _).join(",") + "),0)";
  const expr2 = parser2(update3, scope);
  op.update = expr2.$expr;
  op.params = expr2.$params;
}
function parseMark(spec, scope) {
  const role = getRole(spec), group2 = spec.type === GroupMark, facet = spec.from && spec.from.facet, overlap = spec.overlap;
  let layout = spec.layout || role === ScopeRole2 || role === FrameRole2, ops2, op, store, enc, name, layoutRef, boundRef;
  const nested = role === MarkRole || layout || facet;
  const input = parseData$1(spec.from, group2, scope);
  op = scope.add(DataJoin2({
    key: input.key || (spec.key ? fieldRef$1(spec.key) : void 0),
    pulse: input.pulse,
    clean: !group2
  }));
  const joinRef = ref(op);
  op = store = scope.add(Collect2({
    pulse: joinRef
  }));
  op = scope.add(Mark2({
    markdef: definition2(spec),
    interactive: interactive(spec.interactive, scope),
    clip: clip2(spec.clip, scope),
    context: {
      $context: true
    },
    groups: scope.lookup(),
    parent: scope.signals.parent ? scope.signalRef("parent") : null,
    index: scope.markpath(),
    pulse: ref(op)
  }));
  const markRef = ref(op);
  op = enc = scope.add(Encode2(parseEncode(spec.encode, spec.type, role, spec.style, scope, {
    mod: false,
    pulse: markRef
  })));
  op.params.parent = scope.encode();
  if (spec.transform) {
    spec.transform.forEach((_) => {
      const tx = parseTransform(_, scope), md2 = tx.metadata;
      if (md2.generates || md2.changes) {
        error("Mark transforms should not generate new data.");
      }
      if (!md2.nomod)
        enc.params.mod = true;
      tx.params.pulse = ref(op);
      scope.add(op = tx);
    });
  }
  if (spec.sort) {
    op = scope.add(SortItems2({
      sort: scope.compareRef(spec.sort),
      pulse: ref(op)
    }));
  }
  const encodeRef = ref(op);
  if (facet || layout) {
    layout = scope.add(ViewLayout2({
      layout: scope.objectProperty(spec.layout),
      legends: scope.legends,
      mark: markRef,
      pulse: encodeRef
    }));
    layoutRef = ref(layout);
  }
  const bound2 = scope.add(Bound2({
    mark: markRef,
    pulse: layoutRef || encodeRef
  }));
  boundRef = ref(bound2);
  if (group2) {
    if (nested) {
      ops2 = scope.operators;
      ops2.pop();
      if (layout)
        ops2.pop();
    }
    scope.pushState(encodeRef, layoutRef || boundRef, joinRef);
    facet ? parseFacet(spec, scope, input) : nested ? parseSubflow(spec, scope, input) : scope.parse(spec);
    scope.popState();
    if (nested) {
      if (layout)
        ops2.push(layout);
      ops2.push(bound2);
    }
  }
  if (overlap) {
    boundRef = parseOverlap(overlap, boundRef, scope);
  }
  const render = scope.add(Render2({
    pulse: boundRef
  })), sieve = scope.add(Sieve2({
    pulse: ref(render)
  }, void 0, scope.parent()));
  if (spec.name != null) {
    name = spec.name;
    scope.addData(name, new DataScope(scope, store, render, sieve));
    if (spec.on)
      spec.on.forEach((on2) => {
        if (on2.insert || on2.remove || on2.toggle) {
          error("Marks only support modify triggers.");
        }
        parseTrigger(on2, scope, name);
      });
  }
}
function parseOverlap(overlap, source3, scope) {
  const method2 = overlap.method, bound2 = overlap.bound, sep = overlap.separation;
  const params2 = {
    separation: isSignal(sep) ? scope.signalRef(sep.signal) : sep,
    method: isSignal(method2) ? scope.signalRef(method2.signal) : method2,
    pulse: source3
  };
  if (overlap.order) {
    params2.sort = scope.compareRef({
      field: overlap.order
    });
  }
  if (bound2) {
    const tol = bound2.tolerance;
    params2.boundTolerance = isSignal(tol) ? scope.signalRef(tol.signal) : +tol;
    params2.boundScale = scope.scaleRef(bound2.scale);
    params2.boundOrient = bound2.orient;
  }
  return ref(scope.add(Overlap2(params2)));
}
function parseLegend(spec, scope) {
  const config = scope.config.legend, encode2 = spec.encode || {}, _ = lookup5(spec, config), legendEncode = encode2.legend || {}, name = legendEncode.name || void 0, interactive2 = legendEncode.interactive, style2 = legendEncode.style, scales2 = {};
  let scale6 = 0, entryLayout, params2, children3;
  LegendScales.forEach((s) => spec[s] ? (scales2[s] = spec[s], scale6 = scale6 || spec[s]) : 0);
  if (!scale6)
    error("Missing valid scale for legend.");
  const type2 = legendType(spec, scope.scaleType(scale6));
  const datum2 = {
    title: spec.title != null,
    scales: scales2,
    type: type2,
    vgrad: type2 !== "symbol" && _.isVertical()
  };
  const dataRef = ref(scope.add(Collect2(null, [datum2])));
  const entryEncode = {
    enter: {
      x: {
        value: 0
      },
      y: {
        value: 0
      }
    }
  };
  const entryRef = ref(scope.add(LegendEntries2(params2 = {
    type: type2,
    scale: scope.scaleRef(scale6),
    count: scope.objectProperty(_("tickCount")),
    limit: scope.property(_("symbolLimit")),
    values: scope.objectProperty(spec.values),
    minstep: scope.property(spec.tickMinStep),
    formatType: scope.property(spec.formatType),
    formatSpecifier: scope.property(spec.format)
  })));
  if (type2 === Gradient2) {
    children3 = [legendGradient(spec, scale6, config, encode2.gradient), legendGradientLabels(spec, config, encode2.labels, entryRef)];
    params2.count = params2.count || scope.signalRef(`max(2,2*floor((${deref(_.gradientLength())})/100))`);
  } else if (type2 === Discrete2) {
    children3 = [legendGradientDiscrete(spec, scale6, config, encode2.gradient, entryRef), legendGradientLabels(spec, config, encode2.labels, entryRef)];
  } else {
    entryLayout = legendSymbolLayout(spec, config);
    children3 = [legendSymbolGroups(spec, config, encode2, entryRef, deref(entryLayout.columns))];
    params2.size = sizeExpression(spec, scope, children3[0].marks);
  }
  children3 = [guideGroup({
    role: LegendEntryRole,
    from: dataRef,
    encode: entryEncode,
    marks: children3,
    layout: entryLayout,
    interactive: interactive2
  })];
  if (datum2.title) {
    children3.push(legendTitle(spec, config, encode2.title, dataRef));
  }
  return parseMark(guideGroup({
    role: LegendRole2,
    from: dataRef,
    encode: extendEncode(buildLegendEncode(_, spec, config), legendEncode, Skip3),
    marks: children3,
    aria: _("aria"),
    description: _("description"),
    zindex: _("zindex"),
    name,
    interactive: interactive2,
    style: style2
  }), scope);
}
function legendType(spec, scaleType) {
  let type2 = spec.type || Symbols2;
  if (!spec.type && scaleCount(spec) === 1 && (spec.fill || spec.stroke)) {
    type2 = isContinuous(scaleType) ? Gradient2 : isDiscretizing(scaleType) ? Discrete2 : Symbols2;
  }
  return type2 !== Gradient2 ? type2 : isDiscretizing(scaleType) ? Discrete2 : Gradient2;
}
function scaleCount(spec) {
  return LegendScales.reduce((count, type2) => count + (spec[type2] ? 1 : 0), 0);
}
function buildLegendEncode(_, spec, config) {
  const encode2 = {
    enter: {},
    update: {}
  };
  addEncoders(encode2, {
    orient: _("orient"),
    offset: _("offset"),
    padding: _("padding"),
    titlePadding: _("titlePadding"),
    cornerRadius: _("cornerRadius"),
    fill: _("fillColor"),
    stroke: _("strokeColor"),
    strokeWidth: config.strokeWidth,
    strokeDash: config.strokeDash,
    x: _("legendX"),
    y: _("legendY"),
    // accessibility support
    format: spec.format,
    formatType: spec.formatType
  });
  return encode2;
}
function sizeExpression(spec, scope, marks) {
  const size = deref(getChannel("size", spec, marks)), strokeWidth = deref(getChannel("strokeWidth", spec, marks)), fontSize2 = deref(getFontSize(marks[1].encode, scope, GuideLabelStyle));
  return parser2(`max(ceil(sqrt(${size})+${strokeWidth}),${fontSize2})`, scope);
}
function getChannel(name, spec, marks) {
  return spec[name] ? `scale("${spec[name]}",datum)` : getEncoding(name, marks[0].encode);
}
function getFontSize(encode2, scope, style2) {
  return getEncoding("fontSize", encode2) || getStyle("fontSize", scope, style2);
}
var angleExpr = `item.orient==="${Left2}"?-90:item.orient==="${Right2}"?90:0`;
function parseTitle(spec, scope) {
  spec = isString(spec) ? {
    text: spec
  } : spec;
  const _ = lookup5(spec, scope.config.title), encode2 = spec.encode || {}, userEncode = encode2.group || {}, name = userEncode.name || void 0, interactive2 = userEncode.interactive, style2 = userEncode.style, children3 = [];
  const datum2 = {}, dataRef = ref(scope.add(Collect2(null, [datum2])));
  children3.push(buildTitle(spec, _, titleEncode(spec), dataRef));
  if (spec.subtitle) {
    children3.push(buildSubTitle(spec, _, encode2.subtitle, dataRef));
  }
  return parseMark(guideGroup({
    role: TitleRole2,
    from: dataRef,
    encode: groupEncode(_, userEncode),
    marks: children3,
    aria: _("aria"),
    description: _("description"),
    zindex: _("zindex"),
    name,
    interactive: interactive2,
    style: style2
  }), scope);
}
function titleEncode(spec) {
  const encode2 = spec.encode;
  return encode2 && encode2.title || extend({
    name: spec.name,
    interactive: spec.interactive,
    style: spec.style
  }, encode2);
}
function groupEncode(_, userEncode) {
  const encode2 = {
    enter: {},
    update: {}
  };
  addEncoders(encode2, {
    orient: _("orient"),
    anchor: _("anchor"),
    align: {
      signal: alignExpr$1
    },
    angle: {
      signal: angleExpr
    },
    limit: _("limit"),
    frame: _("frame"),
    offset: _("offset") || 0,
    padding: _("subtitlePadding")
  });
  return extendEncode(encode2, userEncode, Skip3);
}
function buildTitle(spec, _, userEncode, dataRef) {
  const zero3 = {
    value: 0
  }, text2 = spec.text, encode2 = {
    enter: {
      opacity: zero3
    },
    update: {
      opacity: {
        value: 1
      }
    },
    exit: {
      opacity: zero3
    }
  };
  addEncoders(encode2, {
    text: text2,
    align: {
      signal: "item.mark.group.align"
    },
    angle: {
      signal: "item.mark.group.angle"
    },
    limit: {
      signal: "item.mark.group.limit"
    },
    baseline: "top",
    dx: _("dx"),
    dy: _("dy"),
    fill: _("color"),
    font: _("font"),
    fontSize: _("fontSize"),
    fontStyle: _("fontStyle"),
    fontWeight: _("fontWeight"),
    lineHeight: _("lineHeight")
  }, {
    // update
    align: _("align"),
    angle: _("angle"),
    baseline: _("baseline")
  });
  return guideMark({
    type: TextMark,
    role: TitleTextRole,
    style: GroupTitleStyle,
    from: dataRef,
    encode: encode2
  }, userEncode);
}
function buildSubTitle(spec, _, userEncode, dataRef) {
  const zero3 = {
    value: 0
  }, text2 = spec.subtitle, encode2 = {
    enter: {
      opacity: zero3
    },
    update: {
      opacity: {
        value: 1
      }
    },
    exit: {
      opacity: zero3
    }
  };
  addEncoders(encode2, {
    text: text2,
    align: {
      signal: "item.mark.group.align"
    },
    angle: {
      signal: "item.mark.group.angle"
    },
    limit: {
      signal: "item.mark.group.limit"
    },
    baseline: "top",
    dx: _("dx"),
    dy: _("dy"),
    fill: _("subtitleColor"),
    font: _("subtitleFont"),
    fontSize: _("subtitleFontSize"),
    fontStyle: _("subtitleFontStyle"),
    fontWeight: _("subtitleFontWeight"),
    lineHeight: _("subtitleLineHeight")
  }, {
    // update
    align: _("align"),
    angle: _("angle"),
    baseline: _("baseline")
  });
  return guideMark({
    type: TextMark,
    role: TitleSubtitleRole,
    style: GroupSubtitleStyle,
    from: dataRef,
    encode: encode2
  }, userEncode);
}
function parseData(data3, scope) {
  const transforms2 = [];
  if (data3.transform) {
    data3.transform.forEach((tx) => {
      transforms2.push(parseTransform(tx, scope));
    });
  }
  if (data3.on) {
    data3.on.forEach((on2) => {
      parseTrigger(on2, scope, data3.name);
    });
  }
  scope.addDataPipeline(data3.name, analyze(data3, scope, transforms2));
}
function analyze(data3, scope, ops2) {
  const output3 = [];
  let source3 = null, modify2 = false, generate2 = false, upstream, i, n, t, m;
  if (data3.values) {
    if (isSignal(data3.values) || hasSignal(data3.format)) {
      output3.push(load2(scope, data3));
      output3.push(source3 = collect());
    } else {
      output3.push(source3 = collect({
        $ingest: data3.values,
        $format: data3.format
      }));
    }
  } else if (data3.url) {
    if (hasSignal(data3.url) || hasSignal(data3.format)) {
      output3.push(load2(scope, data3));
      output3.push(source3 = collect());
    } else {
      output3.push(source3 = collect({
        $request: data3.url,
        $format: data3.format
      }));
    }
  } else if (data3.source) {
    source3 = upstream = array(data3.source).map((d) => ref(scope.getData(d).output));
    output3.push(null);
  }
  for (i = 0, n = ops2.length; i < n; ++i) {
    t = ops2[i];
    m = t.metadata;
    if (!source3 && !m.source) {
      output3.push(source3 = collect());
    }
    output3.push(t);
    if (m.generates)
      generate2 = true;
    if (m.modifies && !generate2)
      modify2 = true;
    if (m.source)
      source3 = t;
    else if (m.changes)
      source3 = null;
  }
  if (upstream) {
    n = upstream.length - 1;
    output3[0] = Relay2({
      derive: modify2,
      pulse: n ? upstream : upstream[0]
    });
    if (modify2 || n) {
      output3.splice(1, 0, collect());
    }
  }
  if (!source3)
    output3.push(collect());
  output3.push(Sieve2({}));
  return output3;
}
function collect(values2) {
  const s = Collect2({}, values2);
  s.metadata = {
    source: true
  };
  return s;
}
function load2(scope, data3) {
  return Load2({
    url: data3.url ? scope.property(data3.url) : void 0,
    async: data3.async ? scope.property(data3.async) : void 0,
    values: data3.values ? scope.property(data3.values) : void 0,
    format: scope.objectProperty(data3.format)
  });
}
var isX = (orient) => orient === Bottom2 || orient === Top2;
var getSign = (orient, a, b2) => isSignal(orient) ? ifLeftTopExpr(orient.signal, a, b2) : orient === Left2 || orient === Top2 ? a : b2;
var ifX = (orient, a, b2) => isSignal(orient) ? ifXEnc(orient.signal, a, b2) : isX(orient) ? a : b2;
var ifY = (orient, a, b2) => isSignal(orient) ? ifYEnc(orient.signal, a, b2) : isX(orient) ? b2 : a;
var ifTop = (orient, a, b2) => isSignal(orient) ? ifTopExpr(orient.signal, a, b2) : orient === Top2 ? {
  value: a
} : {
  value: b2
};
var ifRight = (orient, a, b2) => isSignal(orient) ? ifRightExpr(orient.signal, a, b2) : orient === Right2 ? {
  value: a
} : {
  value: b2
};
var ifXEnc = ($orient, a, b2) => ifEnc(`${$orient} === '${Top2}' || ${$orient} === '${Bottom2}'`, a, b2);
var ifYEnc = ($orient, a, b2) => ifEnc(`${$orient} !== '${Top2}' && ${$orient} !== '${Bottom2}'`, a, b2);
var ifLeftTopExpr = ($orient, a, b2) => ifExpr(`${$orient} === '${Left2}' || ${$orient} === '${Top2}'`, a, b2);
var ifTopExpr = ($orient, a, b2) => ifExpr(`${$orient} === '${Top2}'`, a, b2);
var ifRightExpr = ($orient, a, b2) => ifExpr(`${$orient} === '${Right2}'`, a, b2);
var ifEnc = (test2, a, b2) => {
  a = a != null ? encoder(a) : a;
  b2 = b2 != null ? encoder(b2) : b2;
  if (isSimple(a) && isSimple(b2)) {
    a = a ? a.signal || $(a.value) : null;
    b2 = b2 ? b2.signal || $(b2.value) : null;
    return {
      signal: `${test2} ? (${a}) : (${b2})`
    };
  } else {
    return [extend({
      test: test2
    }, a)].concat(b2 || []);
  }
};
var isSimple = (enc) => enc == null || Object.keys(enc).length === 1;
var ifExpr = (test2, a, b2) => ({
  signal: `${test2} ? (${toExpr(a)}) : (${toExpr(b2)})`
});
var ifOrient = ($orient, t, b2, l, r) => ({
  signal: (l != null ? `${$orient} === '${Left2}' ? (${toExpr(l)}) : ` : "") + (b2 != null ? `${$orient} === '${Bottom2}' ? (${toExpr(b2)}) : ` : "") + (r != null ? `${$orient} === '${Right2}' ? (${toExpr(r)}) : ` : "") + (t != null ? `${$orient} === '${Top2}' ? (${toExpr(t)}) : ` : "") + "(null)"
});
var toExpr = (v) => isSignal(v) ? v.signal : v == null ? null : $(v);
var mult = (sign2, value3) => value3 === 0 ? 0 : isSignal(sign2) ? {
  signal: `(${sign2.signal}) * ${value3}`
} : {
  value: sign2 * value3
};
var patch = (value3, base2) => {
  const s = value3.signal;
  return s && s.endsWith("(null)") ? {
    signal: s.slice(0, -6) + base2.signal
  } : value3;
};
function fallback(prop, config, axisConfig2, style2) {
  let styleProp;
  if (config && has(config, prop)) {
    return config[prop];
  } else if (has(axisConfig2, prop)) {
    return axisConfig2[prop];
  } else if (prop.startsWith("title")) {
    switch (prop) {
      case "titleColor":
        styleProp = "fill";
        break;
      case "titleFont":
      case "titleFontSize":
      case "titleFontWeight":
        styleProp = prop[5].toLowerCase() + prop.slice(6);
    }
    return style2[GuideTitleStyle][styleProp];
  } else if (prop.startsWith("label")) {
    switch (prop) {
      case "labelColor":
        styleProp = "fill";
        break;
      case "labelFont":
      case "labelFontSize":
        styleProp = prop[5].toLowerCase() + prop.slice(6);
    }
    return style2[GuideLabelStyle][styleProp];
  }
  return null;
}
function keys2(objects) {
  const map2 = {};
  for (const obj of objects) {
    if (!obj)
      continue;
    for (const key2 in obj)
      map2[key2] = 1;
  }
  return Object.keys(map2);
}
function axisConfig(spec, scope) {
  var config = scope.config, style2 = config.style, axis = config.axis, band2 = scope.scaleType(spec.scale) === "band" && config.axisBand, orient = spec.orient, xy, or2, key2;
  if (isSignal(orient)) {
    const xyKeys = keys2([config.axisX, config.axisY]), orientKeys = keys2([config.axisTop, config.axisBottom, config.axisLeft, config.axisRight]);
    xy = {};
    for (key2 of xyKeys) {
      xy[key2] = ifX(orient, fallback(key2, config.axisX, axis, style2), fallback(key2, config.axisY, axis, style2));
    }
    or2 = {};
    for (key2 of orientKeys) {
      or2[key2] = ifOrient(orient.signal, fallback(key2, config.axisTop, axis, style2), fallback(key2, config.axisBottom, axis, style2), fallback(key2, config.axisLeft, axis, style2), fallback(key2, config.axisRight, axis, style2));
    }
  } else {
    xy = orient === Top2 || orient === Bottom2 ? config.axisX : config.axisY;
    or2 = config["axis" + orient[0].toUpperCase() + orient.slice(1)];
  }
  const result = xy || or2 || band2 ? extend({}, axis, xy, or2, band2) : axis;
  return result;
}
function axisDomain(spec, config, userEncode, dataRef) {
  const _ = lookup5(spec, config), orient = spec.orient;
  let enter, update3;
  const encode2 = {
    enter: enter = {
      opacity: zero2
    },
    update: update3 = {
      opacity: one2
    },
    exit: {
      opacity: zero2
    }
  };
  addEncoders(encode2, {
    stroke: _("domainColor"),
    strokeCap: _("domainCap"),
    strokeDash: _("domainDash"),
    strokeDashOffset: _("domainDashOffset"),
    strokeWidth: _("domainWidth"),
    strokeOpacity: _("domainOpacity")
  });
  const pos0 = position(spec, 0);
  const pos1 = position(spec, 1);
  enter.x = update3.x = ifX(orient, pos0, zero2);
  enter.x2 = update3.x2 = ifX(orient, pos1);
  enter.y = update3.y = ifY(orient, pos0, zero2);
  enter.y2 = update3.y2 = ifY(orient, pos1);
  return guideMark({
    type: RuleMark,
    role: AxisDomainRole,
    from: dataRef,
    encode: encode2
  }, userEncode);
}
function position(spec, pos) {
  return {
    scale: spec.scale,
    range: pos
  };
}
function axisGrid(spec, config, userEncode, dataRef, band2) {
  const _ = lookup5(spec, config), orient = spec.orient, vscale = spec.gridScale, sign2 = getSign(orient, 1, -1), offset4 = offsetValue2(spec.offset, sign2);
  let enter, exit, update3;
  const encode2 = {
    enter: enter = {
      opacity: zero2
    },
    update: update3 = {
      opacity: one2
    },
    exit: exit = {
      opacity: zero2
    }
  };
  addEncoders(encode2, {
    stroke: _("gridColor"),
    strokeCap: _("gridCap"),
    strokeDash: _("gridDash"),
    strokeDashOffset: _("gridDashOffset"),
    strokeOpacity: _("gridOpacity"),
    strokeWidth: _("gridWidth")
  });
  const tickPos = {
    scale: spec.scale,
    field: Value,
    band: band2.band,
    extra: band2.extra,
    offset: band2.offset,
    round: _("tickRound")
  };
  const sz2 = ifX(orient, {
    signal: "height"
  }, {
    signal: "width"
  });
  const gridStart = vscale ? {
    scale: vscale,
    range: 0,
    mult: sign2,
    offset: offset4
  } : {
    value: 0,
    offset: offset4
  };
  const gridEnd = vscale ? {
    scale: vscale,
    range: 1,
    mult: sign2,
    offset: offset4
  } : extend(sz2, {
    mult: sign2,
    offset: offset4
  });
  enter.x = update3.x = ifX(orient, tickPos, gridStart);
  enter.y = update3.y = ifY(orient, tickPos, gridStart);
  enter.x2 = update3.x2 = ifY(orient, gridEnd);
  enter.y2 = update3.y2 = ifX(orient, gridEnd);
  exit.x = ifX(orient, tickPos);
  exit.y = ifY(orient, tickPos);
  return guideMark({
    type: RuleMark,
    role: AxisGridRole,
    key: Value,
    from: dataRef,
    encode: encode2
  }, userEncode);
}
function offsetValue2(offset4, sign2) {
  if (sign2 === 1)
    ;
  else if (!isObject(offset4)) {
    offset4 = isSignal(sign2) ? {
      signal: `(${sign2.signal}) * (${offset4 || 0})`
    } : sign2 * (offset4 || 0);
  } else {
    let entry2 = offset4 = extend({}, offset4);
    while (entry2.mult != null) {
      if (!isObject(entry2.mult)) {
        entry2.mult = isSignal(sign2) ? {
          signal: `(${entry2.mult}) * (${sign2.signal})`
        } : entry2.mult * sign2;
        return offset4;
      } else {
        entry2 = entry2.mult = extend({}, entry2.mult);
      }
    }
    entry2.mult = sign2;
  }
  return offset4;
}
function axisTicks(spec, config, userEncode, dataRef, size, band2) {
  const _ = lookup5(spec, config), orient = spec.orient, sign2 = getSign(orient, -1, 1);
  let enter, exit, update3;
  const encode2 = {
    enter: enter = {
      opacity: zero2
    },
    update: update3 = {
      opacity: one2
    },
    exit: exit = {
      opacity: zero2
    }
  };
  addEncoders(encode2, {
    stroke: _("tickColor"),
    strokeCap: _("tickCap"),
    strokeDash: _("tickDash"),
    strokeDashOffset: _("tickDashOffset"),
    strokeOpacity: _("tickOpacity"),
    strokeWidth: _("tickWidth")
  });
  const tickSize = encoder(size);
  tickSize.mult = sign2;
  const tickPos = {
    scale: spec.scale,
    field: Value,
    band: band2.band,
    extra: band2.extra,
    offset: band2.offset,
    round: _("tickRound")
  };
  update3.y = enter.y = ifX(orient, zero2, tickPos);
  update3.y2 = enter.y2 = ifX(orient, tickSize);
  exit.x = ifX(orient, tickPos);
  update3.x = enter.x = ifY(orient, zero2, tickPos);
  update3.x2 = enter.x2 = ifY(orient, tickSize);
  exit.y = ifY(orient, tickPos);
  return guideMark({
    type: RuleMark,
    role: AxisTickRole,
    key: Value,
    from: dataRef,
    encode: encode2
  }, userEncode);
}
function flushExpr(scale6, threshold2, a, b2, c) {
  return {
    signal: 'flush(range("' + scale6 + '"), scale("' + scale6 + '", datum.value), ' + threshold2 + "," + a + "," + b2 + "," + c + ")"
  };
}
function axisLabels(spec, config, userEncode, dataRef, size, band2) {
  const _ = lookup5(spec, config), orient = spec.orient, scale6 = spec.scale, sign2 = getSign(orient, -1, 1), flush2 = deref(_("labelFlush")), flushOffset = deref(_("labelFlushOffset")), labelAlign = _("labelAlign"), labelBaseline = _("labelBaseline");
  let flushOn = flush2 === 0 || !!flush2, update3;
  const tickSize = encoder(size);
  tickSize.mult = sign2;
  tickSize.offset = encoder(_("labelPadding") || 0);
  tickSize.offset.mult = sign2;
  const tickPos = {
    scale: scale6,
    field: Value,
    band: 0.5,
    offset: extendOffset(band2.offset, _("labelOffset"))
  };
  const align = ifX(orient, flushOn ? flushExpr(scale6, flush2, '"left"', '"right"', '"center"') : {
    value: "center"
  }, ifRight(orient, "left", "right"));
  const baseline2 = ifX(orient, ifTop(orient, "bottom", "top"), flushOn ? flushExpr(scale6, flush2, '"top"', '"bottom"', '"middle"') : {
    value: "middle"
  });
  const offsetExpr = flushExpr(scale6, flush2, `-(${flushOffset})`, flushOffset, 0);
  flushOn = flushOn && flushOffset;
  const enter = {
    opacity: zero2,
    x: ifX(orient, tickPos, tickSize),
    y: ifY(orient, tickPos, tickSize)
  };
  const encode2 = {
    enter,
    update: update3 = {
      opacity: one2,
      text: {
        field: Label2
      },
      x: enter.x,
      y: enter.y,
      align,
      baseline: baseline2
    },
    exit: {
      opacity: zero2,
      x: enter.x,
      y: enter.y
    }
  };
  addEncoders(encode2, {
    dx: !labelAlign && flushOn ? ifX(orient, offsetExpr) : null,
    dy: !labelBaseline && flushOn ? ifY(orient, offsetExpr) : null
  });
  addEncoders(encode2, {
    angle: _("labelAngle"),
    fill: _("labelColor"),
    fillOpacity: _("labelOpacity"),
    font: _("labelFont"),
    fontSize: _("labelFontSize"),
    fontWeight: _("labelFontWeight"),
    fontStyle: _("labelFontStyle"),
    limit: _("labelLimit"),
    lineHeight: _("labelLineHeight")
  }, {
    align: labelAlign,
    baseline: labelBaseline
  });
  const bound2 = _("labelBound");
  let overlap = _("labelOverlap");
  overlap = overlap || bound2 ? {
    separation: _("labelSeparation"),
    method: overlap,
    order: "datum.index",
    bound: bound2 ? {
      scale: scale6,
      orient,
      tolerance: bound2
    } : null
  } : void 0;
  if (update3.align !== align) {
    update3.align = patch(update3.align, align);
  }
  if (update3.baseline !== baseline2) {
    update3.baseline = patch(update3.baseline, baseline2);
  }
  return guideMark({
    type: TextMark,
    role: AxisLabelRole,
    style: GuideLabelStyle,
    key: Value,
    from: dataRef,
    encode: encode2,
    overlap
  }, userEncode);
}
function axisTitle(spec, config, userEncode, dataRef) {
  const _ = lookup5(spec, config), orient = spec.orient, sign2 = getSign(orient, -1, 1);
  let enter, update3;
  const encode2 = {
    enter: enter = {
      opacity: zero2,
      anchor: encoder(_("titleAnchor", null)),
      align: {
        signal: alignExpr$1
      }
    },
    update: update3 = extend({}, enter, {
      opacity: one2,
      text: encoder(spec.title)
    }),
    exit: {
      opacity: zero2
    }
  };
  const titlePos = {
    signal: `lerp(range("${spec.scale}"), ${anchorExpr(0, 1, 0.5)})`
  };
  update3.x = ifX(orient, titlePos);
  update3.y = ifY(orient, titlePos);
  enter.angle = ifX(orient, zero2, mult(sign2, 90));
  enter.baseline = ifX(orient, ifTop(orient, Bottom2, Top2), {
    value: Bottom2
  });
  update3.angle = enter.angle;
  update3.baseline = enter.baseline;
  addEncoders(encode2, {
    fill: _("titleColor"),
    fillOpacity: _("titleOpacity"),
    font: _("titleFont"),
    fontSize: _("titleFontSize"),
    fontStyle: _("titleFontStyle"),
    fontWeight: _("titleFontWeight"),
    limit: _("titleLimit"),
    lineHeight: _("titleLineHeight")
  }, {
    // require update
    align: _("titleAlign"),
    angle: _("titleAngle"),
    baseline: _("titleBaseline")
  });
  autoLayout(_, orient, encode2, userEncode);
  encode2.update.align = patch(encode2.update.align, enter.align);
  encode2.update.angle = patch(encode2.update.angle, enter.angle);
  encode2.update.baseline = patch(encode2.update.baseline, enter.baseline);
  return guideMark({
    type: TextMark,
    role: AxisTitleRole,
    style: GuideTitleStyle,
    from: dataRef,
    encode: encode2
  }, userEncode);
}
function autoLayout(_, orient, encode2, userEncode) {
  const auto = (value3, dim) => value3 != null ? (encode2.update[dim] = patch(encoder(value3), encode2.update[dim]), false) : !has2(dim, userEncode) ? true : false;
  const autoY = auto(_("titleX"), "x"), autoX = auto(_("titleY"), "y");
  encode2.enter.auto = autoX === autoY ? encoder(autoX) : ifX(orient, encoder(autoX), encoder(autoY));
}
function parseAxis(spec, scope) {
  const config = axisConfig(spec, scope), encode2 = spec.encode || {}, axisEncode = encode2.axis || {}, name = axisEncode.name || void 0, interactive2 = axisEncode.interactive, style2 = axisEncode.style, _ = lookup5(spec, config), band2 = tickBand(_);
  const datum2 = {
    scale: spec.scale,
    ticks: !!_("ticks"),
    labels: !!_("labels"),
    grid: !!_("grid"),
    domain: !!_("domain"),
    title: spec.title != null
  };
  const dataRef = ref(scope.add(Collect2({}, [datum2])));
  const ticksRef = ref(scope.add(AxisTicks2({
    scale: scope.scaleRef(spec.scale),
    extra: scope.property(band2.extra),
    count: scope.objectProperty(spec.tickCount),
    values: scope.objectProperty(spec.values),
    minstep: scope.property(spec.tickMinStep),
    formatType: scope.property(spec.formatType),
    formatSpecifier: scope.property(spec.format)
  })));
  const children3 = [];
  let size;
  if (datum2.grid) {
    children3.push(axisGrid(spec, config, encode2.grid, ticksRef, band2));
  }
  if (datum2.ticks) {
    size = _("tickSize");
    children3.push(axisTicks(spec, config, encode2.ticks, ticksRef, size, band2));
  }
  if (datum2.labels) {
    size = datum2.ticks ? size : 0;
    children3.push(axisLabels(spec, config, encode2.labels, ticksRef, size, band2));
  }
  if (datum2.domain) {
    children3.push(axisDomain(spec, config, encode2.domain, dataRef));
  }
  if (datum2.title) {
    children3.push(axisTitle(spec, config, encode2.title, dataRef));
  }
  return parseMark(guideGroup({
    role: AxisRole2,
    from: dataRef,
    encode: extendEncode(buildAxisEncode(_, spec), axisEncode, Skip3),
    marks: children3,
    aria: _("aria"),
    description: _("description"),
    zindex: _("zindex"),
    name,
    interactive: interactive2,
    style: style2
  }), scope);
}
function buildAxisEncode(_, spec) {
  const encode2 = {
    enter: {},
    update: {}
  };
  addEncoders(encode2, {
    orient: _("orient"),
    offset: _("offset") || 0,
    position: value2(spec.position, 0),
    titlePadding: _("titlePadding"),
    minExtent: _("minExtent"),
    maxExtent: _("maxExtent"),
    range: {
      signal: `abs(span(range("${spec.scale}")))`
    },
    translate: _("translate"),
    // accessibility support
    format: spec.format,
    formatType: spec.formatType
  });
  return encode2;
}
function parseScope(spec, scope, preprocessed) {
  const signals = array(spec.signals), scales2 = array(spec.scales);
  if (!preprocessed)
    signals.forEach((_) => parseSignal(_, scope));
  array(spec.projections).forEach((_) => parseProjection(_, scope));
  scales2.forEach((_) => initScale(_, scope));
  array(spec.data).forEach((_) => parseData(_, scope));
  scales2.forEach((_) => parseScale(_, scope));
  (preprocessed || signals).forEach((_) => parseSignalUpdates(_, scope));
  array(spec.axes).forEach((_) => parseAxis(_, scope));
  array(spec.marks).forEach((_) => parseMark(_, scope));
  array(spec.legends).forEach((_) => parseLegend(_, scope));
  if (spec.title)
    parseTitle(spec.title, scope);
  scope.parseLambdas();
  return scope;
}
var rootEncode = (spec) => extendEncode({
  enter: {
    x: {
      value: 0
    },
    y: {
      value: 0
    }
  },
  update: {
    width: {
      signal: "width"
    },
    height: {
      signal: "height"
    }
  }
}, spec);
function parseView(spec, scope) {
  const config = scope.config;
  const root = ref(scope.root = scope.add(operator()));
  const signals = collectSignals(spec, config);
  signals.forEach((_) => parseSignal(_, scope));
  scope.description = spec.description || config.description;
  scope.eventConfig = config.events;
  scope.legends = scope.objectProperty(config.legend && config.legend.layout);
  scope.locale = config.locale;
  const input = scope.add(Collect2());
  const encode2 = scope.add(Encode2(parseEncode(rootEncode(spec.encode), GroupMark, FrameRole2, spec.style, scope, {
    pulse: ref(input)
  })));
  const parent = scope.add(ViewLayout2({
    layout: scope.objectProperty(spec.layout),
    legends: scope.legends,
    autosize: scope.signalRef("autosize"),
    mark: root,
    pulse: ref(encode2)
  }));
  scope.operators.pop();
  scope.pushState(ref(encode2), ref(parent), null);
  parseScope(spec, scope, signals);
  scope.operators.push(parent);
  let op = scope.add(Bound2({
    mark: root,
    pulse: ref(parent)
  }));
  op = scope.add(Render2({
    pulse: ref(op)
  }));
  op = scope.add(Sieve2({
    pulse: ref(op)
  }));
  scope.addData("root", new DataScope(scope, input, input, op));
  return scope;
}
function signalObject(name, value3) {
  return value3 && value3.signal ? {
    name,
    update: value3.signal
  } : {
    name,
    value: value3
  };
}
function collectSignals(spec, config) {
  const _ = (name) => value2(spec[name], config[name]), signals = [signalObject("background", _("background")), signalObject("autosize", parseAutosize(_("autosize"))), signalObject("padding", parsePadding(_("padding"))), signalObject("width", _("width") || 0), signalObject("height", _("height") || 0)], pre = signals.reduce((p, s) => (p[s.name] = s, p), {}), map2 = {};
  array(spec.signals).forEach((s) => {
    if (has(pre, s.name)) {
      s = extend(pre[s.name], s);
    } else {
      signals.push(s);
    }
    map2[s.name] = s;
  });
  array(config.signals).forEach((s) => {
    if (!has(map2, s.name) && !has(pre, s.name)) {
      signals.push(s);
    }
  });
  return signals;
}
function Scope(config, options) {
  this.config = config || {};
  this.options = options || {};
  this.bindings = [];
  this.field = {};
  this.signals = {};
  this.lambdas = {};
  this.scales = {};
  this.events = {};
  this.data = {};
  this.streams = [];
  this.updates = [];
  this.operators = [];
  this.eventConfig = null;
  this.locale = null;
  this._id = 0;
  this._subid = 0;
  this._nextsub = [0];
  this._parent = [];
  this._encode = [];
  this._lookup = [];
  this._markpath = [];
}
function Subscope(scope) {
  this.config = scope.config;
  this.options = scope.options;
  this.legends = scope.legends;
  this.field = Object.create(scope.field);
  this.signals = Object.create(scope.signals);
  this.lambdas = Object.create(scope.lambdas);
  this.scales = Object.create(scope.scales);
  this.events = Object.create(scope.events);
  this.data = Object.create(scope.data);
  this.streams = [];
  this.updates = [];
  this.operators = [];
  this._id = 0;
  this._subid = ++scope._nextsub[0];
  this._nextsub = scope._nextsub;
  this._parent = scope._parent.slice();
  this._encode = scope._encode.slice();
  this._lookup = scope._lookup.slice();
  this._markpath = scope._markpath;
}
Scope.prototype = Subscope.prototype = {
  parse(spec) {
    return parseScope(spec, this);
  },
  fork() {
    return new Subscope(this);
  },
  isSubscope() {
    return this._subid > 0;
  },
  toRuntime() {
    this.finish();
    return {
      description: this.description,
      operators: this.operators,
      streams: this.streams,
      updates: this.updates,
      bindings: this.bindings,
      eventConfig: this.eventConfig,
      locale: this.locale
    };
  },
  id() {
    return (this._subid ? this._subid + ":" : 0) + this._id++;
  },
  add(op) {
    this.operators.push(op);
    op.id = this.id();
    if (op.refs) {
      op.refs.forEach((ref2) => {
        ref2.$ref = op.id;
      });
      op.refs = null;
    }
    return op;
  },
  proxy(op) {
    const vref = op instanceof Entry ? ref(op) : op;
    return this.add(Proxy2({
      value: vref
    }));
  },
  addStream(stream2) {
    this.streams.push(stream2);
    stream2.id = this.id();
    return stream2;
  },
  addUpdate(update3) {
    this.updates.push(update3);
    return update3;
  },
  // Apply metadata
  finish() {
    let name, ds;
    if (this.root)
      this.root.root = true;
    for (name in this.signals) {
      this.signals[name].signal = name;
    }
    for (name in this.scales) {
      this.scales[name].scale = name;
    }
    function annotate(op, name2, type2) {
      let data3, list;
      if (op) {
        data3 = op.data || (op.data = {});
        list = data3[name2] || (data3[name2] = []);
        list.push(type2);
      }
    }
    for (name in this.data) {
      ds = this.data[name];
      annotate(ds.input, name, "input");
      annotate(ds.output, name, "output");
      annotate(ds.values, name, "values");
      for (const field3 in ds.index) {
        annotate(ds.index[field3], name, "index:" + field3);
      }
    }
    return this;
  },
  // ----
  pushState(encode2, parent, lookup6) {
    this._encode.push(ref(this.add(Sieve2({
      pulse: encode2
    }))));
    this._parent.push(parent);
    this._lookup.push(lookup6 ? ref(this.proxy(lookup6)) : null);
    this._markpath.push(-1);
  },
  popState() {
    this._encode.pop();
    this._parent.pop();
    this._lookup.pop();
    this._markpath.pop();
  },
  parent() {
    return peek(this._parent);
  },
  encode() {
    return peek(this._encode);
  },
  lookup() {
    return peek(this._lookup);
  },
  markpath() {
    const p = this._markpath;
    return ++p[p.length - 1];
  },
  // ----
  fieldRef(field3, name) {
    if (isString(field3))
      return fieldRef$1(field3, name);
    if (!field3.signal) {
      error("Unsupported field reference: " + $(field3));
    }
    const s = field3.signal;
    let f = this.field[s];
    if (!f) {
      const params2 = {
        name: this.signalRef(s)
      };
      if (name)
        params2.as = name;
      this.field[s] = f = ref(this.add(Field2(params2)));
    }
    return f;
  },
  compareRef(cmp) {
    let signal = false;
    const check = (_) => isSignal(_) ? (signal = true, this.signalRef(_.signal)) : isExpr$1(_) ? (signal = true, this.exprRef(_.expr)) : _;
    const fields = array(cmp.field).map(check), orders = array(cmp.order).map(check);
    return signal ? ref(this.add(Compare2({
      fields,
      orders
    }))) : compareRef(fields, orders);
  },
  keyRef(fields, flat) {
    let signal = false;
    const check = (_) => isSignal(_) ? (signal = true, ref(sig[_.signal])) : _;
    const sig = this.signals;
    fields = array(fields).map(check);
    return signal ? ref(this.add(Key2({
      fields,
      flat
    }))) : keyRef(fields, flat);
  },
  sortRef(sort2) {
    if (!sort2)
      return sort2;
    const a = aggrField(sort2.op, sort2.field), o = sort2.order || Ascending;
    return o.signal ? ref(this.add(Compare2({
      fields: a,
      orders: this.signalRef(o.signal)
    }))) : compareRef(a, o);
  },
  // ----
  event(source3, type2) {
    const key2 = source3 + ":" + type2;
    if (!this.events[key2]) {
      const id2 = this.id();
      this.streams.push({
        id: id2,
        source: source3,
        type: type2
      });
      this.events[key2] = id2;
    }
    return this.events[key2];
  },
  // ----
  hasOwnSignal(name) {
    return has(this.signals, name);
  },
  addSignal(name, value3) {
    if (this.hasOwnSignal(name)) {
      error("Duplicate signal name: " + $(name));
    }
    const op = value3 instanceof Entry ? value3 : this.add(operator(value3));
    return this.signals[name] = op;
  },
  getSignal(name) {
    if (!this.signals[name]) {
      error("Unrecognized signal name: " + $(name));
    }
    return this.signals[name];
  },
  signalRef(s) {
    if (this.signals[s]) {
      return ref(this.signals[s]);
    } else if (!has(this.lambdas, s)) {
      this.lambdas[s] = this.add(operator(null));
    }
    return ref(this.lambdas[s]);
  },
  parseLambdas() {
    const code = Object.keys(this.lambdas);
    for (let i = 0, n = code.length; i < n; ++i) {
      const s = code[i], e = parser2(s, this), op = this.lambdas[s];
      op.params = e.$params;
      op.update = e.$expr;
    }
  },
  property(spec) {
    return spec && spec.signal ? this.signalRef(spec.signal) : spec;
  },
  objectProperty(spec) {
    return !spec || !isObject(spec) ? spec : this.signalRef(spec.signal || propertyLambda(spec));
  },
  exprRef(code, name) {
    const params2 = {
      expr: parser2(code, this)
    };
    if (name)
      params2.expr.$name = name;
    return ref(this.add(Expression2(params2)));
  },
  addBinding(name, bind3) {
    if (!this.bindings) {
      error("Nested signals do not support binding: " + $(name));
    }
    this.bindings.push(extend({
      signal: name
    }, bind3));
  },
  // ----
  addScaleProj(name, transform4) {
    if (has(this.scales, name)) {
      error("Duplicate scale or projection name: " + $(name));
    }
    this.scales[name] = this.add(transform4);
  },
  addScale(name, params2) {
    this.addScaleProj(name, Scale2(params2));
  },
  addProjection(name, params2) {
    this.addScaleProj(name, Projection2(params2));
  },
  getScale(name) {
    if (!this.scales[name]) {
      error("Unrecognized scale name: " + $(name));
    }
    return this.scales[name];
  },
  scaleRef(name) {
    return ref(this.getScale(name));
  },
  scaleType(name) {
    return this.getScale(name).params.type;
  },
  projectionRef(name) {
    return this.scaleRef(name);
  },
  projectionType(name) {
    return this.scaleType(name);
  },
  // ----
  addData(name, dataScope) {
    if (has(this.data, name)) {
      error("Duplicate data set name: " + $(name));
    }
    return this.data[name] = dataScope;
  },
  getData(name) {
    if (!this.data[name]) {
      error("Undefined data set name: " + $(name));
    }
    return this.data[name];
  },
  addDataPipeline(name, entries) {
    if (has(this.data, name)) {
      error("Duplicate data set name: " + $(name));
    }
    return this.addData(name, DataScope.fromEntries(this, entries));
  }
};
function propertyLambda(spec) {
  return (isArray(spec) ? arrayLambda : objectLambda)(spec);
}
function arrayLambda(array4) {
  const n = array4.length;
  let code = "[";
  for (let i = 0; i < n; ++i) {
    const value3 = array4[i];
    code += (i > 0 ? "," : "") + (isObject(value3) ? value3.signal || propertyLambda(value3) : $(value3));
  }
  return code + "]";
}
function objectLambda(obj) {
  let code = "{", i = 0, key2, value3;
  for (key2 in obj) {
    value3 = obj[key2];
    code += (++i > 1 ? "," : "") + $(key2) + ":" + (isObject(value3) ? value3.signal || propertyLambda(value3) : $(value3));
  }
  return code + "}";
}
function defaults() {
  const defaultFont = "sans-serif", defaultSymbolSize = 30, defaultStrokeWidth = 2, defaultColor = "#4c78a8", black = "#000", gray = "#888", lightGray = "#ddd";
  return {
    // default visualization description
    description: "Vega visualization",
    // default padding around visualization
    padding: 0,
    // default for automatic sizing; options: 'none', 'pad', 'fit'
    // or provide an object (e.g., {'type': 'pad', 'resize': true})
    autosize: "pad",
    // default view background color
    // covers the entire view component
    background: null,
    // default event handling configuration
    // preventDefault for view-sourced event types except 'wheel'
    events: {
      defaults: {
        allow: ["wheel"]
      }
    },
    // defaults for top-level group marks
    // accepts mark properties (fill, stroke, etc)
    // covers the data rectangle within group width/height
    group: null,
    // defaults for basic mark types
    // each subset accepts mark properties (fill, stroke, etc)
    mark: null,
    arc: {
      fill: defaultColor
    },
    area: {
      fill: defaultColor
    },
    image: null,
    line: {
      stroke: defaultColor,
      strokeWidth: defaultStrokeWidth
    },
    path: {
      stroke: defaultColor
    },
    rect: {
      fill: defaultColor
    },
    rule: {
      stroke: black
    },
    shape: {
      stroke: defaultColor
    },
    symbol: {
      fill: defaultColor,
      size: 64
    },
    text: {
      fill: black,
      font: defaultFont,
      fontSize: 11
    },
    trail: {
      fill: defaultColor,
      size: defaultStrokeWidth
    },
    // style definitions
    style: {
      // axis & legend labels
      "guide-label": {
        fill: black,
        font: defaultFont,
        fontSize: 10
      },
      // axis & legend titles
      "guide-title": {
        fill: black,
        font: defaultFont,
        fontSize: 11,
        fontWeight: "bold"
      },
      // headers, including chart title
      "group-title": {
        fill: black,
        font: defaultFont,
        fontSize: 13,
        fontWeight: "bold"
      },
      // chart subtitle
      "group-subtitle": {
        fill: black,
        font: defaultFont,
        fontSize: 12
      },
      // defaults for styled point marks in Vega-Lite
      point: {
        size: defaultSymbolSize,
        strokeWidth: defaultStrokeWidth,
        shape: "circle"
      },
      circle: {
        size: defaultSymbolSize,
        strokeWidth: defaultStrokeWidth
      },
      square: {
        size: defaultSymbolSize,
        strokeWidth: defaultStrokeWidth,
        shape: "square"
      },
      // defaults for styled group marks in Vega-Lite
      cell: {
        fill: "transparent",
        stroke: lightGray
      },
      view: {
        fill: "transparent"
      }
    },
    // defaults for title
    title: {
      orient: "top",
      anchor: "middle",
      offset: 4,
      subtitlePadding: 3
    },
    // defaults for axes
    axis: {
      minExtent: 0,
      maxExtent: 200,
      bandPosition: 0.5,
      domain: true,
      domainWidth: 1,
      domainColor: gray,
      grid: false,
      gridWidth: 1,
      gridColor: lightGray,
      labels: true,
      labelAngle: 0,
      labelLimit: 180,
      labelOffset: 0,
      labelPadding: 2,
      ticks: true,
      tickColor: gray,
      tickOffset: 0,
      tickRound: true,
      tickSize: 5,
      tickWidth: 1,
      titlePadding: 4
    },
    // correction for centering bias
    axisBand: {
      tickOffset: -0.5
    },
    // defaults for cartographic projection
    projection: {
      type: "mercator"
    },
    // defaults for legends
    legend: {
      orient: "right",
      padding: 0,
      gridAlign: "each",
      columnPadding: 10,
      rowPadding: 2,
      symbolDirection: "vertical",
      gradientDirection: "vertical",
      gradientLength: 200,
      gradientThickness: 16,
      gradientStrokeColor: lightGray,
      gradientStrokeWidth: 0,
      gradientLabelOffset: 2,
      labelAlign: "left",
      labelBaseline: "middle",
      labelLimit: 160,
      labelOffset: 4,
      labelOverlap: true,
      symbolLimit: 30,
      symbolType: "circle",
      symbolSize: 100,
      symbolOffset: 0,
      symbolStrokeWidth: 1.5,
      symbolBaseFillColor: "transparent",
      symbolBaseStrokeColor: gray,
      titleLimit: 180,
      titleOrient: "top",
      titlePadding: 5,
      layout: {
        offset: 18,
        direction: "horizontal",
        left: {
          direction: "vertical"
        },
        right: {
          direction: "vertical"
        }
      }
    },
    // defaults for scale ranges
    range: {
      category: {
        scheme: "tableau10"
      },
      ordinal: {
        scheme: "blues"
      },
      heatmap: {
        scheme: "yellowgreenblue"
      },
      ramp: {
        scheme: "blues"
      },
      diverging: {
        scheme: "blueorange",
        extent: [1, 0]
      },
      symbol: ["circle", "square", "triangle-up", "cross", "diamond", "triangle-right", "triangle-down", "triangle-left"]
    }
  };
}
function parse6(spec, config, options) {
  if (!isObject(spec)) {
    error("Input Vega specification must be an object.");
  }
  config = mergeConfig(defaults(), config, spec.config);
  return parseView(spec, new Scope(config, options)).toRuntime();
}

// node_modules/vega/build/vega.module.js
var version = "5.28.0";
extend(transforms, vega_transforms_module_exports, vega_view_transforms_module_exports, vega_encode_module_exports, vega_geo_module_exports, vega_force_module_exports, vega_label_module_exports, vega_hierarchy_module_exports, vega_regression_module_exports, vega_voronoi_module_exports, vega_wordcloud_module_exports, vega_crossfilter_module_exports);

export {
  accessor,
  accessorName,
  accessorFields,
  error,
  splitAccessPath,
  field,
  id,
  identity2 as identity,
  zero,
  one,
  truthy,
  falsy,
  None,
  Error$1,
  Warn,
  Info,
  Debug,
  logger,
  isArray,
  isObject,
  mergeConfig,
  writeConfig,
  peek,
  toNumber,
  panLinear,
  panLog,
  panPow,
  panSymlog,
  zoomLinear,
  zoomLog,
  zoomPow,
  zoomSymlog,
  quarter,
  utcquarter,
  array,
  clampRange,
  isFunction,
  compare,
  ascending2 as ascending,
  constant,
  debounce,
  extend,
  extent,
  extentIndex,
  has,
  fastmap,
  flush,
  inherits,
  inrange,
  isBoolean,
  isDate,
  isIterable,
  isNumber,
  isRegExp,
  isString,
  key,
  lerp,
  lruCache,
  merge,
  repeat,
  pad,
  span,
  $,
  toBoolean,
  toDate,
  toString,
  toSet,
  truncate,
  visitArray,
  YEAR,
  QUARTER,
  MONTH,
  WEEK,
  DATE,
  DAY,
  DAYOFYEAR,
  HOURS,
  MINUTES,
  SECONDS,
  MILLISECONDS,
  TIME_UNITS,
  timeUnits,
  timeUnitSpecifier,
  dayofyear,
  week,
  utcdayofyear,
  utcweek,
  timeFloor,
  utcFloor,
  timeInterval,
  utcInterval,
  timeOffset,
  utcOffset,
  timeSequence,
  utcSequence,
  bin,
  numberFormatDefaultLocale,
  timeFormatDefaultLocale,
  locale,
  defaultLocale,
  resetDefaultLocale,
  typeParsers,
  inferType,
  inferTypes,
  format2 as format,
  formats,
  responseType,
  read,
  loader,
  isTuple,
  tupleid,
  ingest$1,
  changeset,
  Parameters,
  Operator,
  EventStream,
  Pulse,
  MultiPulse,
  Dataflow,
  Transform,
  transforms,
  definition,
  transform,
  quantiles,
  quartiles,
  estimateBandwidth,
  bin2,
  random,
  setRandom,
  bootstrapCI,
  dotbin,
  lcg,
  integer,
  sampleNormal,
  densityNormal,
  cumulativeNormal,
  quantileNormal,
  gaussian,
  kde,
  sampleLogNormal,
  densityLogNormal,
  cumulativeLogNormal,
  quantileLogNormal,
  lognormal,
  mixture,
  sampleUniform,
  densityUniform,
  cumulativeUniform,
  quantileUniform,
  uniform,
  constant2,
  linear2 as linear,
  log3 as log,
  exp2 as exp,
  pow3 as pow,
  quad,
  poly,
  loess,
  sampleCurve,
  scale,
  interpolateRange,
  interpolateColors,
  quantizeInterpolator,
  interpolate,
  scheme,
  Gradient,
  curves,
  parse4 as parse,
  pathRender,
  symbols2 as symbols,
  vg_rect,
  vg_trail,
  resetSVGClipId,
  Bounds,
  Item,
  GroupItem,
  ResourceLoader,
  boundStroke,
  boundContext,
  intersectPath,
  intersectPoint,
  intersectRule,
  intersectBoxLine,
  zorder,
  visit,
  pickVisit,
  textMetrics,
  fontSize,
  lineHeight,
  multiLineOffset,
  fontFamily,
  font,
  Marks,
  boundItem,
  boundMark,
  sceneToJSON,
  sceneFromJSON,
  Scenegraph,
  domCreate,
  domFind,
  domChild,
  domClear,
  point2 as point,
  Handler,
  Renderer,
  CanvasHandler,
  CanvasRenderer,
  SVGHandler,
  markup,
  serializeXML,
  SVGRenderer,
  SVGStringRenderer,
  setHybridRendererOptions,
  HybridRenderer,
  HybridHandler,
  RenderType,
  renderModule,
  intersect,
  boundClip,
  sceneEqual,
  pathEqual,
  resetSVGDefIds,
  projection2 as projection,
  parser,
  codegen,
  expressionFunction,
  context2 as context,
  View,
  eventSelector,
  parse6 as parse2,
  version,
  vega_module_exports
};
//# sourceMappingURL=chunk-SXJFFO5I.js.map
